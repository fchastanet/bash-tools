#!/usr/bin/env bash
###############################################################################
# GENERATED FROM https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/Converters/mysql2puml/mysql2puml-binary.yaml
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034



# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM


SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3


# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}


# @description concatenate each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}


# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}


# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  tty -s
}


read -r -d '\0' bashToolsDefaultConfigTemplate <<-EOM || true
##!/usr/bin/env bash
# shellcheck disable=SC2034

# Default settings
# you can override these settings by creating ${HOME}/.bash-tools/.env file

###
### DISPLAY Level
### minimum level of the messages that will be displayed on screen
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}

###
### DISPLAY duration
### 0: no duration is displayed on the messages
### 1: duration between previous message and current is displayed
### with the message
###
DISPLAY_DURATION=${DISPLAY_DURATION:0}

###
### Log to file
###
### all log messages will be redirected to log file specified
### this same path will be used inside and outside of the container
###
BASH_FRAMEWORK_LOG_FILE=${BASH_FRAMEWORK_LOG_FILE:-${BASH_TOOLS_ROOT_DIR}/logs/bash.log}

###
### LOG Level
### minimum level of the messages that will be logged into LOG_FILE
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}

# absolute directory containing db import sql dumps
DB_IMPORT_DUMP_DIR=${DB_IMPORT_DUMP_DIR:-${HOME}/.bash-tools/dbImportDumps}

# garbage collect all files for which modification is greater than eg: 30 days (+30)
# each time an existing file is used by dbImport/dbImportTable
# the file modification time is set to now
DB_IMPORT_GARBAGE_COLLECT_DAYS=${DB_IMPORT_GARBAGE_COLLECT_DAYS:-+30}

# absolute directory containing dbScripts used by dbScriptAllDatabases
SCRIPTS_FOLDER=${SCRIPTS_FOLDER:-${HOME}/.bash-tools/conf/dbScripts}

# -----------------------------------------------------
# AWS Parameters
# -----------------------------------------------------
S3_BASE_URL=${S3_BASE_URL:-}

# -----------------------------------------------------
# Postman Parameters
# -----------------------------------------------------
POSTMAN_API_KEY=
EOM

# @description loads ~/.bash-tools/.env if available
# if not creates it from a default template
# else check if new options need to be added
BashTools::Conf::requireLoad() {
  BASH_TOOLS_ROOT_DIR="$(cd "${CURRENT_DIR}/${RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR}" && pwd -P)"
  if [[ -d "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework/" ]]; then
    FRAMEWORK_ROOT_DIR="$(cd "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
  else
    # if the directory does not exist yet, give a value to FRAMEWORK_ROOT_DIR
    FRAMEWORK_ROOT_DIR="${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework"
  fi
  # shellcheck disable=SC2034
  FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
  # shellcheck disable=SC2034
  FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

  if [[ -f "${HOME}/.bash-tools/.env" ]]; then
    # shellcheck disable=SC2034
    BASH_FRAMEWORK_ENV_FILES=("${HOME}/.bash-tools/.env")
  fi

  local envFile="${HOME}/.bash-tools/.env"
  if [[ ! -f "${envFile}" ]]; then
    mkdir -p "${HOME}/.bash-tools"
    (
      echo "#!/usr/bin/env bash"
      # shellcheck disable=SC2154
      echo "${bashToolsDefaultConfigTemplate}"
    ) >"${envFile}"
    Log::displayInfo "Configuration file '${envFile}' created"
  else
    if ! grep -q '^POSTMAN_API_KEY=' "${envFile}"; then
      (
        echo '# -----------------------------------------------------'
        echo '# Postman Parameters'
        echo '# -----------------------------------------------------'
        echo 'POSTMAN_API_KEY='
      ) >>"${envFile}"
    fi
  fi
  # shellcheck source=/conf/defaultEnv/.env
  source "${envFile}" || {
    Log::displayError "impossible to load '${envFile}'"
    exit 1
  }
}


# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}


# @description get absolute conf file from specified conf folder deduced using these rules
#   * from absolute file (ignores <confFolder> and <extension>)
#   * relative to where script is executed (ignores <confFolder> and <extension>)
#   * from home/.bash-tools/<confFolder>
#   * from framework conf/<confFolder>
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 conf:String file to use without extension
# @arg $3 extension:String the extension (.sh by default)
#
# @stdout absolute conf filename
# @exitcode 1 if file is not found in any location
Conf::getAbsoluteFile() {
  local confFolder="$1"
  local conf="$2"
  local extension="${3-.sh}"
  if [[ -n "${extension}" && "${extension:0:1}" != "." ]]; then
    extension=".${extension}"
  fi

  testAbs() {
    local result
    result="$(realpath -e "$1" 2>/dev/null)"
    # shellcheck disable=SC2181
    if [[ "$?" = "0" && -f "${result}" ]]; then
      echo "${result}"
      return 0
    fi
    return 1
  }

  # conf is absolute file (including extension)
  testAbs "${confFolder}${extension}" && return 0
  # conf is absolute file
  testAbs "${confFolder}" && return 0
  # conf is absolute file (including extension)
  testAbs "${conf}${extension}" && return 0
  # conf is absolute file
  testAbs "${conf}" && return 0

  # relative to where script is executed (including extension)
  if [[ -n "${CURRENT_DIR+xxx}" ]]; then
    testAbs "$(File::concatenatePath "${CURRENT_DIR}" "${confFolder}")/${conf}${extension}" && return 0
  fi
  # from home/.bash-tools/<confFolder>
  testAbs "$(File::concatenatePath "${HOME}/.bash-tools" "${confFolder}")/${conf}${extension}" && return 0

  if [[ -n "${FRAMEWORK_ROOT_DIR+xxx}" ]]; then
    # from framework conf/<confFolder> (including extension)
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}${extension}" && return 0

    # from framework conf/<confFolder>
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}" && return 0
  fi

  # file not found
  Log::displayError "conf file '${conf}' not found"

  return 1
}


# @description list the conf files list available in bash-tools/conf/<conf> folder
# and those overridden in ${HOME}/.bash-tools/<conf> folder
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 extension:String the extension (.sh by default)
# @arg $3 indentStr:String the indentation ('       - ' by default) can be any string compatible with sed not containing any /
#
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
Conf::getMergedList() {
  local confFolder="$1"
  local extension="${2-sh}"
  local indentStr="${3-       - }"

  local DEFAULT_CONF_DIR="${FRAMEWORK_ROOT_DIR}/conf/${confFolder}"
  local HOME_CONF_DIR="${HOME}/.bash-tools/${confFolder}"

  (
    if [[ -d "${DEFAULT_CONF_DIR}" ]]; then
      Conf::list "${DEFAULT_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
    if [[ -d "${HOME_CONF_DIR}" ]]; then
      Conf::list "${HOME_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
  ) | sort | uniq
}


# @description list files of dir with given extension and display it as a list one by line
#
# @arg $1 dir:String the directory to list
# @arg $2 prefix:String the profile file prefix (default: "")
# @arg $3 ext:String the extension
# @arg $4 findOptions:String find options, eg: -type d (Default value: '-type f')
# @arg $5 indentStr:String the indentation can be any string compatible with sed not containing any / (Default value: '       - ')
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
# @exitcode 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}


# @description Load the nearest config file
# in next example will search first .framework-config file in "srcDir1"
# then if not found will go in up directories until /
# then will search in "srcDir2"
# then if not found will go in up directories until /
# source the file if found
# @example
#   Conf::loadNearestFile ".framework-config" "srcDir1" "srcDir2"
#
# @arg $1 configFileName:String config file name to search
# @arg $2 loadedFile:String (passed by reference) will return the loaded config file name
# @arg $@ srcDirs:String[] source directories in which the config file will be searched
# @exitcode 0 if file found
# @exitcode 1 if file not found
Conf::loadNearestFile() {
  local configFileName="$1"
  local -n loadedFile="$2"
  shift 2 || true
  local -a srcDirs=("$@")
  for srcDir in "${srcDirs[@]}"; do
    configFile="$(File::upFind "${srcDir}" "${configFileName}" || true)"
    if [[ -n "${configFile}" ]]; then
      # shellcheck source=/.framework-config
      source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
      Log::displayDebug "Config file ${configFile} is loaded"
      # shellcheck disable=SC2034
      loadedFile="${configFile}"
      return 0
    fi
  done

  Log::displayDebug "Config file '${configFileName}' not found in any source directories provided"
  return 1
}


# @description default env file with all default values
# @stdout the default env filepath
Env::createDefaultEnvFile() {
  local envFile
  envFile="$(Framework::createTempFile "createDefaultEnvFileEnvFile")" || return 2

  (
    echo "BASH_FRAMEWORK_THEME=${BASH_FRAMEWORK_THEME:-default}"
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
    # shellcheck disable=SC2016
    echo 'BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"'
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${envFile}"
  echo "${envFile}"
}


# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}


# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  export REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED=1

  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  local defaultEnvFile
  defaultEnvFile="$(Env::createDefaultEnvFile)" || return 1
  configFiles+=("${defaultEnvFile}")
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  local localFrameworkConfigFile
  BASH_FRAMEWORK_DISPLAY_LEVEL="${__LEVEL_INFO}" \
    BASH_FRAMEWORK_LOG_LEVEL="${__LEVEL_OFF}" \
    Conf::loadNearestFile ".framework-config" localFrameworkConfigFile "$(pwd)" || true
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  while IFS='' read -r file; do
    # shellcheck source=/src/Env/createDefaultEnvFile.sh
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done < <(printf '%s\n' "${configFiles[@]}" | awk '!x[$0]++')
}


# @description concatenate 2 paths and ensure the path is correct using realpath -m
# @arg $1 basePath:String
# @arg $2 subPath:String
File::concatenatePath() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_REALPATH_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireRealpathCommand has not been loaded"
    exit 1
  fi

  local basePath="$1"
  local subPath="$2"
  local fullPath="${basePath:+${basePath}/}${subPath}"

  realpath -m "${fullPath}" 2>/dev/null
}


# @description search a file in parent directories
#
# @arg $1 fromPath:String path
# @arg $2 fileName:String
# @arg $3 untilInclusivePath:String (optional) find for given file until reaching this folder (default value: /)
# @arg $@ untilInclusivePaths:String[] list of untilInclusivePath
# @stdout The filename if found
# @exitcode 1 if the command failed or file not found
File::upFind() {
  local fromPath="$1"
  shift || true
  local fileName="$1"
  shift || true
  local untilInclusivePath="${1:-/}"
  shift || true

  if [[ -f "${fromPath}" ]]; then
    fromPath="${fromPath%/*}"
  fi
  while true; do
    if [[ -f "${fromPath}/${fileName}" ]]; then
      echo "${fromPath}/${fileName}"
      return 0
    fi
    if Array::contains "${fromPath}" "${untilInclusivePath}" "$@" "/"; then
      return 1
    fi
    fromPath="$(readlink -f "${fromPath}"/..)"
  done
  return 1
}


# @description remove all empty lines
# - at the beginning of the file before non empty line
# - at the end of the file after last non empty line
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
# @see https://unix.stackexchange.com/a/653883
Filters::trimEmptyLines() {
  awk '
    NF {print saved $0; saved = ""; started = 1; next}
    started {saved = saved $0 ORS}
  ' "$@"
}


# @description create a temp file using default TMPDIR variable
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}


# @description ensure command realpath is available
# @exitcode 1 if realpath command not available
# @stderr diagnostics information is displayed
Linux::requireRealpathCommand() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_REALPATH_COMMAND_LOADED=1

  Assert::commandExists realpath
}


# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  Assert::commandExists tar
}


declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description compute duration since last call to this function
# the result is set in following env variables.
# in ss.sss (seconds followed by milliseconds precision 3 decimals)
# @noargs
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @set LOG_LAST_LOG_DATE_INIT int (default 1) set to 0 at first call, allows to detect reference log
# @set LOG_LAST_DURATION_STR String the last duration displayed
# @set LOG_LAST_LOG_DATE String the last log date that will be used to compute next diff
Log::computeDuration() {
  if ((${DISPLAY_DURATION:-0} == 1)); then
    local -i duration=0
    local -i delta=0
    local durationStr deltaStr
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      if ((duration > 59)); then
        durationStr=$(date -ud "@${duration}" +'%H:%M:%S')
      else
        durationStr="${duration}s"
      fi
      if ((delta > 59)); then
        deltaStr=$(date -ud "@${delta}" +'%H:%M:%S')
      else
        deltaStr="${delta}s"
      fi
      LOG_LAST_DURATION_STR="${durationStr}/+${deltaStr}"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}


# @description Display message using debug color (gray)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}


# @description Display message using error color (red)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}


# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}


# @description Get the text representation of a log level
# @arg $1 level:String the log level to convert
# @exitcode 1 if the level is invalid
Log::getLevelText() {
  local level="$1"
  case "${level}" in
    "${__LEVEL_OFF}")
      echo OFF
      ;;
    "${__LEVEL_ERROR}")
      echo ERROR
      ;;
    "${__LEVEL_WARNING}")
      echo WARNING
      ;;
    "${__LEVEL_INFO}")
      echo INFO
      ;;
    "${__LEVEL_DEBUG}")
      echo DEBUG
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}


# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
Log::logMessage() {

  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Log::requireLoad has not been loaded"
    exit 1
  fi

  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}


# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
Log::requireLoad() {
  export REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED=1


  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement UI::requireTheme has not been loaded"
    exit 1
  fi

  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}


# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}


# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  local -i width=${COLUMNS:-0}
  if ((width == 0)) && [[ -t 1 ]]; then
    width=$(tput cols)
  fi
  if ((width == 0)); then
    width=80
  fi
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 1 ]] && tput cols || echo '80')}")
  echo
}


# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  export REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED=1

  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}


# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Gray
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}
# FUNCTIONS

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

beforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

copyrightCallback() {
  #
  # shellcheck disable=SC2155,SC2154,SC2250
  echo "Copyright (c) 2021-now FranÃ§ois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  Log::displayError "optionHelpCallback needs to be overridden"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${levelName}"
      return 1
      ;;
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionDisplayLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionLogLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >>"${overrideEnvFile}"
}

optionLogFileDefaultValueFunction() {
  # shellcheck disable=SC2016
  echo "${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}



defaultBeforeParseCallback() {
  BashTools::Conf::requireLoad
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

beforeParseCallback() {
  defaultBeforeParseCallback
}



# shellcheck disable=SC2034
declare optionBashFrameworkConfig="${BASH_TOOLS_ROOT_DIR}/.framework-config"

optionHelpCallback() {
  mysql2pumlCommandHelp
  exit 0
}

longDescriptionFunction() {
  echo -e "${__HELP_TITLE}EXAMPLE 1:${__HELP_NORMAL}"
  echo -e "${__HELP_EXAMPLE}mysql2puml dump.dql${__HELP_NORMAL}"
  echo
  echo -e "${__HELP_TITLE}EXAMPLE 2:${__HELP_NORMAL}"
  echo -e "${__HELP_EXAMPLE}mysqldump --skip-add-drop-table \\"
  echo -e "  --skip-add-locks \\"
  echo -e "  --skip-disable-keys \\"
  echo -e "  --skip-set-charset \\"
  echo -e "  --user=root \\"
  echo -e "  --password=root \\"
  echo -e "  --no-data skills | mysql2puml"
  echo -e "${__HELP_NORMAL}"
  echo -e "${__HELP_TITLE}LIST OF AVAILABLE SKINS:${__HELP_NORMAL}"
  Conf::getMergedList "mysql2pumlSkins" ".puml" "  - "
}

# shellcheck disable=SC2317
inputSqlFileCallback() {
  # shellcheck disable=SC2154
  if [[ ! -f "${inputSqlFile}" ]]; then
    Log::displayError "${SCRIPT_NAME} - File '${inputSqlFile}' does not exists"
    return 1
  fi
}

optionSkinCallback() {
  declare -a skinList
  readarray -t skinList < <(Conf::getMergedList "mysql2pumlSkins" ".puml" "")
  # shellcheck disable=SC2154
  if ! Array::contains "${optionSkin}" "${skinList[@]}"; then
    Log::displayError "${SCRIPT_NAME} - invalid skin '${optionSkin}' provided"
    exit 1
  fi
}

inputSqlFileCallback() {
  # shellcheck disable=SC2154
  if [[ ! -f "${inputSqlFile}" ]]; then
    Log::displayError "${SCRIPT_NAME} - File '${inputSqlFile}' does not exists"
    exit 1
  fi
}


# ------------------------------------------
# Command mysql2pumlCommand
# ------------------------------------------

# options variables initialization
declare optionHelp="0"
declare optionConfig="0"
declare optionBashFrameworkConfig=""
declare optionInfoVerbose="0"
declare optionDebugVerbose="0"
declare optionTraceVerbose="0"
declare optionLogLevel="optionLogLevelDefaultValueFunction"
declare optionLogFile="optionLogFileDefaultValueFunction"
declare optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
declare optionNoColor="0"
declare optionTheme="default"
declare optionVersion="0"
declare optionQuiet="0"
declare optionSkin="default"
# arguments variables initialization
declare inputSqlFile=""
# @description parse command options and arguments for mysql2pumlCommand
mysql2pumlCommandParse() {
  Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
  Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  optionHelp="0"
  local -i options_parse_optionParsedCountOptionHelp
  ((options_parse_optionParsedCountOptionHelp = 0)) || true
  optionConfig="0"
  local -i options_parse_optionParsedCountOptionConfig
  ((options_parse_optionParsedCountOptionConfig = 0)) || true
  optionBashFrameworkConfig=""
  local -i options_parse_optionParsedCountOptionBashFrameworkConfig
  ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
  optionInfoVerbose="0"
  local -i options_parse_optionParsedCountOptionInfoVerbose
  ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
  optionDebugVerbose="0"
  local -i options_parse_optionParsedCountOptionDebugVerbose
  ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
  optionTraceVerbose="0"
  local -i options_parse_optionParsedCountOptionTraceVerbose
  ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
  optionLogLevel="optionLogLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogLevel
  ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
  optionLogFile="optionLogFileDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogFile
  ((options_parse_optionParsedCountOptionLogFile = 0)) || true
  optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionDisplayLevel
  ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
  optionNoColor="0"
  local -i options_parse_optionParsedCountOptionNoColor
  ((options_parse_optionParsedCountOptionNoColor = 0)) || true
  optionTheme="default"
  local -i options_parse_optionParsedCountOptionTheme
  ((options_parse_optionParsedCountOptionTheme = 0)) || true
  optionVersion="0"
  local -i options_parse_optionParsedCountOptionVersion
  ((options_parse_optionParsedCountOptionVersion = 0)) || true
  optionQuiet="0"
  local -i options_parse_optionParsedCountOptionQuiet
  ((options_parse_optionParsedCountOptionQuiet = 0)) || true
  optionSkin="default"
  local -i options_parse_optionParsedCountOptionSkin
  ((options_parse_optionParsedCountOptionSkin = 0)) || true

  inputSqlFile=""

  local -i options_parse_argParsedCountInputSqlFile
  ((options_parse_argParsedCountInputSqlFile = 0)) || true


  # shellcheck disable=SC2034
  local -i options_parse_parsedArgIndex=0
  while (($# > 0)); do
    local options_parse_arg="$1"
    local argOptDefaultBehavior=0
    case "${options_parse_arg}" in
      # Option 1/14
      # optionHelp alts --help|-h
      # type: Boolean min 0 max 1
      --help | -h)
        # shellcheck disable=SC2034
        optionHelp="1"

        if ((options_parse_optionParsedCountOptionHelp >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionHelp))
        optionHelpCallback "${options_parse_arg}" "${optionHelp}"

        ;;

      # Option 2/14
      # optionConfig alts --config
      # type: Boolean min 0 max 1
      --config)
        # shellcheck disable=SC2034
        optionConfig="1"

        if ((options_parse_optionParsedCountOptionConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfig))
        ;;

      # Option 3/14
      # optionBashFrameworkConfig alts --bash-framework-config
      # type: String min 0 max 1
      --bash-framework-config)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
        # shellcheck disable=SC2034
        optionBashFrameworkConfig="$1"
        optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"

        ;;

      # Option 4/14
      # optionInfoVerbose alts --verbose|-v
      # type: Boolean min 0 max 1
      --verbose | -v)
        # shellcheck disable=SC2034
        optionInfoVerbose="1"

        if ((options_parse_optionParsedCountOptionInfoVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionInfoVerbose))
        optionInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        updateArgListInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        ;;

      # Option 5/14
      # optionDebugVerbose alts -vv
      # type: Boolean min 0 max 1
      -vv)
        # shellcheck disable=SC2034
        optionDebugVerbose="1"

        if ((options_parse_optionParsedCountOptionDebugVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDebugVerbose))
        optionDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        updateArgListDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        ;;

      # Option 6/14
      # optionTraceVerbose alts -vvv
      # type: Boolean min 0 max 1
      -vvv)
        # shellcheck disable=SC2034
        optionTraceVerbose="1"

        if ((options_parse_optionParsedCountOptionTraceVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTraceVerbose))
        optionTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        updateArgListTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        ;;

      # Option 7/14
      # optionLogLevel alts --log-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --log-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogLevel))
        # shellcheck disable=SC2034
        optionLogLevel="$1"
        optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        ;;

      # Option 8/14
      # optionLogFile alts --log-file
      # type: String min 0 max 1
      --log-file)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogFile))
        # shellcheck disable=SC2034
        optionLogFile="$1"
        optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        ;;

      # Option 9/14
      # optionDisplayLevel alts --display-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --display-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionDisplayLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDisplayLevel))
        # shellcheck disable=SC2034
        optionDisplayLevel="$1"
        optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        ;;

      # Option 10/14
      # optionNoColor alts --no-color
      # type: Boolean min 0 max 1
      --no-color)
        # shellcheck disable=SC2034
        optionNoColor="1"

        if ((options_parse_optionParsedCountOptionNoColor >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionNoColor))
        optionNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        updateArgListNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        ;;

      # Option 11/14
      # optionTheme alts --theme
      # type: String min 0 max 1
      # authorizedValues: default|default-force|noColor
      --theme)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ default|default-force|noColor ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default, default-force, noColor)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionTheme >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTheme))
        # shellcheck disable=SC2034
        optionTheme="$1"
        optionThemeCallback "${options_parse_arg}" "${optionTheme}"

        updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"

        ;;

      # Option 12/14
      # optionVersion alts --version
      # type: Boolean min 0 max 1
      --version)
        # shellcheck disable=SC2034
        optionVersion="1"

        if ((options_parse_optionParsedCountOptionVersion >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionVersion))
        optionVersionCallback "${options_parse_arg}" "${optionVersion}"

        ;;

      # Option 13/14
      # optionQuiet alts --quiet|-q
      # type: Boolean min 0 max 1
      --quiet | -q)
        # shellcheck disable=SC2034
        optionQuiet="1"

        if ((options_parse_optionParsedCountOptionQuiet >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionQuiet))
        optionQuietCallback "${options_parse_arg}" "${optionQuiet}"

        updateArgListQuietCallback "${options_parse_arg}" "${optionQuiet}"

        ;;

      # Option 14/14
      # optionSkin alts --skin
      # type: String min 0 max 1
      --skin)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionSkin >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionSkin))
        # shellcheck disable=SC2034
        optionSkin="$1"
        optionSkinCallback "${options_parse_arg}" "${optionSkin}"

        ;;

      -*)
        if [[ "${argOptDefaultBehavior}" = "0" ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
          return 1
        fi
        ;;
      *)
        ((minParsedArgIndex0 = 0)) || true
        ((maxParsedArgIndex0 = 0)) || true
        ((minParsedArgIndex1 = minParsedArgIndex0 + 0)) || true
        ((maxParsedArgIndex1 = maxParsedArgIndex0 + 1)) || true
        ((incrementArg = 1 ))
        if ((0)); then
          # Technical if - never reached
          :

        # Argument 1/1 - inputSqlFile
        # Argument inputSqlFile min 0 max 1
        elif (( options_parse_parsedArgIndex >= minParsedArgIndex0 &&
          options_parse_parsedArgIndex < maxParsedArgIndex1 )); then
          if ((options_parse_argParsedCountInputSqlFile >= 1 )); then
            Log::displayError "Command ${SCRIPT_NAME} - Argument sqlFile - Maximum number of argument occurrences reached(1)"
            return 1
          fi
          ((++options_parse_argParsedCountInputSqlFile))
          # shellcheck disable=SC2034
          inputSqlFile="${options_parse_arg}"
          inputSqlFileCallback "${inputSqlFile}" -- "${@:2}"


        # else too much args
        else


          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            # too much args and no unknownArgumentCallbacks configured
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
            return 1
          fi

        fi
        if ((incrementArg == 1)); then
          ((++options_parse_parsedArgIndex))
        fi
        ;;
    esac
    shift || true
  done || return $?

  commandOptionParseFinished

}

# @description display command options and arguments help for mysql2pumlCommand
mysql2pumlCommandHelp() {
  echo -e "${__HELP_TITLE_COLOR}SYNOPSIS:${__RESET_COLOR}"
  Array::wrap2 ' ' 76 4 "    " "Converts mysql dump sql schema to plantuml format."
  echo
  echo

  # ------------------------------------------
  # usage section
  # ------------------------------------------
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "mysql2puml [OPTIONS] [ARGUMENTS]"
  echo
  # ------------------------------------------
  # usage/options section
  # ------------------------------------------
  optionsAltList=("[--help|-h]" "[--config]" "[--bash-framework-config <bash-framework-config>]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--log-level <log-level>]" "[--log-file <log-file>]" "[--display-level <display-level>]" "[--no-color]" "[--theme <theme>]" "[--version]" "[--quiet|-q]" "[--skin <skin>]"
  )
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
    "mysql2puml" "${optionsAltList[@]}"
  echo

  # ------------------------------------------
  # usage/arguments section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"

  Array::wrap2 " " 80 2 "  [${__HELP_OPTION_COLOR}sqlFile${__HELP_NORMAL} {single}]"
  Array::wrap2 ' ' 76 4 "    " "Sql filepath to parse (read from stdin if not provided)."
  echo


  # ------------------------------------------
  # options section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays this command help"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays configuration"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <bash-framework-config>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Use alternate bash framework configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Info level verbose mode (alias of --display-level INFO)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Debug level verbose mode (alias of --display-level DEBUG)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Trace level verbose mode (alias of --display-level TRACE)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--log-level <log-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionLogLevelDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--log-file <log-file>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log file"
  echo


  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionLogFileDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--display-level <display-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set display level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "$(optionDisplayLevelDefaultValueFunction)"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Produce monochrome output. alias of --theme noColor."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--theme <theme>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Choose color theme - default-force means colors will be produced even if command is piped."
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}default${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}default-force${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}noColor${__RESET_COLOR}"

  Array::wrap2 ' ' 76 6 "    Default value: " "default"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Print version information and quit."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Quiet mode, doesn't display any output."
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--skin <skin>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Header configuration of the plantuml file."
  echo


  Array::wrap2 ' ' 76 6 "    Default value: " "default"
  echo
  # ------------------------------------------
  # longDescription section
  # ------------------------------------------
  echo
  echo
  echo -e "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}"
  longDescriptionFunction
  # ------------------------------------------
  # version section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
  echo "3.0"
  # ------------------------------------------
  # author section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}AUTHOR: ${__RESET_COLOR}"
  echo "[FranÃ§ois Chastanet](https://github.com/fchastanet)"
  # ------------------------------------------
  # sourceFile section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}SOURCE FILE: ${__RESET_COLOR}"
  echo "https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/Converters/mysql2puml/mysql2puml-binary.yaml"
  # ------------------------------------------
  # license section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}LICENSE: ${__RESET_COLOR}"
  echo "MIT License"
  # ------------------------------------------
  # copyright section
  # ------------------------------------------
  Array::wrap2 ' ' 76 0 "$(copyrightCallback)"
}


beforeParseCallback

mysql2pumlCommandParse "$@"
MAIN_FUNCTION_NAME="main"
main() {

Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/8ab6652e563ee45005c17d4a7f70a813cabae8c73bae3a83f86f63e46464f90c/mysql2pumlScript" \
  "IyEvYmluL2F3ayAtZgojID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KIwojIG15c3FsMnB1bWwgLSBTUUwgRERMIHRvIG1hcmtkb3duIGNvbnZlcnRlcgojCiMgSW52b2NhdGlvbi9FeGVjdXRpb246CiMgICBhd2sgLWYgbXlzcWwycHVtbC5hd2sgc2tpbkZpbGUgPCBpbnB1dEZpbGUgPiBvdXRwdXRGaWxlCiMgICBERUJVRz0xIGF3ayAtZiBteXNxbDJwdW1sLmF3ayBza2luRmlsZSA8IGlucHV0RmlsZSA+IG91dHB1dEZpbGUKIwojIFN1cHBvcnRzCiMgICBQbGFudFVNTCBmb3JtYXQKIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpmdW5jdGlvbiBkZWJ1ZyhmaXJzdCwgc2Vjb25kLCB0aGlyZCwgZm91cnRoLCBmaWZ0aCwgc2l4dGgsIHNldmVudGgsIGVpZ2h0aCwgbmludGgsIHRlbnRoLCBlbGV2ZW50aCwgdHdlbGZ0aCkgewogICAgaWYgKERFQlVHID09IDEpIHByaW50KCJERUJVRyAtICIsIGZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGgsIGZpZnRoLCBzaXh0aCwgc2V2ZW50aCwgZWlnaHRoLCBuaW50aCwgdGVudGgsIGVsZXZlbnRoLCB0d2VsZnRoKSA+ICIvZGV2L3N0ZGVyciIKfQoKIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpmdW5jdGlvbiB1bWxfc3RhcnQoKQp7CiAgICBpZiAoIXNraW5GaWxlKSB7CiAgICAgICAgcHJpbnQoInNraW5GaWxlIHBhcmFtZXRlciBtaXNzaW5nIikgPiAiL2Rldi9zdGRlcnIiCiAgICAgICAgZXhpdCAxCiAgICB9CiAgICB3aGlsZSAoKGdldGxpbmUgdG1wIDwgc2tpbkZpbGUpID4gMCkgewogICAgICAgIGlmIChtYXRjaCh0bXAsIC9AZW5kdW1sLykpIHsKICAgICAgICAgICAgYnJlYWsKICAgICAgICB9CiAgICAgICAgcHJpbnQodG1wKQogICAgfQogICAgcHJpbnQgIicgZW50aXRpZXMiCn0KCiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKZnVuY3Rpb24gdW1sX2VuZCgpCnsKICAgIHByaW50ICJAZW5kdW1sIgp9CgojID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCmZ1bmN0aW9uIGx0cmltKHMpIHsgc3ViKC9eWyBcdFxyXG5dKy8sICIiLCBzKTsgcmV0dXJuIHMgfQpmdW5jdGlvbiBydHJpbShzKSB7IHN1YigvWyBcdFxyXG5dKyQvLCAiIiwgcyk7IHJldHVybiBzIH0KZnVuY3Rpb24gdHJpbShzKSB7IHJldHVybiBydHJpbShsdHJpbShzKSk7IH0KCiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKZnVuY3Rpb24gY29sdW1uX3dlaWdodChjb2x1bW4pCnsKICAgIHJldHVybiAoY29sdW1uc0RldGFpbHNbY29sdW1uICIscGsiXSA9PSAiMSIgPyA4IDogMCkgXAogICAgICAgICsgKGNvbHVtbnNEZXRhaWxzW2NvbHVtbiAiLGZrIl0gPT0gIjEiID8gNCA6IDApIFwKICAgICAgICArIChjb2x1bW5zRGV0YWlsc1tjb2x1bW4gIix1bmlxdWUiXSA9PSAiMSIgPyAyIDogMCkgXAogICAgICAgICsgKGNvbHVtbnNEZXRhaWxzW2NvbHVtbiAiLG51bGwiXSA9PSAiMCIgPyAxIDogMCkKfQoKZnVuY3Rpb24gY29sdW1uX3NvcnQoaTEsIGNvbHVtbjEsIGkyLCBjb2x1bW4yKQp7CiAgICB3ZWlnaHQxID0gY29sdW1uX3dlaWdodChjb2x1bW4xKQogICAgd2VpZ2h0MiA9IGNvbHVtbl93ZWlnaHQoY29sdW1uMikKICAgIGlmICh3ZWlnaHQxID09IHdlaWdodDIpIHsKICAgICAgICBsID0gdG9sb3dlcihjb2x1bW4xKQogICAgICAgIHIgPSB0b2xvd2VyKGNvbHVtbjIpCgogICAgICAgIGlmIChsIDwgcikgewogICAgICAgICAgICByZXR1cm4gLTEKICAgICAgICB9IGVsc2UgaWYgKGwgPT0gcikgewogICAgICAgICAgICByZXR1cm4gMAogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiAxCiAgICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gd2VpZ2h0MiAtIHdlaWdodDEKICAgIH0KfQoKIyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpmdW5jdGlvbiB1bWxfdGFibGUoY3JlYXRlVGFibGUpCiMgRERMIHRvIHBsYW50dW1sCiMgQ1JFQVRFIFRBQkxFIGBjb3JlX2N1c3RvbWVyYCAoYGlkYCBpbnQoMTEpIE5PVCBOVUxMIEFVVE9fSU5DUkVNRU5ULCBgaW5zdGFuY2VfbmFtZWAgdmFyY2hhcigxMjgpIE5PVCBOVUxMLCBQUklNQVJZIEtFWSAoYGlkYCksIFVOSVFVRSBLRVkgYGluc3RhbmNlX25hbWVgIChgaW5zdGFuY2VfbmFtZWApICkgRU5HSU5FPUlubm9EQiBBVVRPX0lOQ1JFTUVOVD01IERFRkFVTFQgQ0hBUlNFVD11dGY4OwojIENSRUFURSBUQUJMRSBgY29yZV9sZWFybmVyX3NraWxsYCAoYGlkYCBpbnQoMTEpIE5PVCBOVUxMIEFVVE9fSU5DUkVNRU5ULCBgY3VzdG9tZXJfaWRgIGludCgxMCkgdW5zaWduZWQgTk9UIE5VTEwsIFBSSU1BUlkgS0VZIChgaWRgKSwgS0VZIGBjdXN0b21lcl9pZF82ODRmOTA0Zl9ma19jb3JlX2xlYXJuZXJfaWRgIChgY3VzdG9tZXJfaWRgKSwgQ09OU1RSQUlOVCBgY3VzdG9tZXJfaWRfNjg0ZjkwNGZfZmtfY29yZV9jdXN0b21lcl9pZGAgRk9SRUlHTiBLRVkgKGBjdXN0b21lcl9pZGApIFJFRkVSRU5DRVMgYGNvcmVfY3VzdG9tZXJgIChgaWRgKSkgRU5HSU5FPUlubm9EQiBBVVRPX0lOQ1JFTUVOVD00MTUgREVGQVVMVCBDSEFSU0VUPXV0Zjg7CiN0YWJsZSggdXNlciApIHsKIyAgcHJpbWFyeV9rZXkoIGlkICk6IFVVSUQKIyAgY29sdW1uKCBpc0FjdGl2ZSApOiBCT09MRUFOCiN9CiNMZWFybmVyU2tpbGwgIjAuLioiIC0tPiAiMSIgTGVhcm5lciA6ICJsZWFybmVyX2lkIgp7CiAgICBkZWJ1ZygidW1sX3RhYmxlIiwgY3JlYXRlVGFibGUpCiAgICBzcGxpdChjcmVhdGVUYWJsZSxsaW5lcywiXG4iKQogICAgY29sdW1uSWR4PTAKICAgIGZvciAobGluZSBpbiBsaW5lcykgewogICAgICAgIGRlYnVnKGxpbmVzW2xpbmVdKQogICAgICAgIGlmIChtYXRjaChsaW5lc1tsaW5lXSwgL0NSRUFURSBUQUJMRSBgKFteYF0rKWAgXCgvLCBhcnIpKSB7CiAgICAgICAgICAgIGRlYnVnKCJUQUJMRSAiLCBsaW5lc1tsaW5lXSkKICAgICAgICAgICAgdGFibGVOYW1lID0gYXJyWzFdCiAgICAgICAgfSBlbHNlIGlmIChtYXRjaChsaW5lc1tsaW5lXSwgL1BSSU1BUlkgS0VZIFwoKFteKV0rKVwpLywgYXJyKSkgewogICAgICAgICAgICAjIFBSSU1BUlkgS0VZIChgaWRgKSwKICAgICAgICAgICAgZGVidWcoIlBLICIsIGxpbmVzW2xpbmVdKQogICAgICAgICAgICBzcGxpdChhcnJbMV0scHJpbWFyeUtleXMsIiwiKQogICAgICAgICAgICBmb3IgKGkgaW4gcHJpbWFyeUtleXMpIHsKICAgICAgICAgICAgICAgIGlmKG1hdGNoKHByaW1hcnlLZXlzW2ldLCAvWyBdP2AoW15gXSspK2BbIF0/LywgYXJyKSkgewogICAgICAgICAgICAgICAgICAgIGNvbHVtbnNEZXRhaWxzW2FyclsxXSAiLHBrIl0gPSAiMSIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAobWF0Y2gobGluZXNbbGluZV0sIC9DT05TVFJBSU5UIGBbXmBdK2AgRk9SRUlHTiBLRVkgXChgKFteYF0rKWBcKSBSRUZFUkVOQ0VTIGAoW15gXSspYCBcKGAoW15gXSspYFwpLywgYXJyKSkgewogICAgICAgICAgICAjIENPTlNUUkFJTlQgYGNvcmVfbGVhcm5lcl9jdXN0b21lcl9pZF82ZDM1NmRhOF9ma19jb3JlX2N1c3RvbWVyX2lkYCBGT1JFSUdOIEtFWSAoYGN1c3RvbWVyX2lkYCkgUkVGRVJFTkNFUyBgY29yZV9jdXN0b21lcmAgKGBpZGApCiAgICAgICAgICAgIGRlYnVnKCJDb25zdHJhaW50ICIsIGxpbmVzW2xpbmVdKQogICAgICAgICAgICBjb2x1bW5OYW1lPWFyclsxXQogICAgICAgICAgICBjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIsZmsiXT0iMSIKICAgICAgICAgICAgY29sdW1uc0RldGFpbHNbY29sdW1uTmFtZSAiLGZrVGFibGUiXT1hcnJbMl0KICAgICAgICAgICAgY29sdW1uc0RldGFpbHNbY29sdW1uTmFtZSAiLGZrQ29sdW1uIl09YXJyWzNdCiAgICAgICAgfSBlbHNlIGlmIChtYXRjaChsaW5lc1tsaW5lXSwgL1VOSVFVRSBLRVkgYFteYF0rYCBcKChbXildKylcKS8sIGFycikpIHsKICAgICAgICAgICAgIyBVTklRVUUgS0VZIGB1bmlxdWVfbGVhcm5lcl9ieV9jdXN0b21lcmAgKGBleHRlcm5hbF9pZGAsYGN1c3RvbWVyX2lkYCksCiAgICAgICAgICAgIGRlYnVnKCJVbmlxdWUgS2V5ICIsIGxpbmVzW2xpbmVdKQogICAgICAgICAgICBzcGxpdChhcnJbMV0sdW5pcXVlS2V5cywiLCIpCiAgICAgICAgICAgIGZvciAoaSBpbiB1bmlxdWVLZXlzKSB7CiAgICAgICAgICAgICAgICBpZihtYXRjaCh1bmlxdWVLZXlzW2ldLCAvWyBdP2AoW15gXSspK2BbIF0/LywgYXJyKSkgewogICAgICAgICAgICAgICAgICAgIGNvbHVtbnNEZXRhaWxzW2FyclsxXSAiLHVuaXF1ZSJdID0gIjEiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKGxpbmVzW2xpbmVdLCAvYChbXmBdKylgICgoW0EtWmEtel0rKSgoXChbXildK1wpfClbIF0/KHVuc2lnbmVkfCkpKVsgXT8oTk9UIE5VTEx8TlVMTHwpWyBdPyhBVVRPX0lOQ1JFTUVOVHwpLywgYXJyKSkgewogICAgICAgICAgICAjIGBpZGAgaW50KDExKSBOT1QgTlVMTCBBVVRPX0lOQ1JFTUVOVAogICAgICAgICAgICAjIGB0ZXN0YCBpbnQoMTEpIHVuc2lnbmVkIE5VTEwKICAgICAgICAgICAgIyBgaW5zdGFuY2VfbmFtZWAgdmFyY2hhcigxMjgpIE5PVCBOVUxMCiAgICAgICAgICAgIGRlYnVnKCJDb2x1bW4gIiwgbGluZXNbbGluZV0pCiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBhcnJbMV0KICAgICAgICAgICAgY29sdW1uc1tjb2x1bW5JZHgrK10gPSBjb2x1bW5OYW1lCiAgICAgICAgICAgIGNvbHVtblR5cGU9YXJyWzJdCiAgICAgICAgICAgIGdzdWIoL1wofFwpLywgIiIsIGNvbHVtblR5cGUpCiAgICAgICAgICAgIGNvbHVtbnNEZXRhaWxzW2NvbHVtbk5hbWUgIix0eXBlIl0gPSBjb2x1bW5UeXBlICAjIGVnOiBpbnQoMTEpIHVuc2lnbmVkID0+IGludDExIHVuc2lnbmVkCiAgICAgICAgICAgIGNvbHVtbnNEZXRhaWxzW2NvbHVtbk5hbWUgIixudWxsIl0gPSBhcnJbN109PSJOT1QgTlVMTCIgPyAiMCIgOiAiMSIgIyBlZzogTk9UIE5VTEwKICAgICAgICAgICAgY29sdW1uc0RldGFpbHNbY29sdW1uTmFtZSAiLGF1dG9JbmNyZW1lbnQiXSA9IGFycls4XSAjIGVnOiBBVVRPX0lOQ1JFTUVOVAogICAgICAgIH0KICAgIH0KCiAgICBpZiAoREVCVUcgPT0gMSkgewogICAgICAgIGRlYnVnKCJUYWJsZSAiLCB0YWJsZU5hbWUpCiAgICAgICAgZm9yIChpIGluIGNvbHVtbnMpIGRlYnVnKCJjb2x1bW4gIiwgaSwgIiAiLCBjb2x1bW5zW2ldKQogICAgICAgIGZvciAoaSBpbiBjb2x1bW5zRGV0YWlscykgZGVidWcoIm1hdGNoICIsIGksICIgIiwgY29sdW1uc0RldGFpbHNbaV0pCiAgICB9CiAgICBhc29ydChjb2x1bW5zLCBjb2x1bW5zLCAiY29sdW1uX3NvcnQiKQogICAgaWYgKERFQlVHID09IDEpIHsKICAgICAgICBkZWJ1ZygiKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIikKICAgICAgICBkZWJ1ZygiQ29sdW1ucyBvcmRlciBhZnRlciBzb3J0IikKICAgICAgICBmb3IgKGkgaW4gY29sdW1ucykgZGVidWcoImNvbHVtbiAiLCBpLCAiICIsIGNvbHVtbnNbaV0sIGNvbHVtbl93ZWlnaHQoY29sdW1uc1tpXSkpCiAgICB9CiAgICBwcmludGYoIlRhYmxlKCVzKSB7XG4iLCB0YWJsZU5hbWUgKQogICAgZm9yKGkgaW4gY29sdW1ucykgewogICAgICAgIGNvbHVtbk5hbWU9Y29sdW1uc1tpXQogICAgICAgICMgY29sdW1uKCRuYW1lLCAkdHlwZSwgJG51bGw9IiIsICRwaz0iIiwgJGZrPSIiLCAkdW5pcXVlPSIiKQogICAgICAgIHByaW50ZiggXAogICAgICAgICAgICAiICBjb2x1bW4oXCIlc1wiLCBcIiVzXCIsIFwiJXNcIiwgXCIlc1wiLCBcIiVzXCIsIFwiJXNcIilcbiIsIFwKICAgICAgICAgICAgY29sdW1uTmFtZSwgXAogICAgICAgICAgICB0cmltKGNvbHVtbnNEZXRhaWxzW2NvbHVtbk5hbWUgIix0eXBlIl0pLCBcCiAgICAgICAgICAgIChjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIsbnVsbCJdID09ICIxIikgPyAiTlVMTCIgOiAiTk9UIE5VTEwiLCBcCiAgICAgICAgICAgIChjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIscGsiXSA9PSAiMSIpID8gIlBLIiA6ICIiLCBcCiAgICAgICAgICAgIChjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIsZmtUYWJsZSJdID09ICIxIikgPyAiRksiIDogIiIsIFwKICAgICAgICAgICAgKGNvbHVtbnNEZXRhaWxzW2NvbHVtbk5hbWUgIix1bmlxdWUiXSA9PSAiMSIpID8gIlVOSVFVRSIgOiAiIiBcCiAgICAgICAgKQogICAgfQogICAgcHJpbnQoIn0iKQoKICAgIGZvcihpIGluIGNvbHVtbnMpIHsKICAgICAgICBjb2x1bW5OYW1lPWNvbHVtbnNbaV0KICAgICAgICBpZiAoY29sdW1uc0RldGFpbHNbY29sdW1uTmFtZSAiLGZrIl0gPT0gIjEiKSB7CiAgICAgICAgICAgICNMZWFybmVyU2tpbGwgIjAuLioiIC0tPiAiMSIgTGVhcm5lciA6ICJsZWFybmVyX2lkIgogICAgICAgICAgICBwcmludGYoIiVzIFwiMC4uKlwiIC0tPiBcIjFcIiAlcyA6IFwiJXNcIlxuIiwgdGFibGVOYW1lLCBjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIsZmtUYWJsZSJdLCBjb2x1bW5zRGV0YWlsc1tjb2x1bW5OYW1lICIsZmtDb2x1bW4iXSApCiAgICAgICAgfQogICAgfQogICAgcHJpbnQoIiIpCgogICAgZGVsZXRlIGNvbHVtbnNEZXRhaWxzCiAgICBkZWxldGUgY29sdW1ucwp9CgojID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KZnVuY3Rpb24gdW1sX3BhcnNlX2xpbmUoY3VycmVudExpbmUpCnsKICAgIGlmIChsZW5ndGgoY3VycmVudExpbmUpIDwgMiB8fCBtYXRjaChjdXJyZW50TGluZSwgIl4tLSIpID4gMCkgewogICAgICAgIHJldHVybgogICAgfQoKICAgIGlmIChtYXRjaChjdXJyZW50TGluZSwiOyIpPjApIHsKICAgICAgICBzcWxMaW5lID0gc3FsTGluZSAiXG4iIGN1cnJlbnRMaW5lCiAgICAgICAgZGVidWcoc3FsTGluZSkKICAgICAgICBpZiAobWF0Y2goc3FsTGluZSwiQ1JFQVRFIFRBQkxFIikgPiAwKSB7CiAgICAgICAgICAgIHVtbF90YWJsZShzcWxMaW5lKQogICAgICAgIH0KICAgICAgICBzcWxMaW5lPSIiCiAgICB9CiAgICBlbHNlIHsKICAgICAgICBzcWxMaW5lID0gc3FsTGluZSAiXG4iIGN1cnJlbnRMaW5lCiAgICB9Cn0KCiMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKQkVHSU4gewogICAgREVCVUc9RU5WSVJPTlsiREVCVUciXQogICAgc2tpbkZpbGU9QVJHVlsxXQogICAgZGVidWcoIlNraW4gZmlsZSIsIHNraW5GaWxlKQogICAgdW1sX3N0YXJ0KCkKfQoKewogICAgbGluZT0kMAogICAgdW1sX3BhcnNlX2xpbmUobGluZSkKfQoKRU5EIHsKICAgIHVtbF9lbmQoKQogICAgZXhpdCAwCiAgICAjIGZha2UgY2FsbCBvY2N1cnJpbmcgYWZ0ZXIgZXhpdCB0byByZW1vdmUgd2FybmluZyBhYm91dCB1bnVzZWQgZnVuY3Rpb24KICAgIGNvbHVtbl9zb3J0KCkKfQojID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0K" \
  "755"

declare -gx embed_file_mysql2pumlScript="${PERSISTENT_TMPDIR:-/tmp}/8ab6652e563ee45005c17d4a7f70a813cabae8c73bae3a83f86f63e46464f90c/mysql2pumlScript"


Linux::requireRealpathCommand

# shellcheck disable=SC2154
absSkinFile="$(Conf::getAbsoluteFile "mysql2pumlSkins" "${optionSkin}" "puml")" ||
  Log::fatal "the skin ${optionSkin} does not exist"

if [[ -n "${inputSqlFile}" ]]; then
  exec 3<"${inputSqlFile}"
elif [[ ! -t 0 ]]; then
  exec 3<&0
fi

# shellcheck disable=SC2154
awk -f "${embed_file_mysql2pumlScript}" "${absSkinFile}" - <&3 | Filters::trimEmptyLines

}

# if file is sourced avoid calling main function
# shellcheck disable=SC2178
BASH_SOURCE=".$0" # cannot be changed in bash
# shellcheck disable=SC2128
if test ".$0" == ".${BASH_SOURCE}"; then
  if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
    main "$@" &>/dev/null
  else
    main "$@"
  fi
fi
