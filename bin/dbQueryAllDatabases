#!/usr/bin/env bash
###############################################################################
# GENERATED FROM https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/Database/dbQueryAllDatabases/dbQueryAllDatabases-binary.yaml
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034



# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM


SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3


# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}


# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}


# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  tty -s
}


# @description ignore exit code 141 from simple command pipes
# @example use with:
#   local resultingStatus=0
#   local -a originalPipeStatus=()
#   cmd1 | cmd2 || Bash::handlePipelineFailure resultingStatus originalPipeStatus || true
#   [[ "${resultingStatus}" = "0" ]]
# @arg $1 resultingStatusCode:&int (passed by reference) (optional) resulting status code
# @arg $2 originalStatus:int[] (passed by reference) (optional) copy of original PIPESTATUS array
# @env PIPESTATUS assuming that this function is called like in the example provided
# @see https://unix.stackexchange.com/a/709880/582856
Bash::handlePipelineFailure() {
  local -a pipeStatusBackup=("${PIPESTATUS[@]}")
  local -n handlePipelineFailure_resultingStatusCode=$1
  local -n handlePipelineFailure_originalStatus=$2
  # shellcheck disable=SC2034
  handlePipelineFailure_originalStatus=("${pipeStatusBackup[@]}")
  handlePipelineFailure_resultingStatusCode=0
  local statusCode
  for statusCode in "${pipeStatusBackup[@]}"; do
    if ((statusCode == 141)); then
      return 0
    elif ((statusCode > 0)); then
      # shellcheck disable=SC2034
      handlePipelineFailure_resultingStatusCode="${statusCode}"
      break
    fi
  done
  return "${handlePipelineFailure_resultingStatusCode}"
}


read -r -d '\0' bashToolsDefaultConfigTemplate <<-EOM || true
##!/usr/bin/env bash
# shellcheck disable=SC2034

# Default settings
# you can override these settings by creating ${HOME}/.bash-tools/.env file

###
### DISPLAY Level
### minimum level of the messages that will be displayed on screen
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}

###
### DISPLAY duration
### 0: no duration is displayed on the messages
### 1: duration between previous message and current is displayed
### with the message
###
DISPLAY_DURATION=${DISPLAY_DURATION:0}

###
### Log to file
###
### all log messages will be redirected to log file specified
### this same path will be used inside and outside of the container
###
BASH_FRAMEWORK_LOG_FILE=${BASH_FRAMEWORK_LOG_FILE:-${BASH_TOOLS_ROOT_DIR}/logs/bash.log}

###
### LOG Level
### minimum level of the messages that will be logged into LOG_FILE
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}

# absolute directory containing db import sql dumps
DB_IMPORT_DUMP_DIR=${DB_IMPORT_DUMP_DIR:-${HOME}/.bash-tools/dbImportDumps}

# garbage collect all files for which modification is greater than eg: 30 days (+30)
# each time an existing file is used by dbImport/dbImportTable
# the file modification time is set to now
DB_IMPORT_GARBAGE_COLLECT_DAYS=${DB_IMPORT_GARBAGE_COLLECT_DAYS:-+30}

# absolute directory containing dbScripts used by dbScriptAllDatabases
SCRIPTS_FOLDER=${SCRIPTS_FOLDER:-${HOME}/.bash-tools/conf/dbScripts}

# -----------------------------------------------------
# AWS Parameters
# -----------------------------------------------------
S3_BASE_URL=${S3_BASE_URL:-}

# -----------------------------------------------------
# Postman Parameters
# -----------------------------------------------------
POSTMAN_API_KEY=
EOM

# @description loads ~/.bash-tools/.env if available
# if not creates it from a default template
# else check if new options need to be added
BashTools::Conf::requireLoad() {
  BASH_TOOLS_ROOT_DIR="$(cd "${CURRENT_DIR}/${RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR}" && pwd -P)"
  if [[ -d "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework/" ]]; then
    FRAMEWORK_ROOT_DIR="$(cd "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
  else
    # if the directory does not exist yet, give a value to FRAMEWORK_ROOT_DIR
    FRAMEWORK_ROOT_DIR="${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework"
  fi
  # shellcheck disable=SC2034
  FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
  # shellcheck disable=SC2034
  FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

  if [[ -f "${HOME}/.bash-tools/.env" ]]; then
    # shellcheck disable=SC2034
    BASH_FRAMEWORK_ENV_FILES=("${HOME}/.bash-tools/.env")
  fi

  local envFile="${HOME}/.bash-tools/.env"
  if [[ ! -f "${envFile}" ]]; then
    mkdir -p "${HOME}/.bash-tools"
    (
      echo "#!/usr/bin/env bash"
      # shellcheck disable=SC2154
      echo "${bashToolsDefaultConfigTemplate}"
    ) >"${envFile}"
    Log::displayInfo "Configuration file '${envFile}' created"
  else
    if ! grep -q '^POSTMAN_API_KEY=' "${envFile}"; then
      (
        echo '# -----------------------------------------------------'
        echo '# Postman Parameters'
        echo '# -----------------------------------------------------'
        echo 'POSTMAN_API_KEY='
      ) >>"${envFile}"
    fi
  fi
  # shellcheck source=/conf/defaultEnv/.env
  source "${envFile}" || {
    Log::displayError "impossible to load '${envFile}'"
    exit 1
  }
}


# @description convert base64 encoded back to target file
# if target file is executable prepend dir of target
# file to PATH to make binary available everywhere
# it is advised to include in the path of the target file
# the md5sum of the binFile
#
# @arg $1 targetFile:String the file to write
# @arg $2 binFileBase64:String the base64 encoded file
# @arg $3 fileMode:String the chmod to set on the file
# @set PATH String prepend target embedded file binary directory to PATH variable if binary executable
Compiler::Embed::extractFileFromBase64() {
  local targetFile="$1"
  local binFileBase64="$2"
  local fileMode="${3:-+x}"
  local targetDir="${targetFile%/*}"

  if [[ ! -f "${targetFile}" ]]; then
    if [[ ! -d "${targetDir}" ]]; then
      mkdir -p "${targetDir}"
    fi
    base64 -d >"${targetFile}" <<<"${binFileBase64}"
    chmod "${fileMode}" "${targetFile}"
  fi

  if [[ -x "${targetFile}" ]]; then
    Env::pathPrepend "${targetDir}"
  fi
}


# @description get absolute conf file from specified conf folder deduced using these rules
#   * from absolute file (ignores <confFolder> and <extension>)
#   * relative to where script is executed (ignores <confFolder> and <extension>)
#   * from home/.bash-tools/<confFolder>
#   * from framework conf/<confFolder>
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 conf:String file to use without extension
# @arg $3 extension:String the extension (.sh by default)
#
# @stdout absolute conf filename
# @exitcode 1 if file is not found in any location
Conf::getAbsoluteFile() {
  local confFolder="$1"
  local conf="$2"
  local extension="${3-.sh}"
  if [[ -n "${extension}" && "${extension:0:1}" != "." ]]; then
    extension=".${extension}"
  fi

  testAbs() {
    local result
    result="$(realpath -e "$1" 2>/dev/null)"
    # shellcheck disable=SC2181
    if [[ "$?" = "0" && -f "${result}" ]]; then
      echo "${result}"
      return 0
    fi
    return 1
  }

  # conf is absolute file (including extension)
  testAbs "${confFolder}${extension}" && return 0
  # conf is absolute file
  testAbs "${confFolder}" && return 0
  # conf is absolute file (including extension)
  testAbs "${conf}${extension}" && return 0
  # conf is absolute file
  testAbs "${conf}" && return 0

  # relative to where script is executed (including extension)
  if [[ -n "${CURRENT_DIR+xxx}" ]]; then
    testAbs "$(File::concatenatePath "${CURRENT_DIR}" "${confFolder}")/${conf}${extension}" && return 0
  fi
  # from home/.bash-tools/<confFolder>
  testAbs "$(File::concatenatePath "${HOME}/.bash-tools" "${confFolder}")/${conf}${extension}" && return 0

  if [[ -n "${FRAMEWORK_ROOT_DIR+xxx}" ]]; then
    # from framework conf/<confFolder> (including extension)
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}${extension}" && return 0

    # from framework conf/<confFolder>
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}" && return 0
  fi

  # file not found
  Log::displayError "conf file '${conf}' not found"

  return 1
}


# @description list the conf files list available in bash-tools/conf/<conf> folder
# and those overridden in ${HOME}/.bash-tools/<conf> folder
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 extension:String the extension (.sh by default)
# @arg $3 indentStr:String the indentation ('       - ' by default) can be any string compatible with sed not containing any /
#
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
Conf::getMergedList() {
  local confFolder="$1"
  local extension="${2-sh}"
  local indentStr="${3-       - }"

  local DEFAULT_CONF_DIR="${FRAMEWORK_ROOT_DIR}/conf/${confFolder}"
  local HOME_CONF_DIR="${HOME}/.bash-tools/${confFolder}"

  (
    if [[ -d "${DEFAULT_CONF_DIR}" ]]; then
      Conf::list "${DEFAULT_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
    if [[ -d "${HOME_CONF_DIR}" ]]; then
      Conf::list "${HOME_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
  ) | sort | uniq
}


# @description list files of dir with given extension and display it as a list one by line
#
# @arg $1 dir:String the directory to list
# @arg $2 prefix:String the profile file prefix (default: "")
# @arg $3 ext:String the extension
# @arg $4 findOptions:String find options, eg: -type d (Default value: '-type f')
# @arg $5 indentStr:String the indentation can be any string compatible with sed not containing any / (Default value: '       - ')
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
# @exitcode 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}


# @description Load the nearest config file
# in next example will search first .framework-config file in "srcDir1"
# then if not found will go in up directories until /
# then will search in "srcDir2"
# then if not found will go in up directories until /
# source the file if found
# @example
#   Conf::loadNearestFile ".framework-config" "srcDir1" "srcDir2"
#
# @arg $1 configFileName:String config file name to search
# @arg $2 loadedFile:String (passed by reference) will return the loaded config file name
# @arg $@ srcDirs:String[] source directories in which the config file will be searched
# @exitcode 0 if file found
# @exitcode 1 if file not found
Conf::loadNearestFile() {
  local configFileName="$1"
  local -n loadedFile="$2"
  shift 2 || true
  local -a srcDirs=("$@")
  for srcDir in "${srcDirs[@]}"; do
    configFile="$(File::upFind "${srcDir}" "${configFileName}" || true)"
    if [[ -n "${configFile}" ]]; then
      # shellcheck source=/.framework-config
      source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
      Log::displayDebug "Config file ${configFile} is loaded"
      # shellcheck disable=SC2034
      loadedFile="${configFile}"
      return 0
    fi
  done

  Log::displayWarning "Config file '${configFileName}' not found in any source directories provided"
  return 1
}


# @description check if dsn file has all the mandatory variables set
# Mandatory variables are: HOSTNAME, USER, PASSWORD, PORT
#
# @arg $1 dsnFileName:String dsn absolute filename
# @set HOSTNAME loaded from dsn file
# @set PORT loaded from dsn file
# @set USER loaded from dsn file
# @set PASSWORD loaded from dsn file
# @exitcode 0 on valid file
# @exitcode 1 if one of the properties of the conf file is invalid or if file not found
# @stderr log output if error found in conf file
Database::checkDsnFile() {
  local dsnFileName="$1"
  if [[ ! -f "${dsnFileName}" ]]; then
    Log::displayError "dsn file ${dsnFileName} not found"
    return 1
  fi

  (
    unset HOSTNAME PORT PASSWORD USER
    # shellcheck source=/src/Database/testsData/dsn_valid.env
    source "${dsnFileName}"
    if [[ -z ${HOSTNAME+x} ]]; then
      Log::displayError "dsn file ${dsnFileName} : HOSTNAME not provided"
      return 1
    fi
    if [[ -z "${HOSTNAME}" ]]; then
      Log::displayWarning "dsn file ${dsnFileName} : HOSTNAME value not provided"
    fi
    if [[ "${HOSTNAME}" = "localhost" ]]; then
      Log::displayWarning "dsn file ${dsnFileName} : check that HOSTNAME should not be 127.0.0.1 instead of localhost"
    fi
    if [[ -z "${PORT+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : PORT not provided"
      return 1
    fi
    if ! [[ ${PORT} =~ ^[0-9]+$ ]]; then
      Log::displayError "dsn file ${dsnFileName} : PORT invalid"
      return 1
    fi
    if [[ -z "${USER+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : USER not provided"
      return 1
    fi
    if [[ -z "${PASSWORD+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : PASSWORD not provided"
      return 1
    fi
  )
}


# @description databases's list of given mysql server
#
# @example text
# - information_schema
# - mysql
# - performance_schema
# - sys
#
# @arg $1 instanceUserDbList:&Map<String,String> (passed by reference) database instance to use
# @stdout the list of db except mysql admin ones (see example)
# @exitcode * the query exit code
Database::getUserDbList() {
  # shellcheck disable=SC2034
  local -n instanceUserDbList=$1
  # shellcheck disable=SC2016
  local sql='SELECT `schema_name` from INFORMATION_SCHEMA.SCHEMATA WHERE `schema_name` NOT IN("information_schema", "mysql", "performance_schema", "sys")'
  Database::query instanceUserDbList "${sql}"
}


# @description create a new db instance
# Returns immediately if the instance is already initialized
#
# @arg $1 instanceNewInstance:&Map<String,String> (passed by reference) database instance to use
# @arg $2 dsn:String dsn profile - load the dsn.env profile deduced using rules defined in Conf::getAbsoluteFile
#
# @example
#   declare -Agx dbInstance
#   Database::newInstance dbInstance "default.local"
#
# @exitcode 1 if dns file not able to loaded
Database::newInstance() {
  local -n instanceNewInstance=$1
  local dsn="$2"
  local DSN_FILE

  if [[ -v instanceNewInstance['INITIALIZED'] && "${instanceNewInstance['INITIALIZED']:-0}" == "1" ]]; then
    return
  fi

  # final auth file generated from dns file
  instanceNewInstance['AUTH_FILE']=""
  instanceNewInstance['DSN_FILE']=""

  # check dsn file
  DSN_FILE="$(Conf::getAbsoluteFile "dsn" "${dsn}" "env")" || return 1
  Database::checkDsnFile "${DSN_FILE}" || return 1
  instanceNewInstance['DSN_FILE']="${DSN_FILE}"

  # shellcheck source=/src/Database/testsData/dsn_valid.env
  source "${instanceNewInstance['DSN_FILE']}"

  instanceNewInstance['USER']="${USER}"
  instanceNewInstance['PASSWORD']="${PASSWORD}"
  instanceNewInstance['HOSTNAME']="${HOSTNAME}"
  instanceNewInstance['PORT']="${PORT}"

  # generate authFile for easy authentication
  instanceNewInstance['AUTH_FILE']=$(mktemp -p "${TMPDIR:-/tmp}" -t "mysql.XXXXXXXXXXXX")
  (
    echo "[client]"
    echo "user = ${USER}"
    echo "password = ${PASSWORD}"
    echo "host = ${HOSTNAME}"
    echo "port = ${PORT}"
  ) >"${instanceNewInstance['AUTH_FILE']}"

  # some of those values can be overridden using the dsn file
  # SKIP_COLUMN_NAMES enabled by default
  instanceNewInstance['SKIP_COLUMN_NAMES']="${SKIP_COLUMN_NAMES:-1}"
  instanceNewInstance['SSL_OPTIONS']="${MYSQL_SSL_OPTIONS:---ssl-mode=DISABLED}"
  instanceNewInstance['QUERY_OPTIONS']="${MYSQL_QUERY_OPTIONS:---batch --raw --default-character-set=utf8}"
  instanceNewInstance['DUMP_OPTIONS']="${MYSQL_DUMP_OPTIONS:---default-character-set=utf8  --compression-algorithms --hex-blob --routines --triggers --single-transaction --set-gtid-purged=OFF --column-statistics=0 ${instanceNewInstance['SSL_OPTIONS']}}"
  instanceNewInstance['DB_IMPORT_OPTIONS']="${DB_IMPORT_OPTIONS:---connect-timeout=5 --batch --raw --default-character-set=utf8}"

  instanceNewInstance['INITIALIZED']=1
}


# @description mysql query on a given db
# @warning could use QUERY_OPTIONS variable from dsn if defined
# @example
#   cat file.sql | Database::query ...
# @arg $1 instanceQuery:&Map<String,String> (passed by reference) database instance to use
# @arg $2 sqlQuery:String (optional) sql query or sql file to execute. if not provided or empty, the command can be piped
# @arg $3 dbName:String (optional) the db name
#
# @exitcode mysql command status code
Database::query() {
  local -n instanceQuery=$1
  local -a mysqlCommand=()
  local -a queryOptions

  mysqlCommand+=(mysql)
  mysqlCommand+=("--defaults-extra-file=${instanceQuery['AUTH_FILE']}")
  IFS=' ' read -r -a queryOptions <<<"${instanceQuery['QUERY_OPTIONS']}"
  mysqlCommand+=("${queryOptions[@]}")
  if [[ "${instanceQuery['SKIP_COLUMN_NAMES']}" = "1" ]]; then
    mysqlCommand+=("-s" "--skip-column-names")
  fi
  # add optional db name
  if [[ -n "${3+x}" ]]; then
    mysqlCommand+=("$3")
  fi
  # add optional sql query
  if [[ -n "${2+x}" && -n "$2" && ! -f "$2" ]]; then
    mysqlCommand+=("-e")
    mysqlCommand+=("$2")
  fi
  Log::displayDebug "$(printf "execute command: '%s'" "${mysqlCommand[*]}")"

  if [[ -f "$2" ]]; then
    "${mysqlCommand[@]}" <"$2"
  else
    "${mysqlCommand[@]}"
  fi
}


# @description set the general options to use on mysql command to query the database
# Differs than setOptions in the way that these options could change each time
#
# @arg $1 instanceSetQueryOptions:&Map<String,String> (passed by reference) database instance to use
# @arg $2 optionsList:String query options list
Database::setQueryOptions() {
  local -n instanceSetQueryOptions=$1
  # shellcheck disable=SC2034
  instanceSetQueryOptions['QUERY_OPTIONS']="$2"
}


# @description by default we skip the column names
# but sometimes we need column names to display some results
# disable this option temporarily and then restore it to true
#
# @arg $1 instanceSetQueryOptions:&Map<String,String> (passed by reference) database instance to use
# @arg $2 skipColumnNames:Boolean 0 to disable, 1 to enable (hide column names)
Database::skipColumnNames() {
  local -n instanceSkipColumnNames=$1
  # shellcheck disable=SC2034
  instanceSkipColumnNames['SKIP_COLUMN_NAMES']="$2"
}


# @description check if all requirements are satisfied
# to execute dbImport commands
Db::checkRequirements() {
  if [[ "${SKIP_REQUIREMENTS_CHECKS:-0}" = "1" ]]; then
    return 0
  fi
  local -i failures=0
  echo
  Assert::commandExists mysql "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists mysqlshow "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists mysqldump "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists pv "sudo apt-get install -y pv" || ((++failures))
  Assert::commandExists gawk "sudo apt-get install -y gawk" || ((++failures))
  Assert::commandExists awk "sudo apt-get install -y gawk" || ((++failures))
  Version::checkMinimal "gawk" "--version" "5.0.1" || ((++failures))
  return "${failures}"
}


# @description used to execute given query when using
# dbScriptAllDatabases
# @arg $1 dsn:String
# @arg $2 db:String
# @env query String
# @env optionSeparator String
Db::queryOneDatabase() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_EXECUTED_AS_USER_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireExecutedAsUser has not been loaded"
    exit 1
  fi

  # query and optionSeparator are passed via export
  local dsn="$1"
  local db="$2"

  local -A dbInstance
  Database::newInstance dbInstance "${dsn}"
  Database::setQueryOptions dbInstance "${dbInstance[QUERY_OPTIONS]} --connect-timeout=5"

  # identify columns header
  echo -n "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
  Database::skipColumnNames dbInstance 0

  # shellcheck disable=SC2154
  if ! Database::query dbInstance "${query}" "${db}" | sed "s/\t/${optionSeparator}/g"; then
    Log::fatal "database ${db} error" 1>&2
  fi
}


# @description default env file with all default values
# @stdout the default env filepath
Env::createDefaultEnvFile() {
  local envFile
  envFile="$(Framework::createTempFile "createDefaultEnvFileEnvFile")" || return 2

  (
    echo "BASH_FRAMEWORK_THEME=${BASH_FRAMEWORK_THEME:-default}"
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
    # shellcheck disable=SC2016
    echo 'BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"'
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${envFile}"
  echo "${envFile}"
}


# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}


# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  export REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED=1

  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  local defaultEnvFile
  defaultEnvFile="$(Env::createDefaultEnvFile)" || return 1
  configFiles+=("${defaultEnvFile}")
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  local localFrameworkConfigFile
  BASH_FRAMEWORK_DISPLAY_LEVEL="${__LEVEL_INFO}" \
    BASH_FRAMEWORK_LOG_LEVEL="${__LEVEL_OFF}" \
    Conf::loadNearestFile ".framework-config" localFrameworkConfigFile "$(pwd)" || true
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  while IFS='' read -r file; do
    # shellcheck source=/src/Env/createDefaultEnvFile.sh
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done < <(printf '%s\n' "${configFiles[@]}" | awk '!x[$0]++')
}


# @description concatenate 2 paths and ensure the path is correct using realpath -m
# @arg $1 basePath:String
# @arg $2 subPath:String
File::concatenatePath() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_REALPATH_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireRealpathCommand has not been loaded"
    exit 1
  fi

  local basePath="$1"
  local subPath="$2"
  local fullPath="${basePath:+${basePath}/}${subPath}"

  realpath -m "${fullPath}" 2>/dev/null
}


# @description search a file in parent directories
#
# @arg $1 fromPath:String path
# @arg $2 fileName:String
# @arg $3 untilInclusivePath:String (optional) find for given file until reaching this folder (default value: /)
# @arg $@ untilInclusivePaths:String[] list of untilInclusivePath
# @stdout The filename if found
# @exitcode 1 if the command failed or file not found
File::upFind() {
  local fromPath="$1"
  shift || true
  local fileName="$1"
  shift || true
  local untilInclusivePath="${1:-/}"
  shift || true

  if [[ -f "${fromPath}" ]]; then
    fromPath="${fromPath%/*}"
  fi
  while true; do
    if [[ -f "${fromPath}/${fileName}" ]]; then
      echo "${fromPath}/${fileName}"
      return 0
    fi
    if Array::contains "${fromPath}" "${untilInclusivePath}" "$@" "/"; then
      return 1
    fi
    fromPath="$(readlink -f "${fromPath}"/..)"
  done
  return 1
}


# @description create a temp file using default TMPDIR variable
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}


# @description ensure running user is not root
# @exitcode 1 if current user is root
# @stderr diagnostics information is displayed
Linux::requireExecutedAsUser() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_EXECUTED_AS_USER_LOADED=1

  if [[ "$(id -u)" = "0" ]]; then
    Log::fatal "this script should be executed as normal user"
  fi
}


# @description ensure command realpath is available
# @exitcode 1 if realpath command not available
# @stderr diagnostics information is displayed
Linux::requireRealpathCommand() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_REALPATH_COMMAND_LOADED=1

  Assert::commandExists realpath
}


# @description ensure command tar is available
# @exitcode 1 if tar command not available
# @stderr diagnostics information is displayed
Linux::requireTarCommand() {
  Assert::commandExists tar
}


declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description compute duration since last call to this function
# the result is set in following env variables.
# in ss.sss (seconds followed by milliseconds precision 3 decimals)
# @noargs
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @set LOG_LAST_LOG_DATE_INIT int (default 1) set to 0 at first call, allows to detect reference log
# @set LOG_LAST_DURATION_STR String the last duration displayed
# @set LOG_LAST_LOG_DATE String the last log date that will be used to compute next diff
Log::computeDuration() {
  if ((${DISPLAY_DURATION:-0} == 1)); then
    local -i duration=0
    local -i delta=0
    local durationStr deltaStr
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      if ((duration > 59)); then
        durationStr=$(date -ud "@${duration}" +'%H:%M:%S')
      else
        durationStr="${duration}s"
      fi
      if ((delta > 59)); then
        deltaStr=$(date -ud "@${delta}" +'%H:%M:%S')
      else
        deltaStr="${delta}s"
      fi
      LOG_LAST_DURATION_STR="${durationStr}/+${deltaStr}"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}


# @description Display message using debug color (gray)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}


# @description Display message using error color (red)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}


# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}


# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}


# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}


# @description Get the text representation of a log level
# @arg $1 level:String the log level to convert
# @exitcode 1 if the level is invalid
Log::getLevelText() {
  local level="$1"
  case "${level}" in
    "${__LEVEL_OFF}")
      echo OFF
      ;;
    "${__LEVEL_ERROR}")
      echo ERROR
      ;;
    "${__LEVEL_WARNING}")
      echo WARNING
      ;;
    "${__LEVEL_INFO}")
      echo INFO
      ;;
    "${__LEVEL_DEBUG}")
      echo DEBUG
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}


# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
Log::logMessage() {

  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Log::requireLoad has not been loaded"
    exit 1
  fi

  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}


# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
Log::requireLoad() {
  export REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED=1


  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement UI::requireTheme has not been loaded"
    exit 1
  fi

  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}


# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}


# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  local -i width=${COLUMNS:-0}
  if ((width == 0)) && [[ -t 1 ]]; then
    width=$(tput cols)
  fi
  if ((width == 0)); then
    width=80
  fi
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 1 ]] && tput cols || echo '80')}")
  echo
}


# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  export REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED=1

  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}


# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Gray
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}


# @description Check that command version is greater than expected minimal version
# display warning if command version greater than expected minimal version
# display error if command version less than expected minimal version and exit 1
# @arg $1 commandName:String command path
# @arg $2 argVersion:String command line parameters to launch to get command version
# @arg $3 minimalVersion:String expected minimal command version
# @arg $4 parseVersionCallback:Function
# @arg $5 help:String optional help message to display if command does not exist
# @exitcode 0 if command version greater or equal to expected minimal version
# @exitcode 1 if command version less than expected minimal version
# @exitcode 2 if command does not exist
Version::checkMinimal() {
  local commandName="$1"
  local argVersion="$2"
  local minimalVersion="$3"
  local parseVersionCallback=${4:-Version::parse}
  local help="${5:-}"

  Assert::commandExists "${commandName}" "${help}" || return 2

  # shellcheck disable=SC2034
  local status=0
  # shellcheck disable=SC2034
  local -a pipeStatus=()
  local version
  version="$("${commandName}" "${argVersion}" 2>&1 | ${parseVersionCallback} || Bash::handlePipelineFailure status pipeStatus)"

  Log::displayDebug "check ${commandName} version ${version} against minimal ${minimalVersion}"

  local result=0
  Version::compare "${version}" "${minimalVersion}" || result=$?
  case "${result}" in
    1)
      Log::displayInfo "${commandName} version is ${version} greater than ${minimalVersion}"
      ;;
    2)
      Log::displayError "${commandName} minimal version is ${minimalVersion}, your version is ${version}"
      return 1
      ;;
    *)
      Log::displaySuccess "${commandName} version is matching exactly the expected minimal version ${version}"
      ;;
  esac
}


# @description compare 2 version numbers
# @arg $1 version1:String version 1
# @arg $2 version2:String version 2
# @exitcode 0 if equal
# @exitcode 1 if version1 > version2
# @exitcode 2 else
Version::compare() {
  if [[ "$1" = "$2" ]]; then
    return 0
  fi
  local IFS=.
  # shellcheck disable=2206
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i = 0; i < ${#ver1[@]}; i++)); do
    if [[ -z "${ver2[i]+unset}" ]] || [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}


# @description filter to keep only version number from a string
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
Version::parse() {
  # match anything, print(p), exit on first match(Q)
  sed -En \
    -e 's/\x1b\[[0-9;]*[mGKHF]//g' \
    -e 's/[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/' \
    -e '//{p;Q}' \
    "$@"
}
# FUNCTIONS

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

beforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

copyrightCallback() {
  #
  # shellcheck disable=SC2155,SC2154,SC2250
  echo "Copyright (c) 2020-now François Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  Log::displayError "optionHelpCallback needs to be overridden"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${levelName}"
      return 1
      ;;
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionDisplayLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_INFO}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

optionLogLevelDefaultValueFunction() {
  Log::getLevelText "${BASH_FRAMEWORK_LOG_LEVEL:-${__LEVEL_OFF}}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >>"${overrideEnvFile}"
}

optionLogFileDefaultValueFunction() {
  # shellcheck disable=SC2016
  echo "${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}



defaultBeforeParseCallback() {
  BashTools::Conf::requireLoad
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

beforeParseCallback() {
  defaultBeforeParseCallback
}



declare -a PARALLEL_OPTIONS

optionProgressBarCallback() {
  PARALLEL_OPTIONS+=(--bar)
}

optionJobsCallback() {
  # shellcheck disable=SC2154
  if ! [[ "${optionJobs}" =~ ^[0-9]+$ ]]; then
    Log::fatal "number of jobs is incorrect"
  fi

  if [[ ${optionJobs} -lt 1 ]]; then
    Log::fatal "number of jobs must be greater than 0"
  fi
}



fromDsnOptionLongDescription() {
  local dsnList=""
  dsnList="$(Conf::getMergedList "dsn" "env" "      - ")"

  echo -e "  ${__HELP_TITLE}Data Source Name (DSN)${__HELP_NORMAL}"
  echo -e "    ${__HELP_TITLE}Default dsn directory:${__HELP_NORMAL}"
  echo -e "      ${BASH_TOOLS_ROOT_DIR}/conf/dsn"
  echo
  echo -e "    ${__HELP_TITLE}User dsn directory:${__HELP_NORMAL}"
  echo -e "      ${HOME}/.bash-tools/dsn"
  echo -e '      Allows to override dsn defined in "Default dsn directory"'
  echo
  echo -e "    ${__HELP_TITLE}List of available dsn:${__HELP_NORMAL}"
  echo -e "${dsnList}"
}



optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  Db::checkRequirements
  exit 0
}



declare QUERIES_DIR
declare HOME_QUERIES_DIR
declare queryIsFile="0"
declare optionSeparator="|"

# shellcheck disable=SC2034
declare copyrightBeginYear="2020"
# shellcheck disable=SC2034
declare defaultFromDsn="default.remote"

beforeParseCallback() {
  defaultBeforeParseCallback
  Linux::requireExecutedAsUser
  Linux::requireRealpathCommand
}

initConf() {
  # shellcheck disable=SC2034
  QUERIES_DIR="${BASH_TOOLS_ROOT_DIR}/conf/dbQueries"
  HOME_QUERIES_DIR="${HOME}/.bash-tools/dbQueries"

  Db::checkRequirements
}

optionHelpCallback() {
  dbQueryAllDatabasesCommandHelp
  exit 0
}

optionSeparatorCallback() {
  # shellcheck disable=SC2154
  if ((${#optionSeparator} != 1)); then
    Log::fatal "Command ${SCRIPT_NAME} - only one character is accepted as separator"
  fi

  if [[ ${optionSeparator} =~ [a-zA-Z0-9/\ ] ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - characters alphanumeric, slash(/) and space( ) are not supported as separator"
  fi
}

longDescriptionFunction() {
  local example1=$'dbQueryAllDatabases databaseSize -j 12 --separator "|" --bar 2>/dev/null | column -s "|" -t -n -c 40'

  local queriesList
  queriesList="$(Conf::getMergedList "dbQueries" "sql" "      - " || true)"

  fromDsnOptionLongDescription
  echo
  echo -e "  ${__HELP_TITLE}QUERIES${__HELP_NORMAL}"
  echo -e "    ${__HELP_TITLE}Default queries directory:${__HELP_NORMAL}"
  echo -e "      ${QUERIES_DIR-configuration error}"
  echo
  echo -e "    ${__HELP_TITLE}User queries directory:${__HELP_NORMAL}"
  echo -e "      ${HOME_QUERIES_DIR-configuration error}"
  echo -e "      Allows to override queries defined in 'Default queries directory'"
  echo
  echo -e "    ${__HELP_TITLE}List of available queries:${__HELP_NORMAL}"
  echo -e "${queriesList}"
  echo
  echo -e "  ${__HELP_TITLE}EXAMPLES:${__HELP_NORMAL}"
  echo -e "    ${__HELP_EXAMPLE}${example1}${__HELP_NORMAL}"
}

argQueryHelpFunction() {
  echo "    Query to execute"
  echo "      - <file>, try to execute the mysql query"
  echo "        provided by the file"
  echo '      - <queryFile>, search for query file in'
  echo '        queries directory (see below)'
  echo '      - else the argument is interpreted as'
  echo '        query string'
}

dbQueryAllDatabasesEveryArgumentCallback() {
  if [[ -n "${DB_QUERY_ALL_DATABASES_COMMAND:-}" ]]; then
    # a command is defined, then accept that arguments can be overridden
    return 1
  fi
}

argQueryCallback() {
  if [[ -f "${argQuery}" ]]; then
    queryIsFile="1"
  else
    declare queryAbsoluteFile
    queryAbsoluteFile="$(Conf::getAbsoluteFile "dbQueries" "${argQuery}" "sql")" && {
      # shellcheck disable=SC2034
      queryIsFile="1"
      argQuery="${queryAbsoluteFile}"
      Log::displayInfo "Using query file ${queryAbsoluteFile}"
    }
  fi
}

dbQueryAllDatabasesCommandCallback() {
  if [[ -z "${optionFromDsn}" ]]; then
    # default value for FROM_DSN if from-aws not set
    optionFromDsn="${defaultFromDsn}"
  fi
}


# ------------------------------------------
# Command dbQueryAllDatabasesCommand
# ------------------------------------------

# options variables initialization
declare optionJobs="1"
declare optionProgressBar="0"
declare optionFromDsn=""
declare optionHelp="0"
declare optionConfig="0"
declare optionBashFrameworkConfig=""
declare optionInfoVerbose="0"
declare optionDebugVerbose="0"
declare optionTraceVerbose="0"
declare optionLogLevel="optionLogLevelDefaultValueFunction"
declare optionLogFile="optionLogFileDefaultValueFunction"
declare optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
declare optionNoColor="0"
declare optionTheme="default"
declare optionVersion="0"
declare optionQuiet="0"
declare optionSeparator="|"
# arguments variables initialization
declare argQuery=""
# @description parse command options and arguments for dbQueryAllDatabasesCommand
dbQueryAllDatabasesCommandParse() {
  Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
  Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  optionJobs="1"
  local -i options_parse_optionParsedCountOptionJobs
  ((options_parse_optionParsedCountOptionJobs = 0)) || true
  optionProgressBar="0"
  local -i options_parse_optionParsedCountOptionProgressBar
  ((options_parse_optionParsedCountOptionProgressBar = 0)) || true
  optionFromDsn=""
  local -i options_parse_optionParsedCountOptionFromDsn
  ((options_parse_optionParsedCountOptionFromDsn = 0)) || true
  optionHelp="0"
  local -i options_parse_optionParsedCountOptionHelp
  ((options_parse_optionParsedCountOptionHelp = 0)) || true
  optionConfig="0"
  local -i options_parse_optionParsedCountOptionConfig
  ((options_parse_optionParsedCountOptionConfig = 0)) || true
  optionBashFrameworkConfig=""
  local -i options_parse_optionParsedCountOptionBashFrameworkConfig
  ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
  optionInfoVerbose="0"
  local -i options_parse_optionParsedCountOptionInfoVerbose
  ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
  optionDebugVerbose="0"
  local -i options_parse_optionParsedCountOptionDebugVerbose
  ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
  optionTraceVerbose="0"
  local -i options_parse_optionParsedCountOptionTraceVerbose
  ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
  optionLogLevel="optionLogLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogLevel
  ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
  optionLogFile="optionLogFileDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionLogFile
  ((options_parse_optionParsedCountOptionLogFile = 0)) || true
  optionDisplayLevel="optionDisplayLevelDefaultValueFunction"
  local -i options_parse_optionParsedCountOptionDisplayLevel
  ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
  optionNoColor="0"
  local -i options_parse_optionParsedCountOptionNoColor
  ((options_parse_optionParsedCountOptionNoColor = 0)) || true
  optionTheme="default"
  local -i options_parse_optionParsedCountOptionTheme
  ((options_parse_optionParsedCountOptionTheme = 0)) || true
  optionVersion="0"
  local -i options_parse_optionParsedCountOptionVersion
  ((options_parse_optionParsedCountOptionVersion = 0)) || true
  optionQuiet="0"
  local -i options_parse_optionParsedCountOptionQuiet
  ((options_parse_optionParsedCountOptionQuiet = 0)) || true
  optionSeparator="|"
  local -i options_parse_optionParsedCountOptionSeparator
  ((options_parse_optionParsedCountOptionSeparator = 0)) || true

  argQuery=""

  local -i options_parse_argParsedCountArgQuery
  ((options_parse_argParsedCountArgQuery = 0)) || true


  # shellcheck disable=SC2034
  local -i options_parse_parsedArgIndex=0
  while (($# > 0)); do
    local options_parse_arg="$1"
    local argOptDefaultBehavior=0
    case "${options_parse_arg}" in
      # Option 1/17
      # optionJobs alts --jobs|-j
      # type: String min 0 max 1
      --jobs | -j)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionJobs >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionJobs))
        # shellcheck disable=SC2034
        optionJobs="$1"
        optionJobsCallback "${options_parse_arg}" "${optionJobs}"

        ;;

      # Option 2/17
      # optionProgressBar alts --bar|-b
      # type: Boolean min 0 max 1
      --bar | -b)
        # shellcheck disable=SC2034
        optionProgressBar="1"

        if ((options_parse_optionParsedCountOptionProgressBar >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionProgressBar))
        optionProgressBarCallback "${options_parse_arg}" "${optionProgressBar}"

        ;;

      # Option 3/17
      # optionFromDsn alts --from-dsn|-f
      # type: String min 0 max 1
      --from-dsn | -f)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionFromDsn >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionFromDsn))
        # shellcheck disable=SC2034
        optionFromDsn="$1"
        ;;

      # Option 4/17
      # optionHelp alts --help|-h
      # type: Boolean min 0 max 1
      --help | -h)
        # shellcheck disable=SC2034
        optionHelp="1"

        if ((options_parse_optionParsedCountOptionHelp >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionHelp))
        optionHelpCallback "${options_parse_arg}" "${optionHelp}"

        ;;

      # Option 5/17
      # optionConfig alts --config
      # type: Boolean min 0 max 1
      --config)
        # shellcheck disable=SC2034
        optionConfig="1"

        if ((options_parse_optionParsedCountOptionConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfig))
        ;;

      # Option 6/17
      # optionBashFrameworkConfig alts --bash-framework-config
      # type: String min 0 max 1
      --bash-framework-config)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
        # shellcheck disable=SC2034
        optionBashFrameworkConfig="$1"
        optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"

        ;;

      # Option 7/17
      # optionInfoVerbose alts --verbose|-v
      # type: Boolean min 0 max 1
      --verbose | -v)
        # shellcheck disable=SC2034
        optionInfoVerbose="1"

        if ((options_parse_optionParsedCountOptionInfoVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionInfoVerbose))
        optionInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        updateArgListInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        ;;

      # Option 8/17
      # optionDebugVerbose alts -vv
      # type: Boolean min 0 max 1
      -vv)
        # shellcheck disable=SC2034
        optionDebugVerbose="1"

        if ((options_parse_optionParsedCountOptionDebugVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDebugVerbose))
        optionDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        updateArgListDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        ;;

      # Option 9/17
      # optionTraceVerbose alts -vvv
      # type: Boolean min 0 max 1
      -vvv)
        # shellcheck disable=SC2034
        optionTraceVerbose="1"

        if ((options_parse_optionParsedCountOptionTraceVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTraceVerbose))
        optionTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        updateArgListTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        ;;

      # Option 10/17
      # optionLogLevel alts --log-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --log-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogLevel))
        # shellcheck disable=SC2034
        optionLogLevel="$1"
        optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        ;;

      # Option 11/17
      # optionLogFile alts --log-file
      # type: String min 0 max 1
      --log-file)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogFile))
        # shellcheck disable=SC2034
        optionLogFile="$1"
        optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        ;;

      # Option 12/17
      # optionDisplayLevel alts --display-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --display-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionDisplayLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDisplayLevel))
        # shellcheck disable=SC2034
        optionDisplayLevel="$1"
        optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        ;;

      # Option 13/17
      # optionNoColor alts --no-color
      # type: Boolean min 0 max 1
      --no-color)
        # shellcheck disable=SC2034
        optionNoColor="1"

        if ((options_parse_optionParsedCountOptionNoColor >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionNoColor))
        optionNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        updateArgListNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        ;;

      # Option 14/17
      # optionTheme alts --theme
      # type: String min 0 max 1
      # authorizedValues: default|default-force|noColor
      --theme)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ default|default-force|noColor ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default, default-force, noColor)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionTheme >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTheme))
        # shellcheck disable=SC2034
        optionTheme="$1"
        optionThemeCallback "${options_parse_arg}" "${optionTheme}"

        updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"

        ;;

      # Option 15/17
      # optionVersion alts --version
      # type: Boolean min 0 max 1
      --version)
        # shellcheck disable=SC2034
        optionVersion="1"

        if ((options_parse_optionParsedCountOptionVersion >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionVersion))
        optionVersionCallback "${options_parse_arg}" "${optionVersion}"

        ;;

      # Option 16/17
      # optionQuiet alts --quiet|-q
      # type: Boolean min 0 max 1
      --quiet | -q)
        # shellcheck disable=SC2034
        optionQuiet="1"

        if ((options_parse_optionParsedCountOptionQuiet >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionQuiet))
        optionQuietCallback "${options_parse_arg}" "${optionQuiet}"

        updateArgListQuietCallback "${options_parse_arg}" "${optionQuiet}"

        ;;

      # Option 17/17
      # optionSeparator alts --separator|-s
      # type: String min 0 max 1
      --separator | -s)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionSeparator >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionSeparator))
        # shellcheck disable=SC2034
        optionSeparator="$1"
        optionSeparatorCallback "${options_parse_arg}" "${optionSeparator}"

        ;;

      -*)
        if [[ "${argOptDefaultBehavior}" = "0" ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
          return 1
        fi
        ;;
      *)
        ((minParsedArgIndex0 = 0)) || true
        ((maxParsedArgIndex0 = 0)) || true
        ((minParsedArgIndex1 = minParsedArgIndex0 + 1)) || true
        ((maxParsedArgIndex1 = maxParsedArgIndex0 + 1)) || true
        ((incrementArg = 1 ))
        if ((0)); then
          # Technical if - never reached
          :

        # Argument 1/1 - argQuery
        # Argument argQuery min 1 max 1
        elif (( options_parse_parsedArgIndex >= minParsedArgIndex0 &&
          options_parse_parsedArgIndex < maxParsedArgIndex1 )); then
          if ((options_parse_argParsedCountArgQuery >= 1 )); then
            Log::displayError "Command ${SCRIPT_NAME} - Argument argQuery - Maximum number of argument occurrences reached(1)"
            return 1
          fi
          ((++options_parse_argParsedCountArgQuery))
          # shellcheck disable=SC2034
          argQuery="${options_parse_arg}"
          argQueryCallback "${argQuery}" -- "${@:2}"


        # else too much args
        else

          # shellcheck disable=SC2317
        dbQueryAllDatabasesEveryArgumentCallback "" "${options_parse_arg}"|| argOptDefaultBehavior=$?


          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            # too much args and no unknownArgumentCallbacks configured
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
            return 1
          fi

        fi
        if ((incrementArg == 1)); then
          ((++options_parse_parsedArgIndex))
        fi
        ;;
    esac
    shift || true
  done

















  if ((options_parse_argParsedCountArgQuery < 1 )); then
    Log::displayError "Command ${SCRIPT_NAME} - Argument 'argQuery' should be provided at least 1 time(s)"
    return 1
  fi || return $?


  commandOptionParseFinished
  dbQueryAllDatabasesCommandCallback

}

# @description display command options and arguments help for dbQueryAllDatabasesCommand
dbQueryAllDatabasesCommandHelp() {

}


beforeParseCallback
initConf

dbQueryAllDatabasesCommandParse "$@"
MAIN_FUNCTION_NAME="main"
main() {

Linux::requireTarCommand
Compiler::Embed::extractFileFromBase64 \
  "${PERSISTENT_TMPDIR:-/tmp}/101ee8873657e2b35014acccb93127462c5f709e4e72f74dfa2c94a05be94876/dbQueryAllDatabasesScript" \
  "QkVHSU57CiAgaGVhZGVyUHJpbnRlZD0wCn0KL14kLyB7bmV4dH0KewogIGJ1ZmZlciA9IHN1YnN0cigkMCwgMCwgMzUpCiAgbGluZSA9ICQwCiAgaWYoYnVmZmVyID09ICJAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQCIpIHsKICAgIGlmIChoZWFkZXJQcmludGVkID09IDApIHsKICAgICAgbGluZT1zdWJzdHIobGluZSwgMzYpCiAgICAgIGhlYWRlclByaW50ZWQ9MQogICAgfSBlbHNlIHsKICAgICAgbmV4dAogICAgfQogIH0KICBwcmludCBsaW5lCgp9Cg==" \
  "644"

declare -gx embed_file_dbQueryAllDatabasesScript="${PERSISTENT_TMPDIR:-/tmp}/101ee8873657e2b35014acccb93127462c5f709e4e72f74dfa2c94a05be94876/dbQueryAllDatabasesScript"


# later on, parallel calls this script(inception)
if [[ "${DB_QUERY_ALL_DATABASES_COMMAND}" = "DbQueryOneDatabase" ]]; then
  shift || true
  Linux::requireExecutedAsUser
  Db::queryOneDatabase "${ORIGINAL_BASH_FRAMEWORK_ARGV[@]}"
  exit 0
fi

# query contains the sql from argQuery or from query string if -q option is provided
# shellcheck disable=SC2154
declare query="${argQuery}"
# shellcheck disable=SC2154
if [[ "${queryIsFile}" = "1" ]]; then
  query="$(cat "${argQuery}")"
fi

declare -Agx dbInstance
Database::newInstance dbInstance "${optionFromDsn}"
Database::setQueryOptions dbInstance "${dbInstance['QUERY_OPTIONS']} --connect-timeout=5"
Log::displayInfo "Using dsn ${dbInstance['DSN_FILE']}"

# list of all databases
allDbs="$(Database::getUserDbList dbInstance)"
PARALLEL_OPTIONS+=("-j" "${optionJobs}")

# query all databases
export query
export optionSeparator
export optionFromDsn
export DB_QUERY_ALL_DATABASES_COMMAND="DbQueryOneDatabase"
# shellcheck disable=SC2154
echo "${allDbs}" |
  SHELL=$(type -p bash) \
    parallel --bar --eta --progress "${PARALLEL_OPTIONS[@]}" \
    "$0" "${optionFromDsn}" |
  awk -f "${embed_file_dbQueryAllDatabasesScript}" -

}

# if file is sourced avoid calling main function
# shellcheck disable=SC2178
BASH_SOURCE=".$0" # cannot be changed in bash
# shellcheck disable=SC2128
if test ".$0" == ".${BASH_SOURCE}"; then
  if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
    main "$@" &>/dev/null
  else
    main "$@"
  fi
fi
