#!/usr/bin/env bash

CURRENT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
# load bash-framework
# shellcheck source=bash-framework/_bootstrap.sh
source "$( cd "${CURRENT_DIR}/.." && pwd )/bash-framework/_bootstrap.sh"

Framework::expectNonRootUser

import bash-framework/Database
import bash-framework/Array
import bash-framework/Functions

# ensure that Ctrl-C is trapped by this script and not sub mysql process
trap 'exit 130' INT

#default values
SCRIPT_NAME=${0##*/}
JOBS_NUMBER=1
QUERY=0
MYSQL_OPTIONS=""
DSN="default.local"
QUERIES_DIR="$(cd "${CURRENT_DIR}/.." && pwd)/conf/dbQueries"
HOME_QUERIES_DIR="${HOME}/.bash-tools/dbQueries"

declare -a PARALLEL_OPTIONS
# check dependencies
Functions::checkCommandExists mysql "sudo apt-get install mysql-client"
Functions::checkCommandExists mysqlshow "sudo apt-get install mysql-client"
Functions::checkCommandExists pv "sudo apt-get install -y pv"

# Usage info
showHelp() {
local dsnList queriesList 
dsnList="$(Functions::getConfMergedList "dsn" "env")"
queriesList="$(Functions::getConfMergedList "dbQueries" "sql" || true)"
cat << EOF
Description: Execute a query on multiple databases in order to generate a report, query can be parallelized on multiple databases

Usage: ${SCRIPT_NAME} [-h|--help] prints this help and exits
Usage: ${SCRIPT_NAME} <query|queryFile> [-d|--dsn <dsn>] [-t|--as-tsv] [-q|--query] [--jobs|-j <jobsCount>] [--bar|-b]

    -t|--as-tsv           show results as tsv file (separated by tabulations)
    -q|--query            implies <query> parameter is a mysql query string
    -d|--dsn <dsn>        to use for target mysql server (Default: ${DSN}) 
    -j|--jobs <jobsCount> specify the number of db to query in parallel (this needs the use of gnu parallel)
    -b|--bar              Show progress as a progress bar. In the bar is shown: % of jobs completed, estimated seconds left, and number of jobs started.
    <query|queryFile>
        if -q option is provided this parameter is a mysql query string
        else a file must be specified

List of available dsn: 
${dsnList}
List of available queries (default dir ${QUERIES_DIR} overridable in home dir ${HOME_QUERIES_DIR}):
${queriesList}
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help,as-tsv,query,bar,jobs:,dsn: -o htqbj:d: -- "$@" 2> /dev/null) || {
    showHelp
    Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true
do
case $1 in
-h|--help)
    showHelp
    exit 0
    ;;
--as-tsv|-t)
    MYSQL_OPTIONS="--batch --raw"
    ;;
--jobs|-j)
    shift
    JOBS_NUMBER=$1
    ;;
--bar|-b)
    PARALLEL_OPTIONS+=("--bar")
    ;;
--query|-q)
    QUERY=1
    ;;
--dsn|-d)
    shift
    DSN=${1:-:-default.local}
    ;;
--)
    shift
    break;;
*)
    showHelp
    Log::fatal "invalid argument $1"
esac
shift
done

# additional arguments
shift $(( OPTIND - 1 ))

# if -q option provided (QUERY =1), queryFile is supposed to be a file, 
# else it is a query string by default
queryFile=$1
if [[ -z "${queryFile}" ]]; then
    if [[ "${QUERY}" = "0" ]]; then
        Log::fatal "You must provide the sql file to be executed"
    fi
    Log::fatal "You must provide the sql string to be executed"
fi

# query contains the sql from queryFile or from query string if -q option is provided
declare query="${queryFile}"
if [[ "${QUERY}" = "0" ]]; then
    if [[ ! -f "${queryFile}" ]]; then
        Log::fatal "the file ${queryFile} does not exist"
    fi
    query="$(cat "${queryFile}")"
fi

if ! [[ ${JOBS_NUMBER} =~ ^[0-9]+$ ]] ; then
   Log::fatal "number of jobs is incorrect"
fi

[[ ${JOBS_NUMBER} -lt 1 ]] && Log::fatal "number of jobs must be greater than 0"
[[ ${JOBS_NUMBER} -gt 1 ]] && Functions::checkCommandExists parallel "sudo apt-get install parallel"

declare -Agx dbInstance
Database::newInstance dbInstance "${DSN}"
Database::setOptions dbInstance "${MYSQL_OPTIONS} --connect-timeout=5"

# list of all databases
allDbs="$(Database::query dbInstance "show databases" "mysql" | tail -n +2 | grep -Ev "performance_schema|information_schema|mysql")"
if [[ "${JOBS_NUMBER}" = "1" ]] ; then
    (
        headerLineDisplayed=0
        declare db
        echo "${allDbs}" | while IFS=" " read -r db; do
            # errors will be shown on stderr, result on stdout
            if [[ "${headerLineDisplayed}" = "0" ]]; then
                Database::query dbInstance "${query}" "${db}" || (
                    Log::displayError "database ${db} error" >&2
                )
                headerLineDisplayed=1
            else
                # remove first header line
                (Database::query dbInstance "${query}" "${db}" | sed 1d) || (
                    Log::displayError "database ${db} error" >&2
                )
            fi
        done
    )
else
    PARALLEL_OPTIONS+=("--linebuffer" "-j" "${JOBS_NUMBER}")

    export query
    export MYSQL_OPTIONS
    echo "${allDbs}" |
        parallel "${PARALLEL_OPTIONS[@]}" "${CURRENT_DIR}/_dbQueryOneDatabase.sh" "${DSN}" \
            | sed -E '1!{/^@@@/d}' \
            | sed 's/^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//'
fi
