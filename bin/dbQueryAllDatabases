#!/usr/bin/env bash

CURRENT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
# load bash-framework
# shellcheck source=bash-framework/_bootstrap.sh
source "$( cd "${CURRENT_DIR}/.." && pwd )/bash-framework/_bootstrap.sh"

Framework::expectNonRootUser

import bash-framework/Database
import bash-framework/Array
import bash-framework/Functions

# ensure that Ctrl-C is trapped by this script and not sub mysql process
trap 'exit 130' INT

#default values
SCRIPT_NAME=${0##*/}
JOBS_NUMBER=1
QUERY=0
MYSQL_OPTIONS=""
DSN="default.local"
QUERIES_DIR="$(cd "${CURRENT_DIR}/.." && pwd)/conf/dbQueries"
HOME_QUERIES_DIR="${HOME}/.bash-tools/dbQueries"

declare -a PARALLEL_OPTIONS
# check dependencies
Functions::checkCommandExists mysql "sudo apt-get install mysql-client"
Functions::checkCommandExists mysqlshow "sudo apt-get install mysql-client"
Functions::checkCommandExists pv "sudo apt-get install -y pv"

# Usage info
showHelp() {
DSN_LIST="$(Database::getDsnList  | sed 's/^/       - /')"
local queriesList="$(Functions::getList "${QUERIES_DIR}" "sql" || true)"
local homeQueriesList="$(Functions::getList "${HOME_QUERIES_DIR}" "sql" || true)"
cat << EOF
Description: Execute a query on multiple databases in order to generate a report, query can be parallelized on multiple databases

Usage: ${SCRIPT_NAME} [-h|--help] prints this help and exits
Usage: ${SCRIPT_NAME} <query|queryFile> [-d|--dsn <dsn>] [-t|--as-tsv] [-q|--query] [--jobs|-j <jobsCount>] [--bar|-b]

    -t|--as-tsv           show results as tsv file (separated by tabulations)
    -q|--query            implies <query> parameter is a mysql query string
    -d|--dsn <dsn>        to use for target mysql server (Default: ${DSN}) 
    -j|--jobs <jobsCount> specify the number of db to query in parallel (this needs the use of gnu parallel)
    -b|--bar              Show progress as a progress bar. In the bar is shown: % of jobs completed, estimated seconds left, and number of jobs started.
    <query|queryFile>
        if -q option is provided this parameter is a mysql query string
        else a file must be specified

    List of available dsn: 
${DSN_LIST}
    List of available home queries (${HOME_QUERIES_DIR}): 
${homeQueriesList}
    List of available queries : 
${queriesList}
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help,as-tsv,query,bar,jobs:,dsn: -o htqbj:d: -- "$@" 2> /dev/null) || {
    Log::displayError "invalid options specified"
    showHelp
    exit 1
}

eval set -- "${options}"
while true
do
case $1 in
-h|--help)
    showHelp
    exit 0
    ;;
--as-tsv|-t)
    MYSQL_OPTIONS="--batch --raw"
    ;;
--jobs|-j)
    shift
    JOBS_NUMBER=$1
    ;;
--bar|-b)
    PARALLEL_OPTIONS+=("--bar")
    ;;
--query|-q)
    QUERY=1
    ;;
--dsn|-d)
    shift
    DSN=${1:-:-default.local}
    ;;
--)
    shift
    break;;
*)
    Log::displayError "invalid argument $1"
    showHelp
    exit 1
esac
shift
done

# additional arguments
shift $(( OPTIND - 1 ))

queryFile=$1
if [[ -z "${queryFile}" ]]; then
    if [[ "${QUERY}" = "0" ]]; then
        Log::displayError "You must provide the sql file to be executed"
    else
        Log::displayError "You must provide the sql string to be executed"
    fi
    exit 1
fi

declare query="${queryFile}"
if [[ "${QUERY}" = "0" ]]; then
    if [[ ! -f "${queryFile}" ]]; then
        Log::displayError "the file ${queryFile} does not exist"
        exit 1
    fi
    query="$(cat "${queryFile}")"
fi


if ! [[ ${JOBS_NUMBER} =~ ^[0-9]+$ ]] ; then
   Log::displayError "number of jobs is incorrect"
   exit 1
fi

if [[ ${JOBS_NUMBER} -lt 1 ]] ; then
    Log::displayError "number of jobs must be greater than 0"
    exit 1
fi
if [[ ${JOBS_NUMBER} -gt 1 ]] ; then
    Functions::checkCommandExists parallel "sudo apt-get install parallel"
fi

declare -Agx dbInstance
Database::newInstance dbInstance "${DSN}"
Database::setOptions dbInstance "${MYSQL_OPTIONS} --connect-timeout=5"

# list of all databases
if [[ "${JOBS_NUMBER}" = "1" ]] ; then
    (
        allDbs="$(Database::query dbInstance "show databases" | tail -n +2)"
        headerLineDisplayed=0
        declare db
        echo "${allDbs}" | while IFS=" " read db; do
            if ! Array::contains "${db}" "performance_schema" "information_schema" "mysql" ; then
                # errors will be shown on stderr, result on stdout
                if [[ "${headerLineDisplayed}" = "0" ]]; then
                    Database::query dbInstance "${query}" "${db}" || (
                      Log::displayError "database ${db} error" >&2
                    )
                    headerLineDisplayed=1
                else
                    # remove first header line
                    (Database::query dbInstance "${query}" "${db}" | sed 1d) || (
                      Log::displayError "database ${db} error" >&2
                    )
                fi
            fi
        done
    )
else
    PARALLEL_OPTIONS+=("--linebuffer" "-j" "${JOBS_NUMBER}")

    export query
    export MYSQL_OPTIONS
    Database::query dbInstance "show databases" "mysql" |
        parallel "${PARALLEL_OPTIONS[@]}" "${CURRENT_DIR}/_dbQueryOneDatabase.sh" \
            "${HOSTNAME}" "${PORT}" "${USER}" "${PASSWORD}" \
            | sed -E '1!{/^@@@/d}' \
            | sed 's/^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//'
fi
