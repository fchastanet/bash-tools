#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-tools/tree/master/src/_binaries/Git/upgradeGithubRelease.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${FRAMEWORK_ROOT_DIR}/bin/upgradeGithubRelease
# VAR_RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR=..
# FACADE

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
mkdir -p "${PERSISTENT_TMPDIR}"

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if can
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap() {
  local glue="${1-}"
  local -i glueLength=0
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  local -i firstLine=1
  shift || true
  (($# != 0)) || return 0

  local arg

  # convert multi-line arg to several args
  local -a allArgs=()
  for arg in "$@"; do
    local line
    local IFS=$'\n'
    arg="$(echo -e "${arg}")"
    while read -r line; do
      if [[ -z "${line}" ]]; then
        allArgs+=($'\n')
      else
        allArgs+=("${line}")
      fi
    done <<<"${arg}"
  done
  set -- "${allArgs[@]}"

  local -i currentLineLength=0
  local needEcho="0"
  local arg="$1"
  local argNoAnsi
  local -i argNoAnsiLength=0

  while (($# > 0)); do
    argNoAnsi="$(echo "${arg%%*( )}" | Filters::removeAnsiCodes)"
    ((argNoAnsiLength = ${#argNoAnsi})) || true
    if (($# < 1 && argNoAnsiLength == 0)); then
      break
    fi
    if [[ "${arg}" = $'\n' ]]; then
      if [[ "${needEcho}" = "1" ]]; then
        needEcho="0"
      fi
      echo ""
      ((currentLineLength = 0)) || true
      ((glueLength = 0)) || true
      shift || return 0
      arg="$1"
    elif ((argNoAnsiLength < maxLineLength - currentLineLength - glueLength)); then
      # arg can be stored as a whole on current line
      if ((glueLength > 0)); then
        echo -e -n "${glue}"
        ((currentLineLength += glueLength))
      fi
      if ((currentLineLength == 0 && firstLine == 0)); then
        echo -n "${indentStr}"
      fi
      echo -e -n "${arg}" | sed 's/[\t ]*$//g'
      needEcho="1"
      ((currentLineLength += argNoAnsiLength))
      ((glueLength = ${#glue})) || true
      shift || return 0
      arg="$1"
    else
      if ((argNoAnsiLength >= (maxLineLength - indentNextLine))); then
        if ((currentLineLength == 0 && firstLine == 0)); then
          echo -n "${indentStr}"
          ((currentLineLength += indentNextLine))
        fi
        # arg can be stored on a whole line
        if ((glueLength > 0)); then
          echo -e -n "${glue}"
          ((currentLineLength += glueLength))
        fi
        local -i length
        ((length = maxLineLength - currentLineLength)) || true
        echo -e "${arg:0:${length}}" | sed 's/[\t ]*$//g'
        ((currentLineLength = 0)) || true
        ((glueLength = 0)) || true
        arg="${arg:${length}}"
        needEcho="0"
      else
        # arg cannot be stored on a whole line, so we add it on next line as a whole
        echo
        echo -e -n "${indentStr}${arg}" | sed 's/[\t ]*$//g'
        ((glueLength = ${#glue})) || true
        ((currentLineLength = argNoAnsiLength))
        arg="" # allows to go to next arg
        needEcho="1"
      fi
      if [[ -z "${arg}" ]]; then
        shift || return 0
        arg="$1"
      fi
    fi
    ((firstLine = 0)) || true
  done
  if [[ "${needEcho}" = "1" ]]; then
    echo
  fi
}

#set -x
#Array::wrap ":" 40 0 "Lorem ipsum dolor sit amet," "consectetur adipiscing elit." "Curabitur ac elit id massa" "condimentum finibus."

# Checks if file can be created in folder
#

# @description Checks if file can be created in folder
# The file does not need to exist
# @arg $1 file:String
# @exitcode 1 if file is not a valid path
# @exitcode 2 if file parent's dir is not writable
# @exitcode 3 if existing file is not writable
# @see Assert::validPath
Assert::fileWritable() {
  local file="$1"
  local dir

  Assert::validPath "${file}" || return 1
  if [[ -f "${file}" ]]; then
    [[ -w "${file}" ]] || return 3
  else
    dir="$(dirname "${file}")"
    [[ -w "${dir}" ]] || return 2
  fi

}

# @description check if argument is a valid linux path
# invalid path are those with:
# - invalid characters
# - component beginning by a - (because could be considered as a command's option)
# - not beginning with a slash
# - relative
#
# @arg $1 path:string path that needs to be checked
# @exitcode 1 if path is invalid
# @see https://regex101.com/r/afLrmM/2
# @see Assert::validPosixPath if you need more restrictive check
Assert::validPath() {
  local path="$1"

  [[ "${path}" =~ ^\/$|^(\/[.a-zA-Z_0-9][.a-zA-Z_0-9-]*)+$ ]] &&
    [[ ! "${path}" =~ (\/\.\.)|(\.\.\/)|^\.$|^\.\.$ ]] # avoid relative
}

# @description ensure env files are loaded
# @noargs
# @exitcode 1 if getOrderedConfFiles fails
# @exitcode 2 if one of env files fails to load
# @stderr diagnostics information is displayed
Env::requireLoad() {
  local configFilesStr
  configFilesStr="$(Env::getOrderedConfFiles)" || return 1

  local -a configFiles
  readarray -t configFiles <<<"${configFilesStr}"

  # if empty string, there will be one element
  if ((${#configFiles[@]} == 0)) || [[ -z "${configFilesStr}" ]]; then
    # should not happen, as there is always default file
    Log::displaySkipped "no env file to load"
    return 0
  fi

  Env::mergeConfFiles "${configFiles[@]}" || {
    Log::displayError "while loading config files: ${configFiles[*]}"
    return 2
  }
}

# @description load .framework-config
# @arg $1 loadedConfigFile:&String (passed by reference) the finally loaded configuration file path
# @arg $@ srcDirs:String[] the src directories in which .framework-config file will be searched
# @stdout the config file path loaded if any
# @exitcode 0 if .framework-config file has been found in srcDirs provided
# @exitcode 1 if .framework-config file not found
# @see Conf::loadNearestFile
Framework::loadConfig() {
  # shellcheck disable=SC2034
  local -n loadConfig_loadedConfigFile=$1
  shift || true
  Conf::loadNearestFile ".framework-config" loadConfig_loadedConfigFile "$@"
}

# @description intermediate callback that is used by Github::upgradeRelease
# or Github::installRelease
# if installCallback is not set, it allows to:
#   - copy the downloaded file to the right target file
#   - and set the execution bit
# else
#   installCallback is called with newSoftware, targetFile, version arguments
# fi
# @warning do not use this function as callback for Github::upgradeRelease or Github::installRelease, as it would result to an infinite loop
# @arg $1 newSoftware:String the downloaded software file
# @arg $2 targetFile:String where we want to copy the file
# @arg $3 version:String the version that has been downloaded
# @arg $4 installCallback:Function (optional) the callback to call with 3 first arguments
# @exitcode * on failure
# @see Github::upgradeRelease
# @see Github::installRelease
# @internal
Github::defaultInstall() {
  local newSoftware="$1"
  local targetFile="$2"
  local version="$3"
  local installCallback=$4
  # shellcheck disable=SC2086
  mkdir -p "$(dirname "${targetFile}")"
  if [[ "$(type -t "${installCallback}")" = "function" ]]; then
    ${installCallback} "${newSoftware}" "${targetFile}" "${version}"
  else
    mv "${newSoftware}" "${targetFile}"
    chmod +x "${targetFile}"
    hash -r
    rm -f "${newSoftware}" || true
  fi
}

# @description download specified release software version from github
# @arg $1 releaseUrl:String eg: https://github.com/kubernetes-sigs/kind/releases/download/v1.0.0/kind-linux-amd64
# @exitcode 1 on failure
# @stdout the path to the downloaded release
Github::downloadReleaseVersion() {
  local releaseUrl="$1"
  local newSoftwarePath

  # download specified version
  newSoftwarePath=$(mktemp -p "${TMPDIR:-/tmp}" -t github.newSoftware.XXXX)
  Retry::default curl \
    -L \
    -o "${newSoftwarePath}" \
    --fail \
    "${releaseUrl}" || return 1
  echo "${newSoftwarePath}"
}

# @description Retrieve the latest version number for given github url
# @arg $1 releaseUrl:String github url from which repository will be extracted
# @stderr log messages about retry
# @stdout the version number retrieved
Github::getLatestVersionFromUrl() {
  local releaseUrl="$1"
  local repo
  local latestVersion
  # extract repo from github url
  repo="$(Github::extractRepoFromGithubUrl "${releaseUrl}")" || return 1

  # get latest release version
  if ! Github::getLatestRelease "${repo}" latestVersion; then
    Log::displayError "Repository ${repo} latest version not found"
    return 1
  fi
  Log::displayInfo "Repo ${repo} latest version found is ${latestVersion}"
  echo "${latestVersion}"
}

# @description check if specified release software version exists in github
# @arg $1 releaseUrl:String eg: https://github.com/kubernetes-sigs/kind/releases/download/v1.0.0/kind-linux-amd64
# @exitcode 1 on failure
# @exitcode 0 if release version exists
Github::isReleaseVersionExist() {
  local releaseUrl="$1"

  curl \
    -L \
    -o /dev/null \
    --silent \
    --head \
    --fail \
    "${releaseUrl}"
}

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__INFO_COLOR}${type}    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using info color (blue) but warning level
# @arg $1 message:String the message to display
Log::displayStatus() {
  local type="${2:-STATUS}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    echo -e "${__INFO_COLOR}${type}  - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logStatus "$1" "${type}"
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if
        ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null ||
          ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null
      then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi

  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf '%*s\n' "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo)}" '' | tr ' ' "${character}"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description compare 2 version numbers
# @arg $1 version1:String version 1
# @arg $2 version2:String version 2
# @exitcode 0 if equal
# @exitcode 1 if version1 > version2
# @exitcode 2 else
Version::compare() {
  if [[ "$1" = "$2" ]]; then
    return 0
  fi
  local IFS=.
  # shellcheck disable=2206
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i = 0; i < ${#ver1[@]}; i++)); do
    if [[ -z "${ver2[i]+unset}" ]] || [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}

# @description filter to keep only version number from a string
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
Version::parse() {
  sed -En 's/[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p' "$@" | head -n1
}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
# @stderr diagnostic information + help if second argument is provided
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  [[ -t 1 || -t 2 ]]
}

# @description Load the nearest config file
# in next example will search first .framework-config file in "srcDir1"
# then if not found will go in up directories until /
# then will search in "srcDir2"
# then if not found will go in up directories until /
# source the file if found
# @example
#   Conf::loadNearestFile ".framework-config" "srcDir1" "srcDir2"
#
# @arg $1 configFileName:String config file name to search
# @arg $2 loadedFile:String (passed by reference) will return the loaded config file name
# @arg $@ srcDirs:String[] source directories in which the config file will be searched
# @exitcode 0 if file found
# @exitcode 1 if file not found
Conf::loadNearestFile() {
  local configFileName="$1"
  local -n loadedFile="$2"
  shift 2 || true
  local -a srcDirs=("$@")
  for srcDir in "${srcDirs[@]}"; do
    configFile="$(File::upFind "${srcDir}" "${configFileName}" || true)"
    if [[ -n "${configFile}" ]]; then
      # shellcheck source=/.framework-config
      source "${configFile}" || Log::fatal "error while loading config file '${configFile}'"
      Log::displayDebug "Config file ${configFile} is loaded"
      # shellcheck disable=SC2034
      loadedFile="${configFile}"
      return 0
    fi
  done

  Log::displayWarning "Config file '${configFileName}' not found in any source directories provided"
  return 1
}

# @description get list of env files to load
# in order to make them available for Env::requireLoad
# @env BASH_FRAMEWORK_ENV_FILES String[] list of env files that should be loaded
# @exitcode 1 if one of the env file cannot be generated
# @exitcode 2 if one of the env file is not a file or readable
# @stdout the env files asked to be loaded
# @stderr diagnostic information on failure
# @see https://github.com/fchastanet/bash-tools-framework/blob/master/FrameworkDoc.md#config_file_order
Env::getOrderedConfFiles() {
  local -a configFiles=()

  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi

  local defaultEnvFile
  defaultEnvFile="$(Env::createDefaultEnvFile)" || return 1
  configFiles+=("${defaultEnvFile}")

  local file
  for file in "${configFiles[@]}"; do
    if [[ ! -f "${file}" || ! -r "${file}" ]]; then
      Log::displayError "One of the config file is not available '${file}'"
      return 2
    fi
    echo "${file}"
  done
}

# @description merge and load conf files specified as argument
# - files are cleaned from ay comment
# - missing quotes after property = sign are added automatically
# - automatic remove of all whitespace before and after declarations
# - bash arrays are not supported
# - if a variable is declared in first file and overridden later on
#   in the same file or in subsequent files, those overloads will be
#   ignored
# @warning if an error occurs while loading one of the config file, exit code 3 but environment could be partially loaded
# @arg $@ args:String[] list of configuration files to load in order
# @set envVars String will set in environment all the variables that have been declared in the config files
# @env envVars String the env variables of the current script could be used to interpret variables during config files parsing
# @exitcode 0 if no config files provided or load completed successfully
# @exitcode 1 if error occurred during parsing the config files (file not found, grep, awk or sed error)
# @exitcode 2 if temporary file cannot be created
# @exitcode 3 if an error occurred during config file sourcing
# @stderr diagnostics information is displayed
# @see largely inspired but modified from https://opensource.com/article/21/5/processing-configuration-files-shell
Env::mergeConfFiles() {
  local -a configFileList=("$@")

  if ((${#configFileList[@]} == 0)); then
    return 0
  fi

  local combinedConfigFile
  combinedConfigFile="$(Framework::createTempFile "mergeConfFiles")" || return 2

  (
    # removes any trailing whitespace from each file, if any
    # this is absolutely required when importing into ConfigMaps
    # put quotes around values
    sed -E -e $'s/\s*$// ; /^$/d ; /^#.*$/d ; s/=([^"\'].*)$/="\\1"/' "${configFileList[@]}" |
      # remove all comment lines
      Filters::commentLines |
      # iterates over each file and prints (default awk behavior)
      # each unique line; only takes first value and ignores duplicates
      awk -F= '!line[$1]++'
  ) >"${combinedConfigFile}" || return 1

  # have to export everything, and source it twice:
  # 1) first source is to realize variables
  # 2) second time is to realize references
  set -o allexport
  # shellcheck source=.framework-config
  source "${combinedConfigFile}" || return 3
  # shellcheck source=.framework-config
  source "${combinedConfigFile}" || return 3
  set +o allexport
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description remove ansi codes from input or files given as argument
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# @see https://en.wikipedia.org/wiki/ANSI_escape_code
# shellcheck disable=SC2120
Filters::removeAnsiCodes() {
  # cspell:disable
  sed -E 's/\x1b\[[0-9;]*[mGKHF]//g' "$@"
  # cspell:enable
}

# @description github repository eg: kubernetes-sigs/kind
# @arg $1 githubUrl:String eg: https://github.com/kubernetes-sigs/kind/releases/download/@latestVersion@/kind-linux-amd64
# @exitcode 1 if no matching repo found in provided url, 0 otherwise
# @stdout the repo in the form owner/repo
Github::extractRepoFromGithubUrl() {
  local githubUrl="$1"
  local result
  result="$(sed -n -E 's#^https://github.com/([^/]+/[^/]+)/.*$#\1#p' <<<"${githubUrl}")"
  if [[ -z "${result}" ]]; then
    return 1
  fi
  echo "${result}"
}

# @description Retrieve the latest version number of a github release using Github API using retry
# repo arg with fchastanet/bash-tools value would match https://github.com/fchastanet/bash-tools
# @arg $1 repo:String repository in the format fchastanet/bash-tools
# @arg $2 resultRef:&String reference to a variable that will contain the result of the command
# @stdout log messages about retry
Github::getLatestRelease() {
  local repo="$1"
  # we need to pass the result through a reference instead of output directly
  # because retry can output too
  local -n resultRef=$2
  resultRef=""
  local resultFile
  resultFile="$(mktemp -p "${TMPDIR:-/tmp}" -t githubLatestRelease.XXXX)"
  # Get latest release from GitHub api
  if Retry::default curl \
    -L \
    -o "${resultFile}" \
    --fail \
    --silent \
    "https://api.github.com/repos/${repo}/releases/latest"; then
    # shellcheck disable=SC2034
    resultRef="$(Version::githubApiExtractVersion <"${resultFile}")"
    return 0
  fi
  # display curl result in case of failure
  cat >&2 "${resultFile}"
  rm -f "${resultFile}"
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logStatus() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-STATUS}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displaySkipped "Log file ${file} doesn't exist yet"
    return 0
  fi
  for i in $(seq $((maxLogFilesCount - 1)) -1 1); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
Retry::default() {
  Retry::parameterized 5 15 "" "$@"
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @exitcode 0 always successful
UI::requireTheme() {
  UI::theme "${BASH_FRAMEWORK_THEME-default}"
}

# @description default env file with all default values
# @stdout the default env filepath
Env::createDefaultEnvFile() {
  local envFile
  envFile="$(Framework::createTempFile "createDefaultEnvFileEnvFile")" || return 2

  (
    echo "BASH_FRAMEWORK_THEME=${BASH_FRAMEWORK_THEME:-default}"
    echo "BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}"
    echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-${__LEVEL_WARNING}}"
    # shellcheck disable=SC2016
    echo 'BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-"${FRAMEWORK_ROOT_DIR}/logs/${SCRIPT_NAME}.log"}"'
    echo "BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION=${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
  ) >"${envFile}"
  echo "${envFile}"
}

# @description search a file in parent directories
#
# @arg $1 fromPath:String path
# @arg $2 fileName:String
# @arg $3 untilInclusivePath:String (optional) find for given file until reaching this folder (default value: /)
# @arg $@ untilInclusivePaths:String[] list of untilInclusivePath
# @stdout The filename if found
# @exitcode 1 if the command failed or file not found
File::upFind() {
  local fromPath="$1"
  shift || true
  local fileName="$1"
  shift || true
  local untilInclusivePath="${1:-/}"
  shift || true

  if [[ -f "${fromPath}" ]]; then
    fromPath="$(dirname "${fromPath}")"
  fi
  while true; do
    if [[ -f "${fromPath}/${fileName}" ]]; then
      echo "${fromPath}/${fileName}"
      return 0
    fi
    if Array::contains "${fromPath}" "${untilInclusivePath}" "$@" "/"; then
      return 1
    fi
    fromPath="$(readlink -f "${fromPath}"/..)"
  done
  return 1
}

# @description remove comment lines from input or files provided as arguments
# @arg $@ files:String[] (optional) the files to filter
# @env commentLinePrefix String the comment line prefix (default value: #)
# @exitcode 0 if lines filtered or not
# @exitcode 2 if grep fails for any other reasons than not found
# @stdin the file as stdin to filter (alternative to files argument)
# @stdout the filtered lines
# shellcheck disable=SC2120
Filters::commentLines() {
  grep -vxE "[[:blank:]]*(${commentLinePrefix:-#}.*)?" "$@" || test $? = 1
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayWarning "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}

# @description extract version number from github api
# @noargs
# @stdin json result of github API
# @exitcode 1 if jq or Version::parse fails
# @stdout the version parsed
# @require Linux::requireJqCommand
Version::githubApiExtractVersion() {
  jq -r ".tag_name" | Version::parse
}

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description ensure command jq is available
# @exitcode 1 if jq command not available
# @stderr diagnostics information is displayed
Linux::requireJqCommand() {
  Assert::commandExists jq
}

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# FUNCTIONS

facade_main_upgradeGithubReleasesh() {
BASH_TOOLS_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
if [[ -d "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework/" ]]; then
  FRAMEWORK_ROOT_DIR="$(cd "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
else
  # if the directory does not exist yet, give a value to FRAMEWORK_ROOT_DIR
  FRAMEWORK_ROOT_DIR="${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework"
fi
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

if [[ -f "${HOME}/.bash-tools/.env" ]]; then
  export BASH_FRAMEWORK_ENV_FILES=("${HOME}/.bash-tools/.env")
fi
# REQUIRES
Env::requireLoad
UI::requireTheme
Log::requireLoad
Linux::requireJqCommand
Compiler::Facade::requireCommandBinDir

# @require Compiler::Facade::requireCommandBinDir
# shellcheck disable=SC2034

# default
declare defaultVersionArg="--version"

# option values
declare targetFileArg=""
declare githubUrlPatternArg=""
declare optionVersionArg="${defaultVersionArg}"
declare optionCurrentVersion=""
declare optionMinimalVersion=""
declare optionExactVersion=""

# other values
declare copyrightBeginYear="2020"

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now François Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  upgradeGithubReleaseCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 2.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERROR | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_LOG_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  BASH_FRAMEWORK_LOG_FILE="${logFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  BASH_FRAMEWORK_QUIET_MODE=1
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP='^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$'
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="^bin/|^\.framework-config$|^build.sh$|\.tpl$|/testsData/|^manualTests/|\.bats$"
# Source directories
FRAMEWORK_SRC_DIRS=(
  "${FRAMEWORK_ROOT_DIR}/src"
)

# export here all the variables that will be used in your templates
export REPOSITORY_URL="https://github.com/fchastanet/bash-tools-framework"
EOF
)"

commandOptionParseFinished() {
  if [[ -z "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    BASH_FRAMEWORK_ENV_FILES=()
  fi
  BASH_FRAMEWORK_ENV_FILES+=("${optionEnvFiles[@]}")
  export BASH_FRAMEWORK_ENV_FILES
  Env::requireLoad
  Log::requireLoad

  # load .framework-config
  if [[ -n "${optionBashFrameworkConfig}" && -f "${optionBashFrameworkConfig}" ]]; then
    BASH_FRAMEWORK_CONFIG_FILE="${optionBashFrameworkConfig}"
    # shellcheck source=/.framework-config
    source "${optionBashFrameworkConfig}" ||
      Log::fatal "Command ${SCRIPT_NAME} - error while loading specific .framework-config file: ${optionBashFrameworkConfig}"
  else
    # shellcheck disable=SC2034
    BASH_FRAMEWORK_CONFIG_FILE=""
    # shellcheck source=/.framework-config
    Framework::loadConfig BASH_FRAMEWORK_CONFIG_FILE "${FRAMEWORK_ROOT_DIR}" || {
      # load default template framework config
      if [[ ! -f "${PERSISTENT_TMPDIR}/.framework-config" ]]; then
        echo "${defaultFrameworkConfig}" > "${PERSISTENT_TMPDIR}/.framework-config"
      fi
      Framework::loadConfig BASH_FRAMEWORK_CONFIG_FILE "${PERSISTENT_TMPDIR}" || {
        Log::fatal "Command ${SCRIPT_NAME} - error while loading .framework-config.default file"
      }
      Log::displayWarning "Command ${SCRIPT_NAME} - Load default .framework-config file - ${PERSISTENT_TMPDIR}/.framework-config"
    }
  fi

  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

upgradeGithubReleaseCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    optionVersionArg="--version"
    local -i options_parse_optionParsedCountOptionVersionArg
    ((options_parse_optionParsedCountOptionVersionArg = 0)) || true
    local -i options_parse_optionParsedCountOptionCurrentVersion
    ((options_parse_optionParsedCountOptionCurrentVersion = 0)) || true
    local -i options_parse_optionParsedCountOptionExactVersion
    ((options_parse_optionParsedCountOptionExactVersion = 0)) || true
    local -i options_parse_optionParsedCountOptionMinimalVersion
    ((options_parse_optionParsedCountOptionMinimalVersion = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    local -i options_parse_argParsedCountTargetFileArg
    ((options_parse_argParsedCountTargetFileArg = 0)) || true
    local -i options_parse_argParsedCountGithubUrlPatternArg
    ((options_parse_argParsedCountGithubUrlPatternArg = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/18
        # Option optionVersionArg --version-arg variableType String min 0 max 1 authorizedValues '' regexp ''
        --version-arg)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionVersionArg >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersionArg))
          # shellcheck disable=SC2034
          optionVersionArg="$1"
          ;;
        # Option 2/18
        # Option optionCurrentVersion --current-version|-c variableType String min 0 max 1 authorizedValues '' regexp ''
        --current-version | -c)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionCurrentVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionCurrentVersion))
          # shellcheck disable=SC2034
          optionCurrentVersion="$1"
          ;;
        # Option 3/18
        # Option optionExactVersion --exact-version|-e variableType String min 0 max 1 authorizedValues '' regexp ''
        --exact-version | -e)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionExactVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionExactVersion))
          # shellcheck disable=SC2034
          optionExactVersion="$1"
          ;;
        # Option 4/18
        # Option optionMinimalVersion --minimal-version|-m variableType String min 0 max 1 authorizedValues '' regexp ''
        --minimal-version | -m)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionMinimalVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionMinimalVersion))
          # shellcheck disable=SC2034
          optionMinimalVersion="$1"
          ;;
        # Option 5/18
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 6/18
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 7/18
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 8/18
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 9/18
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 10/18
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 11/18
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 12/18
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 13/18
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 14/18
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 15/18
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 16/18
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 17/18
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 18/18
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if ((0)); then
            # Technical if - never reached
            :
          # Argument 1/2
          # Argument targetFileArg min 1 max 1 authorizedValues '' regexp ''
          elif ((options_parse_parsedArgIndex >= 0 && options_parse_parsedArgIndex < 1)); then
            if ((options_parse_argParsedCountTargetFileArg >= 1)); then
              Log::displayError "Command ${SCRIPT_NAME} - Argument targetFile - Maximum number of argument occurrences reached(1)"
              return 1
            fi
            ((++options_parse_argParsedCountTargetFileArg))
            # shellcheck disable=SC2034
            targetFileArg="${options_parse_arg}"
            targetFileArgCallback "${targetFileArg}" -- "${@:2}"
          # Argument 2/2
          # Argument githubUrlPatternArg min 1 max 1 authorizedValues '' regexp ''
          elif ((options_parse_parsedArgIndex >= 1 && options_parse_parsedArgIndex < 2)); then
            if ((options_parse_argParsedCountGithubUrlPatternArg >= 1)); then
              Log::displayError "Command ${SCRIPT_NAME} - Argument githubUrlPattern - Maximum number of argument occurrences reached(1)"
              return 1
            fi
            ((++options_parse_argParsedCountGithubUrlPatternArg))
            # shellcheck disable=SC2034
            githubUrlPatternArg="${options_parse_arg}"
            githubUrlPatternArgCallback "${githubUrlPatternArg}" -- "${@:2}"
          else
            if [[ "${argOptDefaultBehavior}" = "0" ]]; then
              Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
              return 1
            fi
          fi
          ((++options_parse_parsedArgIndex))
          ;;
      esac
      shift || true
    done
    if ((options_parse_argParsedCountTargetFileArg < 1)); then
      Log::displayError "Command ${SCRIPT_NAME} - Argument 'targetFile' should be provided at least 1 time(s)"
      return 1
    fi
    if ((options_parse_argParsedCountGithubUrlPatternArg < 1)); then
      Log::displayError "Command ${SCRIPT_NAME} - Argument 'githubUrlPattern' should be provided at least 1 time(s)"
      return 1
    fi
    commandOptionParseFinished
    upgradeGithubReleaseCommandCallback
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    echo -e "$(Array::wrap " " 80 0 "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}" "retrieve latest binary release from github and install it")"
    echo

    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]" "[ARGUMENTS]")"
    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--version-arg <versionArg>]" "[--current-version|-c <currentVersion>]" "[--exact-version|-e <exactVersion>]" "[--minimal-version|-m <minimalVersion>]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}targetFile${__HELP_NORMAL} {single} (mandatory)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(the\ binary\ downloaded\ will\ e\ written\ to\ this\ file\ path.\ Ensure\ the\ path\ is\ writable.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}githubUrlPattern${__HELP_NORMAL} {single} (mandatory)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'the url pattern to use to download the binary, see examples below. \n @version@ is template variable that will be replaced by the latest \n version tag found on github.')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}VERSION MANAGEMENT:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--version-arg <versionArg>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'The argument that will be provided to the currently installed binary  to check the version of the software. \n This parameter is needed if \E[2;97m--minimal-version\E[0m argument is used and is  different than default value (\E[2;97m--version\E[0m).')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo '    Default value: --version'
    echo -e "  ${__HELP_OPTION_COLOR}--current-version${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-c <currentVersion>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'Sometimes the command to retrieve the version is complicated.  \n Some command needs you to parse json or other commands provides  multiple sub command versions. In this case you can provide the  version you currently have, see examples below.')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--exact-version${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-e <exactVersion>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'if provided and currently installed binary is not this \E[2;97mexactVersion\E[0m, \n This exact version of the binary will be installed.')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--minimal-version${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-m <minimalVersion>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'if provided and currently installed binary is below this \E[2;97mminimalVersion\E[0m, \n a new version of the binary will be installed. \n If this argument is not provided, the latest binary is unconditionally downloaded from github.')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ \(default\,\ default-force\ or\ noColor\)\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e """
[1;37mOPTIONS EXCEPTIONS:[0m

[2;97m--current-version[0m|[2;97m-c[0m and [2;97m--version-arg[0m are mutually exclusive,
you cannot use both argument at the same time.

[2;97m--exact-version[0m|[2;97m-e[0m and [2;97m--minimal-version[0m|[2;97m-m[0m are mutually exclusive,
you cannot use both argument at the same time.

[1;37mGITHUB TEMPLATE URLS EXAMPLES:[0m

Simple ones(Sometimes @version@ template variable has to be specified twice):
'https://github.com/hadolint/hadolint/releases/download/v@version@/hadolint-Linux-x86_64'
'https://github.com/koalaman/shellcheck/releases/download/v@version@/shellcheck-v@version@.linux.x86_64.tar.xz'
'https://github.com/sharkdp/fd/releases/download/v@version@/fd_@version@_amd64.deb'
'https://github.com/sharkdp/bat/releases/download/v@version@/bat_@version@_amd64.deb'
'https://github.com/kubernetes-sigs/kind/releases/download/v@version@/kind-linux-amd64'
'https://github.com/kubernetes/minikube/releases/download/v@version@/minikube-linux-amd64'
'https://github.com/plantuml/plantuml/releases/download/v@version@/plantuml-@version@.jar'
'https://github.com/Versent/saml2aws/releases/download/v@version@/saml2aws_@version@_linux_amd64.tar.gz'

If you want to add a condition on architecture(linux, windows, x86, 64/32 bits):
\"https://github.com/docker/compose/releases/download/v@version@/docker-compose-\$(uname -s | tr '[:upper:]' '[:lower:]')-\$(uname -m)\"
\"https://github.com/docker/docker-credential-helpers/releases/download/v@version@/docker-credential-wincred-v@version@.windows-\$(dpkg --print-architecture).exe\"
\"https://github.com/Blacksmoke16/oq/releases/download/v@version@/oq-v@version@-\$(uname -s)-\$(uname -m)\"

[1;37mCOMMAND EXAMPLES:[0m
Download docker-compose latest version
[2;97mupgradeGithubRelease /usr/local/bin/docker-compose \"https://github.com/docker/compose/releases/download/v@version@/docker-compose-\$(uname -s | tr '[:upper:]' '[:lower:]')-\$(uname -m)\"[0m

Download oq specific version
[2;97mupgradeGithubRelease /usr/local/bin/oq --exact-version 1.3.4 \"https://github.com/Blacksmoke16/oq/releases/download/v@version@/oq-v@version@-\$(uname -s)-\$(uname -m)\"[0m

Download oq specific version correctly retrieving the oq version and not the jq one
[2;97mupgradeGithubRelease /usr/local/bin/oq --exact-version 1.3.4 --version-arg '-V | grep oq:' \"https://github.com/Blacksmoke16/oq/releases/download/v@version@/oq-v@version@-\$(uname -s)-\$(uname -m)\"[0m"""
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '2.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[François Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-tools/tree/master/src/_binaries/Git/upgradeGithubRelease.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

upgradeGithubReleaseCommandCallback() {
  if [[ -n "${optionExactVersion}" && -n "${optionMinimalVersion}" ]]; then
    Log::fatal "--exact-version|-e and --minimal-version|-m are mutually exclusive, you cannot use both argument at the same time."
  fi
}

githubUrlPatternArgCallback() {
  if [[ ! "${githubUrlPatternArg}" =~ ^https://github.com/ ]]; then
    Log::fatal "Invalid githubUrlPattern ${githubUrlPatternArg} provided, it should begin with https://github.com/"
  fi
}

targetFileArgCallback() {
  if [[ "${targetFileArg:0:1}" != "/" ]]; then
    targetFileArg="$(pwd)/${targetFileArg}"
  fi
  if ! Assert::validPath "${targetFileArg}"; then
    Log::fatal "File ${targetFileArg} is not a valid path"
  fi
  if ! Assert::fileWritable "${targetFileArg}"; then
    Log::fatal "File ${targetFileArg} is not writable"
  fi
}

upgradeGithubReleaseCommand parse "${BASH_FRAMEWORK_ARGV[@]}"

run() {
  computeCurrentCommandVersion() {
    if [[ -n "${optionCurrentVersion}" ]]; then
      echo "${optionCurrentVersion}"
      return 0
    fi
    if [[ -n "${optionVersionArg}" ]]; then
      # need eval here to correctly interpret --version-arg '-V | grep oq:'
      eval "'${targetFileArg}' ${optionVersionArg} 2>&1" | Version::parse || return 3
    fi
  }

  # if minVersion arg provided, we have to compute current bin version
  local tryDownloadNewVersion=1
  if [[ -f "${targetFileArg}" ]]; then
    local commandVersion
    commandVersion="$(computeCurrentCommandVersion)"

    if [[ -n "${optionExactVersion}" ]]; then
      if Version::compare "${commandVersion}" "${optionExactVersion}"; then
        tryDownloadNewVersion=0
        Log::displayStatus "${targetFileArg} version is the exact required version ${optionExactVersion}"
      else
        Log::displayWarning "${targetFileArg} version ${commandVersion} is different than required version ${optionExactVersion}"
      fi
    else
      if [[ -n "${optionMinimalVersion}" ]]; then
        if ! Github::isReleaseVersionExist "$(echo "${githubUrlPatternArg}" | sed -E "s/@version@/${optionMinimalVersion}/g")"; then
          Log::displayError "Minimal version ${optionMinimalVersion} doesn't exist on github"
          return 5
        fi
        local versionCompare=0
        Version::compare "${commandVersion}" "${optionMinimalVersion}" || versionCompare=$?
        # do not try to down version if current version is greater or equal to min version
        if [[ "${versionCompare}" = "1" ]]; then
          local msg="${targetFileArg} version ${commandVersion} is greater than minimal version ${optionMinimalVersion}"
          # current version > min version
          optionExactVersion="$(Github::getLatestVersionFromUrl "${githubUrlPatternArg}")" || return 1
          versionCompare=0
          Version::compare "${commandVersion}" "${optionExactVersion}" || versionCompare=$?
          if [[ "${versionCompare}" = "2" ]]; then
            # current version < remote version
            Log::displayWarning "${msg} but new version ${optionExactVersion} is available on github"
          else
            Log::displayInfo "${msg}"
          fi
          return 0
        elif [[ "${versionCompare}" = "2" ]]; then
          # current version < min version
          Log::displayWarning "${targetFileArg} version ${commandVersion} is lesser than minimal version ${optionMinimalVersion}"
        else
          tryDownloadNewVersion=2 # need to check if a newer version exists
          Log::displayStatus "${targetFileArg} version is the required minimal version ${optionMinimalVersion}"
        fi
      else
        tryDownloadNewVersion="2"
      fi

      # check if a newer version is available
      if [[ "${tryDownloadNewVersion}" = "2" ]]; then
        Log::displayInfo "compute last remote version"
        optionExactVersion="$(Github::getLatestVersionFromUrl "${githubUrlPatternArg}")" || return 1
        versionCompare=0
        Version::compare "${commandVersion}" "${optionExactVersion}" || versionCompare=$?
        if [[ "${versionCompare}" = "1" ]]; then
          # current version > remote version, shouldn't happen
          tryDownloadNewVersion=0
          Log::displayWarning "${targetFileArg} version ${commandVersion} is greater than remote version ${optionExactVersion}"
        elif [[ "${versionCompare}" = "2" ]]; then
          # current version < remote version
          tryDownloadNewVersion=1
          Log::displayWarning "${targetFileArg} version ${optionCurrentVersion} is lesser than remote version ${optionExactVersion}"
        else
          tryDownloadNewVersion=0
          Log::displayStatus "${targetFileArg} version is the same as remote version ${optionExactVersion}"
        fi
      fi
    fi
  fi

  if [[ "${tryDownloadNewVersion}" = "0" ]]; then
    return 0
  fi

  # check if target file is writable
  Assert::fileWritable "${targetFileArg}"

  if [[ -z "${optionExactVersion}" ]]; then
    Log::displayInfo "compute last remote version"
    optionExactVersion="$(Github::getLatestVersionFromUrl "${githubUrlPatternArg}")" || return 1
    if [[ -z "${optionExactVersion}" ]]; then
      Log::displayError "${targetFileArg} latest version not found on github"
      return 5
    fi
  elif ! Github::isReleaseVersionExist "$(echo "${githubUrlPatternArg}" | sed -E "s/@version@/${optionExactVersion}/g")"; then
    Log::displayError "${targetFileArg} version ${optionExactVersion} doesn't exist on github"
    return 4
  fi

  local githubUrl
  githubUrl="$(echo "${githubUrlPatternArg}" | sed -E "s/@version@/${optionExactVersion}/g")"
  Log::displayInfo "Using url ${githubUrl}"

  newSoftware=$(Github::downloadReleaseVersion "${githubUrl}")
  Github::defaultInstall "${newSoftware}" "${targetFileArg}"
  Log::displayStatus "Version ${optionExactVersion} installed in ${targetFileArg}"
}

if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
  run &>/dev/null
else
  run
fi

}

facade_main_upgradeGithubReleasesh "$@"
