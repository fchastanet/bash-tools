#!/usr/bin/env bash
###############################################################################
# GENERATED FROM https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/Git/githubReleaseManager/githubReleaseManager-binary.yaml
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034



# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# if set, and job control is not active, the shell runs the last command
# of a pipeline not executed in the background in the current shell
# environment.
shopt -s lastpipe

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file
# matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
if [[ ! -d "${PERSISTENT_TMPDIR}" ]]; then
  mkdir -p "${PERSISTENT_TMPDIR}"
fi

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  local rc=$?
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
  exit "${rc}"
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM


SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="${REAL_SCRIPT_FILE%/*}"
fi
FRAMEWORK_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3


# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}


# @description concatenate each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if it can.
# - if an arg can be placed on current line it will be,
#   otherwise current line is printed and arg is added to the new
#   current line
# - Empty arg is interpreted as a new line.
# - Add \r to arg in order to force break line and avoid following
#   arg to be concatenated with current arg.
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap2() {
  local glue="${1-}"
  local -i glueLength="${#glue}"
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  shift || true
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  if (($# == 0)); then
    return 0
  fi

  printCurrentLine() {
    if ((isNewline == 0)) || ((previousLineEmpty == 1)); then
      echo
    fi
    ((isNewline = 1))
    echo -en "${indentStr}"
    ((currentLineLength = indentNextLine)) || true
  }
  appendToCurrentLine() {
    local text="$1"
    local -i length=$2
    ((currentLineLength += length)) || true
    ((isNewline = 0)) || true
    if [[ "${text: -1}" = $'\r' ]]; then
      text="${text:0:-1}"
      echo -en "${text%%+([[:blank:]])}"
      printCurrentLine
    else
      echo -en "${text%%+([[:blank:]])}"
    fi
  }

  (
    local currentLine
    local -i currentLineLength=0 isNewline=1 argLength=0
    local -a additionalLines
    local -i previousLineEmpty=0
    local arg=""

    while (($# > 0)); do
      arg="$1"
      shift || true

      # replace tab by 2 spaces
      arg="${arg//$'\t'/  }"
      # remove trailing spaces
      arg="${arg%[[:blank:]]}"
      if [[ "${arg}" = $'\n' || -z "${arg}" ]]; then
        printCurrentLine
        ((previousLineEmpty = 1))
        continue
      else
        if ((previousLineEmpty == 1)); then
          printCurrentLine
        fi
        ((previousLineEmpty = 0)) || true
      fi
      # convert eol to args
      mapfile -t additionalLines <<<"${arg}"
      if ((${#additionalLines[@]} > 1)); then
        set -- "${additionalLines[@]}" "$@"
        continue
      fi

      ((argLength = ${#arg})) || true

      # empty arg
      if ((argLength == 0)); then
        if ((isNewline == 0)); then
          # isNewline = 0 means currentLine is not empty
          printCurrentLine
        fi
        continue
      fi

      if ((isNewline == 0)); then
        glueLength="${#glue}"
      else
        glueLength="0"
      fi
      if ((currentLineLength + argLength + glueLength > maxLineLength)); then
        if ((argLength + glueLength > maxLineLength)); then
          # arg is too long to even fit on one line
          # we have to split the arg on current and next line
          local -i remainingLineLength
          ((remainingLineLength = maxLineLength - currentLineLength - glueLength))
          appendToCurrentLine "${glue:0:${glueLength}}${arg:0:${remainingLineLength}}" "$((glueLength + remainingLineLength))"
          printCurrentLine
          arg="${arg:${remainingLineLength}}"
          # remove leading spaces
          arg="${arg##[[:blank:]]}"

          set -- "${arg}" "$@"
        else
          # the arg can fit on next line
          printCurrentLine
          appendToCurrentLine "${arg}" "${argLength}"
        fi
      else
        appendToCurrentLine "${glue:0:${glueLength}}${arg}" "$((glueLength + argLength))"
      fi
    done
    if [[ "${currentLine}" != "" ]] && [[ ! "${currentLine}" =~ ^[\ \t]+$ ]]; then
      printCurrentLine
    fi
  ) | sed -E -e 's/[[:blank:]]+$//'
}


# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}


# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  tty -s
}


# @description ignore exit code 141 from simple command pipes
# @example use with:
#   local resultingStatus=0
#   local -a originalPipeStatus=()
#   cmd1 | cmd2 || Bash::handlePipelineFailure resultingStatus originalPipeStatus || true
#   [[ "${resultingStatus}" = "0" ]]
# @arg $1 resultingStatusCode:&int (passed by reference) (optional) resulting status code
# @arg $2 originalStatus:int[] (passed by reference) (optional) copy of original PIPESTATUS array
# @env PIPESTATUS assuming that this function is called like in the example provided
# @see https://unix.stackexchange.com/a/709880/582856
Bash::handlePipelineFailure() {
  local -a pipeStatusBackup=("${PIPESTATUS[@]}")
  local -n handlePipelineFailure_resultingStatusCode=$1
  local -n handlePipelineFailure_originalStatus=$2
  # shellcheck disable=SC2034
  handlePipelineFailure_originalStatus=("${pipeStatusBackup[@]}")
  handlePipelineFailure_resultingStatusCode=0
  local statusCode
  for statusCode in "${pipeStatusBackup[@]}"; do
    if ((statusCode == 141)); then
      return 0
    elif ((statusCode > 0)); then
      # shellcheck disable=SC2034
      handlePipelineFailure_resultingStatusCode="${statusCode}"
      break
    fi
  done
  return "${handlePipelineFailure_resultingStatusCode}"
}


read -r -d '\0' bashToolsDefaultConfigTemplate <<-EOM || true
##!/usr/bin/env bash
# shellcheck disable=SC2034

# Default settings
# you can override these settings by creating ${HOME}/.bash-tools/.env file

###
### DISPLAY Level
### minimum level of the messages that will be displayed on screen
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_DISPLAY_LEVEL=${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}

###
### DISPLAY duration
### 0: no duration is displayed on the messages
### 1: duration between previous message and current is displayed
### with the message
###
DISPLAY_DURATION=${DISPLAY_DURATION:0}

###
### Log to file
###
### all log messages will be redirected to log file specified
### this same path will be used inside and outside of the container
###
BASH_FRAMEWORK_LOG_FILE=${BASH_FRAMEWORK_LOG_FILE:-${BASH_TOOLS_ROOT_DIR}/logs/bash.log}

###
### LOG Level
### minimum level of the messages that will be logged into LOG_FILE
###
### 0: NO LOG
### 1: ERROR
### 2: WARNING
### 3: INFO
### 4: DEBUG
###
BASH_FRAMEWORK_LOG_LEVEL=${BASH_FRAMEWORK_LOG_LEVEL:-0}

# absolute directory containing db import sql dumps
DB_IMPORT_DUMP_DIR=${DB_IMPORT_DUMP_DIR:-${HOME}/.bash-tools/dbImportDumps}

# garbage collect all files for which modification is greater than eg: 30 days (+30)
# each time an existing file is used by dbImport/dbImportTable
# the file modification time is set to now
DB_IMPORT_GARBAGE_COLLECT_DAYS=${DB_IMPORT_GARBAGE_COLLECT_DAYS:-+30}

# absolute directory containing dbScripts used by dbScriptAllDatabases
SCRIPTS_FOLDER=${SCRIPTS_FOLDER:-${HOME}/.bash-tools/conf/dbScripts}

# -----------------------------------------------------
# AWS Parameters
# -----------------------------------------------------
S3_BASE_URL=${S3_BASE_URL:-}

# -----------------------------------------------------
# Postman Parameters
# -----------------------------------------------------
POSTMAN_API_KEY=
EOM

# @description loads ~/.bash-tools/.env if available
# if not creates it from a default template
# else check if new options need to be added
BashTools::Conf::requireLoad() {
  BASH_TOOLS_ROOT_DIR="$(cd "${CURRENT_DIR}/${RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR}" && pwd -P)"
  if [[ -d "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework/" ]]; then
    FRAMEWORK_ROOT_DIR="$(cd "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
  else
    # if the directory does not exist yet, give a value to FRAMEWORK_ROOT_DIR
    FRAMEWORK_ROOT_DIR="${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework"
  fi
  # shellcheck disable=SC2034
  FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
  # shellcheck disable=SC2034
  FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
  # shellcheck disable=SC2034
  FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

  if [[ -f "${HOME}/.bash-tools/.env" ]]; then
    # shellcheck disable=SC2034
    BASH_FRAMEWORK_ENV_FILES=("${HOME}/.bash-tools/.env")
  fi

  local envFile="${HOME}/.bash-tools/.env"
  if [[ ! -f "${envFile}" ]]; then
    mkdir -p "${HOME}/.bash-tools"
    (
      echo "#!/usr/bin/env bash"
      # shellcheck disable=SC2154
      echo "${bashToolsDefaultConfigTemplate}"
    ) >"${envFile}"
    Log::displayInfo "Configuration file '${envFile}' created"
  else
    if ! grep -q '^POSTMAN_API_KEY=' "${envFile}"; then
      (
        echo '# -----------------------------------------------------'
        echo '# Postman Parameters'
        echo '# -----------------------------------------------------'
        echo 'POSTMAN_API_KEY='
      ) >>"${envFile}"
    fi
  fi
  # shellcheck source=/conf/defaultEnv/.env
  source "${envFile}" || {
    Log::displayError "impossible to load '${envFile}'"
    exit 1
  }
}


# @description check if all requirements are satisfied
# to execute dbImport commands
Db::checkRequirements() {
  if [[ "${SKIP_REQUIREMENTS_CHECKS:-0}" = "1" ]]; then
    return 0
  fi
  local -i failures=0
  echo
  Assert::commandExists mysql "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists mysqlshow "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists mysqldump "sudo apt-get install -y mysql-client" || ((++failures))
  Assert::commandExists pv "sudo apt-get install -y pv" || ((++failures))
  Assert::commandExists gawk "sudo apt-get install -y gawk" || ((++failures))
  Assert::commandExists awk "sudo apt-get install -y gawk" || ((++failures))
  Version::checkMinimal "gawk" "--version" "5.0.1" || ((++failures))
  return "${failures}"
}


# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  export REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED=1

  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  local localFrameworkConfigFile
  localFrameworkConfigFile="$(pwd)/.framework-config"
  if [[ -f "${localFrameworkConfigFile}" ]]; then
    configFiles+=("${localFrameworkConfigFile}")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}


# @description create a temp file using default TMPDIR variable
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}


# @description clone the repository if not done yet, else pull it if no change in it
# @arg $1 dir:String directory in which repository is installed or will be cloned
# @arg $2 repo:String repository url
# @arg $3 cloneCallback:Function callback on successful clone
# @arg $4 pullCallback:Function callback on successful pull
# @env GIT_CLONE_OPTIONS:String additional options to pass to git clone command
# @env SUDO String allows to use custom sudo prefix command
# @exitcode 0 on successful pulling/cloning, 1 on failure
Git::cloneOrPullIfNoChanges() {
  local dir="$1"
  shift || true
  local repo="$1"
  shift || true
  local cloneCallback=${1:-}
  shift || true
  local pullCallback=${1:-}
  shift || true

  if [[ -d "${dir}/.git" ]]; then
    local exitCode=0
    Git::pullIfNoChanges "${dir}" || exitCode=$?
    if [[ "${exitCode}" =~ ^[245]$ ]]; then
      # changes detected or pull not applicable
      return 0
    elif [[ "${exitCode}" != "0" ]]; then
      return "${exitCode}"
    fi
    # shellcheck disable=SC2086
    if [[ "$(type -t ${pullCallback})" = "function" ]]; then
      ${pullCallback} "${dir}"
    fi
  else
    Log::displayInfo "cloning ${repo} ..."
    if ! ${SUDO:-} test -d "${dir%/*}"; then
      ${SUDO:-} mkdir -p "${dir%/*}"
    fi
    # shellcheck disable=SC2086,SC2248
    if ${SUDO:-} git clone ${GIT_CLONE_OPTIONS} --progress "$@" "${repo}" "${dir}"; then
      # shellcheck disable=SC2086
      if [[ "$(type -t ${cloneCallback})" = "function" ]]; then
        ${cloneCallback} "${dir}"
      fi
    else
      Log::displayError "Cloning '${repo}' on '${dir}' failed"
      return 1
    fi
  fi
}


# @description pull git directory only if no change has been detected
# @arg $1 dir:String the git directory to pull
# @exitcode 0 on successful pulling
# @exitcode 1 on any other failure
# @exitcode 2 changes detected, pull avoided
# @exitcode 3 not a git directory
# @exitcode 4 not able to update index
# @exitcode 5 not a branch, pull avoided
# @stderr diagnostics information is displayed
# @env SUDO String allows to use custom sudo prefix command
Git::pullIfNoChanges() {

  if [[ "${REQUIRE_FUNCTION_GIT_REQUIRE_GIT_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Git::requireGitCommand has not been loaded"
    exit 1
  fi

  local dir="$1"
  if [[ ! -d "${dir}/.git" ]]; then
    return 3
  fi
  (
    cd "${dir}" || return 3
    if ! ${SUDO:-} git update-index --refresh &>/dev/null; then
      Log::displayWarning "Impossible to update git index of '${dir}' - check if you have modified file"
      return 4
    fi
    if ! ${SUDO:-} git diff-index --quiet HEAD --; then
      Log::displayWarning "Pulling git repository '${dir}' avoided as changes detected"
      return 2
    fi
    if ! ${SUDO:-} git symbolic-ref -q HEAD; then
      Log::displayWarning "Pulling git repository '${dir}' avoided as you are not on a branch"
      return 5
    fi
    Log::displayInfo "Pull git repository '${dir}' as no changes detected"
    ${SUDO:-} git pull --progress
  )
}


# @description ensure command git is available
# @exitcode 1 if git command not available
# @stderr diagnostics information is displayed
Git::requireGitCommand() {
  export REQUIRE_FUNCTION_GIT_REQUIRE_GIT_COMMAND_LOADED=1

  Assert::commandExists git
}


# @description intermediate callback that is used by Github::upgradeRelease
# or Github::installRelease
# if installCallback is not set, it allows to:
#   - copy the downloaded file to the right target file
#   - and set the execution bit
# else
#   installCallback is called with newSoftware, targetFile, version arguments
# fi
# @warning do not use this function as callback for Github::upgradeRelease or Github::installRelease, as it would result to an infinite loop
# @arg $1 newSoftware:String the downloaded software file
# @arg $2 targetFile:String where we want to copy the file
# @arg $3 version:String the version that has been downloaded
# @arg $4 installCallback:Function (optional) the callback to call with 3 first arguments
# @env SUDO String allows to use custom sudo prefix command
# @exitcode * on failure
# @see Github::upgradeRelease
# @see Github::installRelease
# @internal
Github::defaultInstall() {
  local newSoftware="$1"
  local targetFile="$2"
  local version="$3"
  local installCallback=$4
  # shellcheck disable=SC2086
  if ! ${SUDO:-} test -d "${targetFile%/*}"; then
    ${SUDO:-} mkdir -p "${targetFile%/*}"
  fi
  if [[ "$(type -t "${installCallback}")" = "function" ]]; then
    ${installCallback} "${newSoftware}" "${targetFile}" "${version}"
  else
    ${SUDO:-} mv "${newSoftware}" "${targetFile}"
    ${SUDO:-} chmod +x "${targetFile}"
    hash -r
    ${SUDO:-} rm -f "${newSoftware}" || true
    Log::displaySuccess "Version ${version} installed in ${targetFile}"
  fi
}


# @description github repository eg: kubernetes-sigs/kind
# @arg $1 githubUrl:String eg: https://github.com/kubernetes-sigs/kind/releases/download/@latestVersion@/kind-linux-amd64
# @exitcode 1 if no matching repo found in provided url, 0 otherwise
# @stdout the repo in the form owner/repo
Github::extractRepoFromGithubUrl() {
  local githubUrl="$1"
  local result
  result="$(sed -n -E 's#^https://github.com/([^/]+/[^/]+)/.*$#\1#p' <<<"${githubUrl}")"
  if [[ -z "${result}" ]]; then
    return 1
  fi
  echo "${result}"
}


# @description check if specified release software version exists in github
# @arg $1 releaseUrl:String eg: https://github.com/kubernetes-sigs/kind/releases/download/v1.0.0/kind-linux-amd64
# @exitcode 1 on failure
# @exitcode 0 if release version exists
# @env CURL_CONNECT_TIMEOUT number of seconds before giving up host connection
Github::isReleaseVersionExist() {
  local releaseUrl="$1"

  curl \
    -L \
    --connect-timeout "${CURL_CONNECT_TIMEOUT:-5}" \
    -o /dev/null \
    --silent \
    --head \
    --fail \
    "${releaseUrl}"
}


# @description upgrade given binary to latest github release using retry
#
# downloadReleaseUrl argument : the placeholder @latestVersion@ will be replaced by the latest release version
# @arg $1 targetFile:String target binary file (eg: /usr/local/bin/kind)
# @arg $2 downloadReleaseUrl:String github release url (eg: https://github.com/kubernetes-sigs/kind/releases/download/@latestVersion@/kind-linux-amd64)
# @arg $3 softVersionArg:String parameter to add to existing command to compute current version
# @arg $4 softVersionCallback:Function function called to get software version (default: Version::getCommandVersionFromPlainText will call software with argument --version)
# @arg $5 installCallback:Function function called to install the file retrieved on github (default copy as is and set execution bit)
# @arg $6 softVersionCallback:Function function to call to filter the version retrieved from github (Default: Version::parse)
# @stdout log messages about retry, install, upgrade
# @env SOFT_VERSION_CALLBACK pass softVersionCallback by env variable instead of passing it by arg
# @env INSTALL_CALLBACK pass installCallback by env variable instead of passing it by arg
# @env CURL_CONNECT_TIMEOUT number of seconds before giving up host connection
# @env EXACT_VERSION if provided, retrieve exact version instead of the latest
Github::upgradeRelease() {
  local targetFile="$1"
  local downloadReleaseUrl="$2"
  local softVersionArg="${3:---version}"
  local softVersionCallback="${4:-${SOFT_VERSION_CALLBACK:-Version::getCommandVersionFromPlainText}}"
  # shellcheck disable=SC2034
  local installCallback="${5:-${INSTALL_CALLBACK:-}}"
  local parseGithubVersionCallback="${6:-${PARSE_VERSION_CALLBACK:-Version::parse}}"

  local repo
  repo="$(Github::extractRepoFromGithubUrl "${downloadReleaseUrl}")"
  local releasesUrl="https://api.github.com/repos/${repo}/releases/latest"

  # shellcheck disable=SC2317
  extractVersion() {
    Version::githubApiExtractVersion | "${parseGithubVersionCallback}"
  }
  FILTER_LAST_VERSION_CALLBACK=${FILTER_LAST_VERSION_CALLBACK:-extractVersion} \
    SOFT_VERSION_CALLBACK="${softVersionCallback}" \
    INSTALL_CALLBACK="${installCallback}" \
    Web::upgradeRelease \
    "${targetFile}" \
    "${releasesUrl}" \
    "${downloadReleaseUrl}" \
    "${softVersionArg}" \
    "${EXACT_VERSION:-}"
}


# @description Get version of installed software
# @arg $1 newSoftware:String Name of the software
# @arg $2 versionArg:String Command to get version
# @exitcode 0:Success
InstallCallbacks::getVersion() {
  # local newSoftware="$1"
  local versionArg="$2"
  eval "${versionArg}" || {
    Log::displayError "Failed to get version"
    return 1
  }
}


# @description Install Debian package (with .deb extension)
# @arg $1 debFile:String
InstallCallbacks::installDeb() {
  local newSoftware="$1"
  Log::displayInfo "Installing Debian package ${newSoftware}"
  sudo dpkg -i "${newSoftware}"
  sudo rm -f "${newSoftware}"
}


# @description Install tar.gz file
# @arg $1 newSoftware:String Name of the software
# @arg $2 targetFileArg:String Target file
# @exitcode 0:Success
InstallCallbacks::installFromTarGz() {
  local newSoftware="$1"
  local targetFileArg="$2"
  Log::displayInfo "Installing ${newSoftware} to ${targetFileArg}"
  sudo tar xzvf "${newSoftware}" -C "${targetFileArg%/*}" "${targetFileArg##*/}"
  sudo chmod +x "${targetFileArg}"
  hash -r
  sudo rm -f "${newSoftware}"
}


# @description Install tar.xz file
# @arg $1 newSoftware:String Name of the software
# @arg $2 targetFileArg:String Target file
# @exitcode 0:Success
InstallCallbacks::installFromTarXz() {
  local newSoftware="$1"
  local targetFileArg="$2"

  Log::displayInfo "Installing ${newSoftware} to ${targetFileArg}"
  # Create temp directory
  local tempDir
  tempDir="$(mktemp -d)"

  # Extract to temp directory
  tar xvf "${newSoftware}" -C "${tempDir}"

  # Find and move file, ignoring directory structure
  sudo find "${tempDir}" -type f -name "${targetFileArg##*/}" -exec mv {} "${targetFileArg}" \;

  # Set permissions
  sudo chmod +x "${targetFileArg}"
  hash -r

  # Cleanup
  sudo rm -rf "${tempDir}" "${newSoftware}"
}


# @description apt-get install
# @arg $@ softwares:String[] list of softwares to install
# @feature Retry::default
# Linux::requireSudoCommand
# @stdout diagnostics logs
Linux::Apt::install() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireUbuntu has not been loaded"
    exit 1
  fi

  Log::displayInfo "Apt install $*"
  Retry::default sudo apt-get install -y -q "$@"
}


# @description retrieve linux distributor id
# @noargs
# @exitcode 1 if lsb_release fails or not found
# @stdout the linux distributor id
Linux::getDistributorId() {
  (
    source /etc/os-release
    echo "${ID}"
  )
}


# @description ensure command jq is available
# @exitcode 1 if jq command not available
# @stderr diagnostics information is displayed
Linux::requireJqCommand() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_JQ_COMMAND_LOADED=1

  if [[ "${SKIP_REQUIRE_JQ:-0}" = "0" && "${SKIP_REQUIRES:-0}" = "0" ]]; then
    Assert::commandExists jq
  fi
}


# @description ensure linux distribution is ubuntu
# @exitcode 1 if linux distribution is not ubuntu
Linux::requireUbuntu() {
  export REQUIRE_FUNCTION_LINUX_REQUIRE_UBUNTU_LOADED=1

  if ! Array::contains "$(Linux::getDistributorId)" "ubuntu" "debian"; then
    Log::fatal "this script should be executed under Ubuntu or Debian OS"
  fi
}


# @description ensure command yq is available
# @exitcode 1 if yq command not available
# @stderr diagnostics information is displayed
Linux::requireYqCommand() {
  if [[ "${SKIP_REQUIRE_YQ:-0}" = "0" && "${SKIP_REQUIRES:-0}" = "0" ]]; then
    Assert::commandExists yq
  fi
}


declare -g FIRST_LOG_DATE LOG_LAST_LOG_DATE LOG_LAST_LOG_DATE_INIT LOG_LAST_DURATION_STR
FIRST_LOG_DATE="${EPOCHREALTIME/[^0-9]/}"
LOG_LAST_LOG_DATE="${FIRST_LOG_DATE}"
LOG_LAST_LOG_DATE_INIT=1
LOG_LAST_DURATION_STR=""

# @description compute duration since last call to this function
# the result is set in following env variables.
# in ss.sss (seconds followed by milliseconds precision 3 decimals)
# @noargs
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @set LOG_LAST_LOG_DATE_INIT int (default 1) set to 0 at first call, allows to detect reference log
# @set LOG_LAST_DURATION_STR String the last duration displayed
# @set LOG_LAST_LOG_DATE String the last log date that will be used to compute next diff
Log::computeDuration() {
  if ((${DISPLAY_DURATION:-0} == 1)); then
    local -i duration=0
    local -i delta=0
    local durationStr deltaStr
    local -i currentLogDate
    currentLogDate="${EPOCHREALTIME/[^0-9]/}"
    if ((LOG_LAST_LOG_DATE_INIT == 1)); then
      LOG_LAST_LOG_DATE_INIT=0
      LOG_LAST_DURATION_STR="Ref"
    else
      duration=$(((currentLogDate - FIRST_LOG_DATE) / 1000000))
      delta=$(((currentLogDate - LOG_LAST_LOG_DATE) / 1000000))
      if ((duration > 59)); then
        durationStr=$(date -ud "@${duration}" +'%H:%M:%S')
      else
        durationStr="${duration}s"
      fi
      if ((delta > 59)); then
        deltaStr=$(date -ud "@${delta}" +'%H:%M:%S')
      else
        deltaStr="${delta}s"
      fi
      LOG_LAST_DURATION_STR="${durationStr}/+${deltaStr}"
    fi
    LOG_LAST_LOG_DATE="${currentLogDate}"
    # shellcheck disable=SC2034
    local microSeconds="${EPOCHREALTIME#*.}"
    LOG_LAST_DURATION_STR="$(printf '%(%T)T.%03.0f\n' "${EPOCHSECONDS}" "${microSeconds:0:3}")(${LOG_LAST_DURATION_STR}) - "
  else
    # shellcheck disable=SC2034
    LOG_LAST_DURATION_STR=""
  fi
}


# @description Display message using debug color (gray)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    Log::computeDuration
    echo -e "${__DEBUG_COLOR}DEBUG   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}


# @description Display message using error color (red)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    Log::computeDuration
    echo -e "${__ERROR_COLOR}ERROR   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}


# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__INFO_COLOR}${type}    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}


# @description Display message using success color (bg green/fg white)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displaySuccess() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    Log::computeDuration
    echo -e "${__SUCCESS_COLOR}SUCCESS - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logSuccess "$1"
}


# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    Log::computeDuration
    echo -e "${__WARNING_COLOR}WARN    - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}


# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
# @env DISPLAY_DURATION int (default 0) if 1 display elapsed time information between 2 info logs
# @env LOG_CONTEXT String allows to contextualize the log
Log::fatal() {
  Log::computeDuration
  echo -e "${__ERROR_COLOR}FATAL   - ${LOG_CONTEXT:-}${LOG_LAST_DURATION_STR:-}${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}


# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
Log::logMessage() {

  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Log::requireLoad has not been loaded"
    exit 1
  fi

  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logSuccess() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SUCCESS}" "$1"
  fi
}


# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}


# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
Log::requireLoad() {
  export REQUIRE_FUNCTION_LOG_REQUIRE_LOAD_LOADED=1


  if [[ "${REQUIRE_FUNCTION_ENV_REQUIRE_LOAD_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Env::requireLoad has not been loaded"
    exit 1
  fi

  if [[ "${REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement UI::requireTheme has not been loaded"
    exit 1
  fi

  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if [[ ! -d "${BASH_FRAMEWORK_LOG_FILE%/*}" ]]; then
        if ! mkdir -p "${BASH_FRAMEWORK_LOG_FILE%/*}" 2>/dev/null; then
          BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
          echo -e "${__ERROR_COLOR}ERROR   - directory ${BASH_FRAMEWORK_LOG_FILE%/*} is not writable${__RESET_COLOR}" >&2
        fi
      elif ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null; then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}


# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displayDebug "Log file ${file} doesn't exist yet"
    return 0
  fi
  local i
  for ((i = maxLogFilesCount - 1; i > 0; i--)); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}


# @description Retry a command 5 times with a delay of 15 seconds between each attempt
# @arg $@ command:String[] the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @env RETRY_MAX_RETRY int max retries
# @env RETRY_DELAY_BETWEEN_RETRIES int delay between attempts
Retry::default() {
  Retry::parameterized "${RETRY_MAX_RETRY:-5}" "${RETRY_DELAY_BETWEEN_RETRIES:-15}" "" "$@"
}


# @description Retry a command several times depending on parameters
# @arg $1 maxRetries:int    $1 max retries
# @arg $2 delay:int between attempt
# @arg $3 message:String to display to describe the attempt
# @arg $@ rest of parameters, the command to run
# @exitcode 0 on success
# @exitcode 1 if max retries count reached
# @exitcode 2 if maxRetries invalid value
Retry::parameterized() {
  local maxRetries=$1
  shift || true
  local delayBetweenTries=$1
  shift || true
  local message="$1"
  shift || true
  local retriesCount=1
  if [[ "${maxRetries}" -lt 1 ]]; then
    Log::displayError "invalid maxRetry value"
    return 2
  fi

  while true; do
    Log::displayInfo "Attempt ${retriesCount}/${maxRetries}: ${message}"
    if "$@"; then
      break
    elif [[ "${retriesCount}" -lt "${maxRetries}" ]]; then
      Log::displayDebug "Command failed. Wait for ${delayBetweenTries} seconds"
      ((retriesCount++))
      sleep "${delayBetweenTries}"
    else
      Log::displayError "The command has failed after ${retriesCount} attempts."
      return 1
    fi
  done
  return 0
}


# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  local -i width=${COLUMNS:-0}
  if ((width == 0)) && [[ -t 1 ]]; then
    width=$(tput cols)
  fi
  if ((width == 0)); then
    width=80
  fi
  printf -- "${character}%.0s" $(seq "${COLUMNS:-$([[ -t 1 ]] && tput cols || echo '80')}")
  echo
}


# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @env LOAD_THEME int 0 to avoid loading theme
# @exitcode 0 always successful
UI::requireTheme() {
  export REQUIRE_FUNCTION_UI_REQUIRE_THEME_LOADED=1

  if [[ "${LOAD_THEME:-1}" = "1" ]]; then
    UI::theme "${BASH_FRAMEWORK_THEME-default}"
  fi
}


# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Gray
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}


# @description Check that command version is greater than expected minimal version
# display warning if command version greater than expected minimal version
# display error if command version less than expected minimal version and exit 1
# @arg $1 commandName:String command path
# @arg $2 argVersion:String command line parameters to launch to get command version
# @arg $3 minimalVersion:String expected minimal command version
# @arg $4 parseVersionCallback:Function
# @arg $5 help:String optional help message to display if command does not exist
# @exitcode 0 if command version greater or equal to expected minimal version
# @exitcode 1 if command version less than expected minimal version
# @exitcode 2 if command does not exist
Version::checkMinimal() {
  local commandName="$1"
  local argVersion="$2"
  local minimalVersion="$3"
  local parseVersionCallback=${4:-Version::parse}
  local help="${5:-}"

  Assert::commandExists "${commandName}" "${help}" || return 2

  # shellcheck disable=SC2034
  local status=0
  # shellcheck disable=SC2034
  local -a pipeStatus=()
  local version
  version="$("${commandName}" "${argVersion}" 2>&1 | ${parseVersionCallback} || Bash::handlePipelineFailure status pipeStatus)"

  Log::displayDebug "check ${commandName} version ${version} against minimal ${minimalVersion}"

  local result=0
  Version::compare "${version}" "${minimalVersion}" || result=$?
  case "${result}" in
    1)
      Log::displayInfo "${commandName} version is ${version} greater than ${minimalVersion}"
      ;;
    2)
      Log::displayError "${commandName} minimal version is ${minimalVersion}, your version is ${version}"
      return 1
      ;;
    *)
      Log::displaySuccess "${commandName} version is matching exactly the expected minimal version ${version}"
      ;;
  esac
}


# @description compare 2 version numbers
# @arg $1 version1:String version 1
# @arg $2 version2:String version 2
# @exitcode 0 if equal
# @exitcode 1 if version1 > version2
# @exitcode 2 else
Version::compare() {
  if [[ "$1" = "$2" ]]; then
    return 0
  fi
  local IFS=.
  # shellcheck disable=2206
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i = 0; i < ${#ver1[@]}; i++)); do
    if [[ -z "${ver2[i]+unset}" ]] || [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}


# @description extract software version number
# @arg $1 command:String the command that will be called with --version parameter
# @arg $2 argVersion:String  allows to override default --version parameter
Version::getCommandVersionFromPlainText() {
  local command="$1"
  local argVersion="${2:---version}"
  "${command}" "${argVersion}" 2>&1 |
    Version::parse # keep only version numbers
}


# @description extract version number from github api
# @noargs
# @stdin json result of github API
# @exitcode 1 if jq or Version::parse fails
# @stdout the version parsed
Version::githubApiExtractVersion() {

  if [[ "${REQUIRE_FUNCTION_LINUX_REQUIRE_JQ_COMMAND_LOADED:-0}" != 1 ]]; then
    echo >&2 "Requirement Linux::requireJqCommand has not been loaded"
    exit 1
  fi

  jq -r ".tag_name"
}


# @description filter to keep only version number from a string
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
Version::parse() {
  # match anything, print(p), exit on first match(Q)
  sed -En \
    -e 's/\x1b\[[0-9;]*[mGKHF]//g' \
    -e 's/[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/' \
    -e '//{p;Q}' \
    "$@"
}


# @description Retrieve the latest version number of a web release
# @arg $1 releaseListUrl:String the url from which version list can be retrieved
# @stdout log messages about retry
# @env CURL_CONNECT_TIMEOUT number of seconds before giving up host connection
Web::getReleases() {
  local releaseListUrl="$1"
  # Get latest release from GitHub api
  if command -v gh &>/dev/null && [[ -n "${GH_TOKEN}" ]]; then
    Log::displayDebug "Using gh to retrieve release versions list"
    Retry::parameterized "${RETRY_MAX_RETRY:-5}" \
      "${RETRY_DELAY_BETWEEN_RETRIES:-15}" \
      "Retrieving release versions list ..." \
      gh api "${releaseListUrl#https://github.com}"
  else
    if command -v gh &>/dev/null && [[ "${GH_WARNING_DISPLAYED:-0}" = "0" ]]; then
      Log::displayWarning "GH_TOKEN is not set, cannot use gh, using curl to retrieve release versions list"
      GH_WARNING_DISPLAYED=1
    fi
    Retry::parameterized "${RETRY_MAX_RETRY:-5}" \
      "${RETRY_DELAY_BETWEEN_RETRIES:-15}" \
      "Retrieving release versions list ..." \
      curl \
      -L \
      --connect-timeout "${CURL_CONNECT_TIMEOUT:-5}" \
      --fail \
      --silent \
      "${releaseListUrl}"
  fi
}


# @description upgrade given binary to latest release using retry
#
# releasesUrl argument : the placeholder @latestVersion@ will be replaced by the latest release version
# @arg $1 targetFile:String target binary file (eg: /usr/local/bin/kind)
# @arg $2 releasesUrl:String url on which we can query all available versions (eg: "https://go.dev/dl/?mode=json")
# @arg $3 downloadReleaseUrl:String url from which the software will be downloaded (eg: https://storage.googleapis.com/golang/go@latestVersion@.linux-amd64.tar.gz)
# @arg $4 softVersionArg:String parameter to add to existing command to compute current version
# @arg $5 exactVersion:String if you want to retrieve a specific version instead of the latest
# @stdout log messages about retry, install, upgrade
# @env FILTER_LAST_VERSION_CALLBACK a callback to filter the latest version from releasesUrl
# @env SOFT_VERSION_CALLBACK a callback to execute command version
# @env PARSE_VERSION_CALLBACK a callback to parse the version of the existing command
# @env INSTALL_CALLBACK a callback to install the software downloaded
# @env CURL_CONNECT_TIMEOUT number of seconds before giving up host connection
# @env VERSION_PLACEHOLDER a placeholder to replace in downloadReleaseUrl (default: @latestVersion@)
Web::upgradeRelease() {
  local targetFile="$1"
  local releasesUrl="$2"
  local downloadReleaseUrl="$3"
  local softVersionArg="${4:---version}"
  local exactVersion="${5:-}"
  # options from env variables
  local filterLastVersionCallback="${FILTER_LAST_VERSION_CALLBACK:-Version::parse}"
  local softVersionCallback="${SOFT_VERSION_CALLBACK:-Version::getCommandVersionFromPlainText}"
  local installCallback="${INSTALL_CALLBACK:-}"

  local currentVersion="not existing"
  if [[ -f "${targetFile}" ]]; then
    currentVersion="$(${softVersionCallback} "${targetFile}" "${softVersionArg}" 2>&1 || true)"
  fi
  if [[ -z "${exactVersion}" ]]; then
    local latestVersion
    latestVersion="$(Web::getReleases "${releasesUrl}" | ${filterLastVersionCallback})" || {
      Log::displayError "latest version not found on ${releasesUrl}"
      return 1
    }
    Log::displayInfo "Latest version found is ${latestVersion}"

    exactVersion="${latestVersion}"
  fi
  local url="${downloadReleaseUrl//${VERSION_PLACEHOLDER:-@latestVersion@}/${exactVersion}}"
  if [[ -n "${exactVersion}" ]] && ! Github::isReleaseVersionExist "${url}"; then
    Log::displayError "${targetFile} version ${exactVersion} doesn't exist on github"
    return 2
  fi
  Log::displayDebug "currentVersion: '${currentVersion}'"
  Log::displayDebug "exactVersion: '${exactVersion}'"
  if [[ "${currentVersion}" = "${exactVersion}" ]]; then
    Log::displayInfo "${targetFile} version ${exactVersion} already installed"
  else
    if [[ -z "${currentVersion}" ]]; then
      Log::displayInfo "Installing ${targetFile} with version ${exactVersion}"
    else
      Log::displayInfo "Upgrading ${targetFile} from version ${currentVersion} to ${exactVersion}"
    fi
    Log::displayInfo "Using url ${url}"
    newSoftware=$(mktemp -p "${TMPDIR:-/tmp}" -t web.newSoftware.XXXX)
    Retry::default curl \
      -L \
      --connect-timeout "${CURL_CONNECT_TIMEOUT:-5}" \
      -o "${newSoftware}" \
      --fail \
      "${url}"

    Github::defaultInstall "${newSoftware}" "${targetFile}" "${exactVersion}" "${installCallback}"
  fi
}
# FUNCTIONS

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

beforeParseCallback() {
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

copyrightCallback() {
  #
  # shellcheck disable=SC2155,SC2154,SC2250
  echo "Copyright (c) 2020-now François Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  Log::displayError "optionHelpCallback needs to be overridden"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}" >>"${overrideEnvFile}"
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERR | ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARN | WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERR | ERROR | WARN | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
      ;;
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  # shellcheck disable=SC2034
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  echo "BASH_FRAMEWORK_LOG_LEVEL=${logLevel}" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  echo "BASH_FRAMEWORK_LOG_FILE='${logFile}'" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  echo "BASH_FRAMEWORK_QUIET_MODE=1" >>"${overrideEnvFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'

# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-${REAL_SCRIPT_FILE%/*/*}}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/${0##*/}.log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"

EOF
)"

overrideEnvFile="$(Framework::createTempFile "overrideEnvFile")"

commandOptionParseFinished() {
  # load default template framework config
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" >"${defaultEnvFile}"
  local -a files=("${defaultEnvFile}")
  # shellcheck disable=SC2154
  if [[ -f "${optionBashFrameworkConfig}" ]]; then
    files+=("${optionBashFrameworkConfig}")
  fi
  files+=("${overrideEnvFile}")
  Env::requireLoad "${files[@]}"
  Log::requireLoad
  # shellcheck disable=SC2154
  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}



defaultBeforeParseCallback() {
  BashTools::Conf::requireLoad
  Env::requireLoad
  UI::requireTheme
  Log::requireLoad
}

beforeParseCallback() {
  defaultBeforeParseCallback
}



specificRequirements() {
  Linux::requireJqCommand
  Linux::requireYqCommand
  Git::requireGitCommand
}

longDescriptionFunction() {
  :
}

optionHelpCallback() {
  githubReleaseManagerCommandHelp
  exit 0
}

softwareIdsArgCallback() {
  # validate if strings provided are valid software ids
  :
}

validateSoftwareIds() {
  local configFile="$1"
  shift
  local softwareIds=("$@")
  local errors=0

  # Get all valid software IDs from config
  local validIds
  validIds="$(yq '.softwares[].id' "${configFile}")"

  for softwareId in "${softwareIds[@]}"; do
    if ! echo "${validIds}" | grep -q "^${softwareId}$"; then
      Log::displayError "Software ID '${softwareId}' not found in configuration file '${configFile}'"
      ((errors++))
    fi
  done

  return "${errors}"
}

validateYamlConfig() {
  local configFile="$1"
  local errors=0
  Log::displayInfo "Validating configuration file ${configFile}"

  # Check if softwares key exists and is an array
  if ! yq '.softwares | type' "${configFile}" | grep -q "!!seq"; then
    Log::displayError "Configuration file must have a 'softwares' array"
    ((errors++))
  fi

  # Validate each software entry
  while IFS= read -r index; do
    local prefix=".softwares[${index}]"

    local missingFields
    missingFields="$(yq eval "${prefix}"' | select( has("id") and has("url") and has("version") and has("targetFile") and has("versionArg") | not) | .id // "[unknown]"' "${configFile}")"
    if [[ "${missingFields}" != '[unknown]' ]]; then
      Log::displayError "Missing required fields in software ${index} entries: ${missingFields}"
      ((errors++))
    fi
  done < <(yq '.softwares | keys | .[]' "${configFile}")

  Log::displayInfo "Configuration file ${configFile} validation complete"
  return "${errors}"
}

configFileOptionCallback() {
  if [[ -z "${optionConfigFile}" || "${optionConfigFile}" = "<currentDir>/githubReleaseManager.yaml" ]]; then
    optionConfigFile="$(pwd)/githubReleaseManager.yaml"
  fi
  # shellcheck disable=SC2154
  if [[ ! -f "${optionConfigFile}" ]]; then
    Log::fatal "Configuration file ${optionConfigFile} does not exist"
  fi
  if [[ "${SKIP_YAML_CHECKS:-0}" = "1" ]]; then
    return
  fi
  if ! validateYamlConfig "${optionConfigFile}"; then
    Log::fatal "Configuration file ${optionConfigFile} is invalid"
  fi
  # shellcheck disable=SC2154
  if ! validateSoftwareIds "${optionConfigFile}" "${softwareIdsArg[@]}"; then
    Log::fatal "Invalid software ID(s) provided"
  fi
}



optionVersionCallback() {
  # shellcheck disable=SC2154
  echo "${SCRIPT_NAME} version 3.0"
  Db::checkRequirements
  exit 0
}


# ------------------------------------------
# Command githubReleaseManagerCommand
# ------------------------------------------

# options variables initialization
declare optionHelp="0"
declare optionConfig="0"
declare optionBashFrameworkConfig=""
declare optionInfoVerbose="0"
declare optionDebugVerbose="0"
declare optionTraceVerbose="0"
declare optionLogLevel=""
declare optionLogFile=""
declare optionDisplayLevel=""
declare optionNoColor="0"
declare optionTheme="default"
declare optionVersion="0"
declare optionQuiet="0"
declare optionConfigFile="<currentDir>/githubReleaseManager.yaml"
# arguments variables initialization
declare -a softwareIdsArg=()
# @description parse command options and arguments for githubReleaseManagerCommand
githubReleaseManagerCommandParse() {
  Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
  Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  optionHelp="0"
  local -i options_parse_optionParsedCountOptionHelp
  ((options_parse_optionParsedCountOptionHelp = 0)) || true
  optionConfig="0"
  local -i options_parse_optionParsedCountOptionConfig
  ((options_parse_optionParsedCountOptionConfig = 0)) || true
  optionBashFrameworkConfig=""
  local -i options_parse_optionParsedCountOptionBashFrameworkConfig
  ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
  optionInfoVerbose="0"
  local -i options_parse_optionParsedCountOptionInfoVerbose
  ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
  optionDebugVerbose="0"
  local -i options_parse_optionParsedCountOptionDebugVerbose
  ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
  optionTraceVerbose="0"
  local -i options_parse_optionParsedCountOptionTraceVerbose
  ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
  optionLogLevel=""
  local -i options_parse_optionParsedCountOptionLogLevel
  ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
  optionLogFile=""
  local -i options_parse_optionParsedCountOptionLogFile
  ((options_parse_optionParsedCountOptionLogFile = 0)) || true
  optionDisplayLevel=""
  local -i options_parse_optionParsedCountOptionDisplayLevel
  ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
  optionNoColor="0"
  local -i options_parse_optionParsedCountOptionNoColor
  ((options_parse_optionParsedCountOptionNoColor = 0)) || true
  optionTheme="default"
  local -i options_parse_optionParsedCountOptionTheme
  ((options_parse_optionParsedCountOptionTheme = 0)) || true
  optionVersion="0"
  local -i options_parse_optionParsedCountOptionVersion
  ((options_parse_optionParsedCountOptionVersion = 0)) || true
  optionQuiet="0"
  local -i options_parse_optionParsedCountOptionQuiet
  ((options_parse_optionParsedCountOptionQuiet = 0)) || true
  optionConfigFile="<currentDir>/githubReleaseManager.yaml"
  local -i options_parse_optionParsedCountOptionConfigFile
  ((options_parse_optionParsedCountOptionConfigFile = 0)) || true

  softwareIdsArg=()


  # shellcheck disable=SC2034
  local -i options_parse_parsedArgIndex=0
  while (($# > 0)); do
    local options_parse_arg="$1"
    local argOptDefaultBehavior=0
    case "${options_parse_arg}" in
      # Option 1/14
      # optionHelp alts --help|-h
      # type: Boolean min 0 max 1
      --help | -h)
        # shellcheck disable=SC2034
        optionHelp="1"

        if ((options_parse_optionParsedCountOptionHelp >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionHelp))
        optionHelpCallback "${options_parse_arg}" "${optionHelp}"

        ;;

      # Option 2/14
      # optionConfig alts --config
      # type: Boolean min 0 max 1
      --config)
        # shellcheck disable=SC2034
        optionConfig="1"

        if ((options_parse_optionParsedCountOptionConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfig))
        ;;

      # Option 3/14
      # optionBashFrameworkConfig alts --bash-framework-config
      # type: String min 0 max 1
      --bash-framework-config)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
        # shellcheck disable=SC2034
        optionBashFrameworkConfig="$1"
        optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"

        ;;

      # Option 4/14
      # optionInfoVerbose alts --verbose|-v
      # type: Boolean min 0 max 1
      --verbose | -v)
        # shellcheck disable=SC2034
        optionInfoVerbose="1"

        if ((options_parse_optionParsedCountOptionInfoVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionInfoVerbose))
        optionInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        updateArgListInfoVerboseCallback "${options_parse_arg}" "${optionInfoVerbose}"

        ;;

      # Option 5/14
      # optionDebugVerbose alts -vv
      # type: Boolean min 0 max 1
      -vv)
        # shellcheck disable=SC2034
        optionDebugVerbose="1"

        if ((options_parse_optionParsedCountOptionDebugVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDebugVerbose))
        optionDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        updateArgListDebugVerboseCallback "${options_parse_arg}" "${optionDebugVerbose}"

        ;;

      # Option 6/14
      # optionTraceVerbose alts -vvv
      # type: Boolean min 0 max 1
      -vvv)
        # shellcheck disable=SC2034
        optionTraceVerbose="1"

        if ((options_parse_optionParsedCountOptionTraceVerbose >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTraceVerbose))
        optionTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        updateArgListTraceVerboseCallback "${options_parse_arg}" "${optionTraceVerbose}"

        ;;

      # Option 7/14
      # optionLogLevel alts --log-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --log-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogLevel))
        # shellcheck disable=SC2034
        optionLogLevel="$1"
        optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"

        ;;

      # Option 8/14
      # optionLogFile alts --log-file
      # type: String min 0 max 1
      --log-file)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionLogFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionLogFile))
        # shellcheck disable=SC2034
        optionLogFile="$1"
        optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"

        ;;

      # Option 9/14
      # optionDisplayLevel alts --display-level
      # type: String min 0 max 1
      # authorizedValues: OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE
      --display-level)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ OFF|ERR|ERROR|WARN|WARNING|INFO|DEBUG|TRACE ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF, ERR, ERROR, WARN, WARNING, INFO, DEBUG, TRACE)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionDisplayLevel >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionDisplayLevel))
        # shellcheck disable=SC2034
        optionDisplayLevel="$1"
        optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"

        ;;

      # Option 10/14
      # optionNoColor alts --no-color
      # type: Boolean min 0 max 1
      --no-color)
        # shellcheck disable=SC2034
        optionNoColor="1"

        if ((options_parse_optionParsedCountOptionNoColor >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionNoColor))
        optionNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        updateArgListNoColorCallback "${options_parse_arg}" "${optionNoColor}"

        ;;

      # Option 11/14
      # optionTheme alts --theme
      # type: String min 0 max 1
      # authorizedValues: default|default-force|noColor
      --theme)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi
        if [[ ! "$1" =~ default|default-force|noColor ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default, default-force, noColor)"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionTheme >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionTheme))
        # shellcheck disable=SC2034
        optionTheme="$1"
        optionThemeCallback "${options_parse_arg}" "${optionTheme}"

        updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"

        ;;

      # Option 12/14
      # optionVersion alts --version
      # type: Boolean min 0 max 1
      --version)
        # shellcheck disable=SC2034
        optionVersion="1"

        if ((options_parse_optionParsedCountOptionVersion >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionVersion))
        optionVersionCallback "${options_parse_arg}" "${optionVersion}"

        ;;

      # Option 13/14
      # optionQuiet alts --quiet|-q
      # type: Boolean min 0 max 1
      --quiet | -q)
        # shellcheck disable=SC2034
        optionQuiet="1"

        if ((options_parse_optionParsedCountOptionQuiet >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionQuiet))
        optionQuietCallback "${options_parse_arg}" "${optionQuiet}"

        updateArgListQuietCallback "${options_parse_arg}" "${optionQuiet}"

        ;;

      # Option 14/14
      # optionConfigFile alts --config-file|-c
      # type: String min 0 max 1
      --config-file | -c)
        shift
        if (($# == 0)); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
          return 1
        fi

        if ((options_parse_optionParsedCountOptionConfigFile >= 1 )); then
          Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
          return 1
        fi
        ((++options_parse_optionParsedCountOptionConfigFile))
        # shellcheck disable=SC2034
        optionConfigFile="$1"
        ;;

      -*)
        if [[ "${argOptDefaultBehavior}" = "0" ]]; then
          Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
          return 1
        fi
        ;;
      *)
        ((minParsedArgIndex0 = 0)) || true
        ((maxParsedArgIndex0 = 0)) || true
        ((minParsedArgIndex1 = minParsedArgIndex0 + 0)) || true
        ((maxParsedArgIndex1 = maxParsedArgIndex0)) || true
        ((incrementArg = 1 ))
        if ((0)); then
          # Technical if - never reached
          :

        # Argument 1/1 - softwareIdsArg
        # Argument softwareIdsArg min 0 max -1
        elif (( options_parse_parsedArgIndex >= minParsedArgIndex0 )); then
          ((++options_parse_argParsedCountSoftwareIdsArg))
          # shellcheck disable=SC2034
          # shellcheck disable=SC2034
          softwareIdsArg+=("${options_parse_arg}")
          softwareIdsArgCallback "${softwareIdsArg[@]}" -- "${@:2}"


        # else too much args
        else


          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            # too much args and no unknownArgumentCallbacks configured
            Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
            return 1
          fi

        fi
        if ((incrementArg == 1)); then
          ((++options_parse_parsedArgIndex))
        fi
        ;;
    esac
    shift || true
  done || return $?


  commandOptionParseFinished
  configFileOptionCallback

}

# @description display command options and arguments help for githubReleaseManagerCommand
githubReleaseManagerCommandHelp() {
  echo -e "${__HELP_TITLE_COLOR}SYNOPSIS:${__RESET_COLOR}"
  Array::wrap2 ' ' 76 4 "    " "Retrieve latest binary release from github and install it."
  echo
  echo

  # ------------------------------------------
  # usage section
  # ------------------------------------------
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "githubReleaseManager [OPTIONS] [ARGUMENTS]"
  echo
  # ------------------------------------------
  # usage/options section
  # ------------------------------------------
  optionsAltList=("[--help|-h]" "[--config]" "[--bash-framework-config <bash-framework-config>]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--log-level <log-level>]" "[--log-file <log-file>]" "[--display-level <display-level>]" "[--no-color]" "[--theme <theme>]" "[--version]" "[--quiet|-q]" "[--config-file|-c <configFile>]"
  )
  Array::wrap2 " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
    "githubReleaseManager" "${optionsAltList[@]}"
  echo

  # ------------------------------------------
  # usage/arguments section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"

  Array::wrap2 " " 80 2 "  [${__HELP_OPTION_COLOR}softwareId${__HELP_NORMAL} {list} (optional)]"
  Array::wrap2 ' ' 76 4 "    " "The specific software ids to install." "If not provided, all the softwares specified in configuration" "file will be installed." ""
  echo


  # ------------------------------------------
  # options section
  # ------------------------------------------
  echo
  echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays this command help"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Displays configuration"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <bash-framework-config>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Use alternate bash framework configuration."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Info level verbose mode (alias of --display-level INFO)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Debug level verbose mode (alias of --display-level DEBUG)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Trace level verbose mode (alias of --display-level TRACE)"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--log-level <log-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  echo -e "  ${__HELP_OPTION_COLOR}--log-file <log-file>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set log file"
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--display-level <display-level>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Set display level"
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}OFF${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}ERROR${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARN${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}WARNING${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}INFO${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}DEBUG${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}TRACE${__RESET_COLOR}"

  echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Produce monochrome output. alias of --theme noColor."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--theme <theme>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Choose color theme - default-force means colors will be produced even if command is piped."
  echo

  echo "    Possible values: "
  echo -e "      - ${__OPTION_COLOR}default${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}default-force${__RESET_COLOR}"
  echo -e "      - ${__OPTION_COLOR}noColor${__RESET_COLOR}"
  Array::wrap2 ' ' 76 6 "    Default value: " "default"
  echo

  echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Print version information and quit."
  echo


  echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "Quiet mode, doesn't display any output."
  echo

  echo
  echo -e "${__HELP_TITLE_COLOR}GITHUB RELEASE MANAGER OPTIONS:${__RESET_COLOR}"
  echo -e "  ${__HELP_OPTION_COLOR}--config-file${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-c <configFile>${__HELP_NORMAL} {single}"
  Array::wrap2 ' ' 76 4 "    " "The yaml configuration file to use." ""
  echo

  Array::wrap2 ' ' 76 6 "    Default value: " "<currentDir>/githubReleaseManager.yaml"
  echo
  # ------------------------------------------
  # longDescription section
  # ------------------------------------------
  echo
  echo
  echo -e "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}"
  longDescriptionFunction
  # ------------------------------------------
  # version section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
  echo "3.0"
  # ------------------------------------------
  # author section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}AUTHOR: ${__RESET_COLOR}"
  echo "[François Chastanet](https://github.com/fchastanet)"
  # ------------------------------------------
  # sourceFile section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}SOURCE FILE: ${__RESET_COLOR}"
  echo "https://github.com/fchastanet/bash-tools-framework/tree/master/src/_binaries/Git/githubReleaseManager/githubReleaseManager-binary.yaml"
  # ------------------------------------------
  # license section
  # ------------------------------------------
  echo
  echo -n -e "${__HELP_TITLE_COLOR}LICENSE: ${__RESET_COLOR}"
  echo "MIT License"
  # ------------------------------------------
  # copyright section
  # ------------------------------------------
  Array::wrap2 ' ' 76 0 "$(copyrightCallback)"
}


beforeParseCallback
specificRequirements

githubReleaseManagerCommandParse "$@"
MAIN_FUNCTION_NAME="main"
main() {

# shellcheck disable=SC2154

importInstallCallbacks() {
  InstallCallbacks::installDeb
  Github::defaultInstall
  Linux::Apt::install
  Linux::requireUbuntu
  InstallCallbacks::getVersion
  InstallCallbacks::installFromTarGz
  InstallCallbacks::installFromTarXz
  Git::cloneOrPullIfNoChanges
  Git::requireGitCommand
}

forEachSoftware() {
  local configFile="${1}"
  shift || true
  local -a softwareIds=("$@")

  local theme="${optionTheme}"
  if [[ "${theme}" != "noColor" ]]; then
    theme="default-force"
  fi
  # Run installations in parallel using xargs
  local cmd="${BASH_SOURCE[0]}"
  export cmd optionConfigFile theme
  callSoft() {
    local soft="$1"
    SKIP_YAML_CHECKS=1 LOG_CONTEXT="Software ${soft} - " "${cmd}" \
      --theme "${theme}" -c "${optionConfigFile}" "${soft}"
  }
  export -f callSoft

  if command -v parallel &>/dev/null; then
    parallel -j "$(nproc)" callSoft ::: "${softwareIds[@]}"
  else
    printf "%s\n" "${softwareIds[@]}" |
      xargs --no-run-if-empty -n 1 -P "$(nproc)" -I {} bash -c 'callSoft "$@"' _ {}
  fi

}

processSingleSoftware() {
  local configFile="${1}"
  local softwareId="${2}"

  local id=""
  local url=""
  local version=""
  local versionArg=""
  local targetFile=""
  local sudo=""
  local installCallback=""
  local softVersionCallback=""
  local type=""
  local installScript=""
  local targetDir=""
  local cloneOptions=""
  local branch=""

  # shellcheck source=/dev/null
  source <(
    yq -o shell -r \
      ".softwares[] | select(.id == \"${softwareId}\") | del(.installScript)" \
      "${configFile}" | sed -E \
      -e '/^$/d' \
      -e 's/^([^=]+)=["\x27]*(.*)$/\1="\2/' \
      -e 's/["\x27]*$/"/'
  )
  if [[ -z "${id}" ]]; then
    return 0
  fi
  # shellcheck disable=SC2034
  LOG_CONTEXT="Software ${softwareId} - "
  if [[ -z "${installCallback}" || "${installCallback}" = "null" ]]; then
    installCallback="Github::defaultInstall"
  fi
  if [[ -z "${softVersionCallback}" || "${softVersionCallback}" = "null" ]]; then
    softVersionCallback="Version::getCommandVersionFromPlainText"
  fi
  if [[ -z "${type}" || "${type}" == "null" ]]; then
    type="githubRelease"
  fi
  if [[ "${type}" == "gitClone" ]]; then
    installScript="$(yq -r ".softwares[] | select(.id == \"${softwareId}\") | .installScript" "${configFile}")"
    if [[ "${installScript}" = "null" ]]; then
      installScript=""
    fi
    if [[ -z "${targetDir}" || "${targetDir}" == "null" ]]; then
      Log::displayError "targetDir is required for gitClone type"
      return 1
    fi
    installUsingGitClone \
      "${softwareId}" "${url}" "${sudo}" \
      "${targetDir}" "${branch}" "${cloneOptions}" "${installScript}"
  else
    installGithubRelease \
      "${softwareId}" "${url}" "${version}" \
      "${versionArg}" "${targetFile}" "${sudo}" \
      "${installCallback}" "${softVersionCallback}"
  fi
}

installUsingGitClone() {
  local softwareId="${1}"
  local githubUrl="${2}"
  local sudo="${3}"
  local targetDir="${4}"
  local branch="${5:-master}"
  local cloneOptions="${6:-}"
  local installScript="${7:-}"

  if [[ "${sudo}" == "null" ]]; then
    sudo=""
  fi
  Log::displayInfo "Installing ${softwareId}..."
  echo "  Type: Git Clone"
  echo "  URL: ${githubUrl}"
  echo "  Sudo: ${sudo}"
  echo "  Branch: ${branch}"
  echo "  Clone options: ${cloneOptions}"
  echo "  Target dir: ${targetDir}"
  if [[ -n "${installScript}" ]]; then
    echo "  Install script: Yes"
  fi
  function changeBranch() {
    local dir="$1"
    (
      cd "${dir}" || return 1
      "${sudo:-}" git checkout "${branch}"
    )
  }
  if ! SUDO="${sudo}" Git::cloneOrPullIfNoChanges \
    "${targetDir}" "${githubUrl}" changeBranch changeBranch; then
    Log::displayError "Failed to clone/pull ${softwareId}"
    return 1
  fi
  if [[ -n "${installScript}" ]]; then
    Log::displayInfo "Executing install script for ${softwareId}"
    (
      cd "${targetDir}" || return 1
      eval "${installScript}"
    ) || {
      Log::displayError "Failed to execute install script for ${softwareId}"
      return 1
    }
  fi
}

installGithubRelease() {
  local softwareId="${1}"
  local githubUrl="${2}"
  local version="${3}"
  local versionArg="${4}"
  local targetFileArg="${5}"
  local sudo="${6}"
  local installCallback="${7:-Github::defaultInstall}"
  local softVersionCallback="${8:-Version::getCommandVersionFromPlainText}"
  if [[ "${sudo}" == "null" ]]; then
    sudo=""
  fi
  local targetFile
  targetFile="$(eval echo "${targetFileArg}")"

  Log::displayInfo "Installing ${softwareId}..."
  echo "  Type: GitHub Release"
  echo "  URL: ${githubUrl}"
  echo "  Version: ${version}"
  echo "  Target file: ${targetFile}"
  echo "  Sudo: ${sudo}"
  echo "  Install callback: ${installCallback}"
  echo "  Soft version callback: ${softVersionCallback}"
  local exactVersion
  if [[ "${version}" == "latest" ]]; then
    exactVersion=""
  else
    exactVersion="${version}"
  fi

  if ! SUDO="${sudo}" \
    VERSION_PLACEHOLDER="@version@" EXACT_VERSION="${exactVersion}" \
    SOFT_VERSION_CALLBACK="${softVersionCallback}" \
    Github::upgradeRelease \
    "${targetFile}" \
    "${githubUrl}" \
    "${versionArg}" \
    "${softVersionCallback}" \
    "${installCallback}"; then
    Log::displayError "Failed to install ${softwareId}"
  fi
}
if command -v gh &>/dev/null; then
  if [[ -z "${SKIP_YAML_CHECKS:-}" && -z "${GH_TOKEN}" ]]; then
    if gh auth status | grep -q "Logged in to github.com"; then
      GH_TOKEN="$(gh auth token)"
      export GH_TOKEN
    fi
  fi
  if [[ -z "${GH_TOKEN}" ]]; then
    Log::displayWarning "GH_TOKEN is not set, cannot use gh, using curl to retrieve release versions list"
    export GH_WARNING_DISPLAYED=1
  fi
fi

declare -a softwareIds
# Get all software entries if no specific IDs provided
if [[ ${#softwareIdsArg[@]} -eq 0 ]]; then
  readarray -t softwareIds < <(yq '.softwares[].id' "${optionConfigFile}")
else
  softwareIds=("${softwareIdsArg[@]}")
fi

# shellcheck disable=SC2034
declare -g ARCH KERNEL MACHINE OS arch kernel machine os
ARCH="$(dpkg --print-architecture)"
# shellcheck disable=SC2034
arch="${ARCH,,}"
KERNEL="$(uname -s)"
# shellcheck disable=SC2034
kernel="${KERNEL,,}"
MACHINE="$(uname -m)"
# shellcheck disable=SC2034
machine="${MACHINE,,}"
OS="$(uname -s)"
# shellcheck disable=SC2034
os="${OS,,}"

if [[ ${#softwareIds[@]} -eq 1 ]]; then
  processSingleSoftware "${optionConfigFile}" "${softwareIds[0]}"
else
  forEachSoftware \
    "${optionConfigFile}" "${softwareIds[@]}"
fi

}

# if file is sourced avoid calling main function
# shellcheck disable=SC2178
BASH_SOURCE=".$0" # cannot be changed in bash
# shellcheck disable=SC2128
if test ".$0" == ".${BASH_SOURCE}"; then
  if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
    main "$@" &>/dev/null
  else
    main "$@"
  fi
fi
