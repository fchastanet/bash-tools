#!/usr/bin/env bash
###############################################################################
# GENERATED FACADE FROM https://github.com/fchastanet/bash-tools/tree/master/src/_binaries/DbImport/dbImport.sh
# DO NOT EDIT IT
# @generated
###############################################################################
# shellcheck disable=SC2288,SC2034
# BIN_FILE=${FRAMEWORK_ROOT_DIR}/bin/dbImport
# VAR_RELATIVE_FRAMEWORK_DIR_TO_CURRENT_DIR=..
# FACADE

# ensure that no user aliases could interfere with
# commands used in this script
unalias -a || true
shopt -u expand_aliases

# shellcheck disable=SC2034
((failures = 0)) || true

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# Command Substitution can inherit errexit option since bash v4.4
shopt -s inherit_errexit || true

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

# ensure regexp are interpreted without accentuated characters
export LC_ALL=POSIX

export TERM=xterm-256color

# avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# store command arguments for later usage
# shellcheck disable=SC2034
declare -a BASH_FRAMEWORK_ARGV=("$@")
# shellcheck disable=SC2034
declare -a ORIGINAL_BASH_FRAMEWORK_ARGV=("$@")

# @see https://unix.stackexchange.com/a/386856
# shellcheck disable=SC2317
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT
SCRIPT_NAME=${0##*/}
REAL_SCRIPT_FILE="$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")"
if [[ -n "${EMBED_CURRENT_DIR}" ]]; then
  CURRENT_DIR="${EMBED_CURRENT_DIR}"
else
  CURRENT_DIR="$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")" && pwd -P)"
fi

################################################
# Temp dir management
################################################

KEEP_TEMP_FILES="${KEEP_TEMP_FILES:-0}"
export KEEP_TEMP_FILES

# PERSISTENT_TMPDIR is not deleted by traps
PERSISTENT_TMPDIR="${TMPDIR:-/tmp}/bash-framework"
export PERSISTENT_TMPDIR
mkdir -p "${PERSISTENT_TMPDIR}"

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${PERSISTENT_TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
# shellcheck disable=SC2317
cleanOnExit() {
  if [[ "${KEEP_TEMP_FILES:-0}" = "1" ]]; then
    Log::displayInfo "KEEP_TEMP_FILES=1 temp files kept here '${TMPDIR}'"
  elif [[ -n "${TMPDIR+xxx}" ]]; then
    Log::displayDebug "KEEP_TEMP_FILES=0 removing temp files '${TMPDIR}'"
    rm -Rf "${TMPDIR:-/tmp/fake}" >/dev/null 2>&1
  fi
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @description check if an element is contained in an array
#
# @arg $1 needle:String
# @arg $@ array:String[]
# @exitcode 0 if found
# @exitcode 1 otherwise
# @example
#   Array::contains "${libPath}" "${__BASH_FRAMEWORK_IMPORTED_FILES[@]}"
Array::contains() {
  local element
  for element in "${@:2}"; do
    [[ "${element}" = "$1" ]] && return 0
  done
  return 1
}

# @description concat each element of an array with a separator
# but wrapping text when line length is more than provided argument
# The algorithm will try not to cut the array element if can
#
# @arg $1 glue:String
# @arg $2 maxLineLength:int
# @arg $3 indentNextLine:int
# @arg $@ array:String[]
Array::wrap() {
  local glue="${1-}"
  local -i glueLength=0
  shift || true
  local -i maxLineLength=$1
  shift || true
  local -i indentNextLine=$1
  local indentStr=""
  if ((indentNextLine > 0)); then
    indentStr="$(head -c "${indentNextLine}" </dev/zero | tr '\0' " ")"
  fi
  local -i firstLine=1
  shift || true
  (($# != 0)) || return 0

  local arg

  # convert multi-line arg to several args
  local -a allArgs=()
  for arg in "$@"; do
    local line
    local IFS=$'\n'
    arg="$(echo -e "${arg}")"
    while read -r line; do
      if [[ -z "${line}" ]]; then
        allArgs+=($'\n')
      else
        allArgs+=("${line}")
      fi
    done <<<"${arg}"
  done
  set -- "${allArgs[@]}"

  local -i currentLineLength=0
  local needEcho="0"
  local arg="$1"
  local argNoAnsi
  local -i argNoAnsiLength=0

  while (($# > 0)); do
    argNoAnsi="$(echo "${arg%%*( )}" | Filters::removeAnsiCodes)"
    ((argNoAnsiLength = ${#argNoAnsi})) || true
    if (($# < 1 && argNoAnsiLength == 0)); then
      break
    fi
    if [[ "${arg}" = $'\n' ]]; then
      if [[ "${needEcho}" = "1" ]]; then
        needEcho="0"
      fi
      echo ""
      ((currentLineLength = 0)) || true
      ((glueLength = 0)) || true
      shift || return 0
      arg="$1"
    elif ((argNoAnsiLength < maxLineLength - currentLineLength - glueLength)); then
      # arg can be stored as a whole on current line
      if ((glueLength > 0)); then
        echo -e -n "${glue}"
        ((currentLineLength += glueLength))
      fi
      if ((currentLineLength == 0 && firstLine == 0)); then
        echo -n "${indentStr}"
      fi
      echo -e -n "${arg}" | sed 's/[\t ]*$//g'
      needEcho="1"
      ((currentLineLength += argNoAnsiLength))
      ((glueLength = ${#glue})) || true
      shift || return 0
      arg="$1"
    else
      if ((argNoAnsiLength >= (maxLineLength - indentNextLine))); then
        if ((currentLineLength == 0 && firstLine == 0)); then
          echo -n "${indentStr}"
          ((currentLineLength += indentNextLine))
        fi
        # arg can be stored on a whole line
        if ((glueLength > 0)); then
          echo -e -n "${glue}"
          ((currentLineLength += glueLength))
        fi
        local -i length
        ((length = maxLineLength - currentLineLength)) || true
        echo -e "${arg:0:${length}}" | sed 's/[\t ]*$//g'
        ((currentLineLength = 0)) || true
        ((glueLength = 0)) || true
        arg="${arg:${length}}"
        needEcho="0"
      else
        # arg cannot be stored on a whole line, so we add it on next line as a whole
        echo
        echo -e -n "${indentStr}${arg}" | sed 's/[\t ]*$//g'
        ((glueLength = ${#glue})) || true
        ((currentLineLength = argNoAnsiLength))
        arg="" # allows to go to next arg
        needEcho="1"
      fi
      if [[ -z "${arg}" ]]; then
        shift || return 0
        arg="$1"
      fi
    fi
    ((firstLine = 0)) || true
  done
  if [[ "${needEcho}" = "1" ]]; then
    echo
  fi
}

#set -x
#Array::wrap ":" 40 0 "Lorem ipsum dolor sit amet," "consectetur adipiscing elit." "Curabitur ac elit id massa" "condimentum finibus."

# @description check if command specified exists or return 1
# with error and message if not
#
# @arg $1 commandName:String on which existence must be checked
# @arg $2 helpIfNotExists:String a help command to display if the command does not exist
#
# @exitcode 1 if the command specified does not exist
# @stderr diagnostic information + help if second argument is provided
Assert::commandExists() {
  local commandName="$1"
  local helpIfNotExists="$2"

  "${BASH_FRAMEWORK_COMMAND:-command}" -v "${commandName}" >/dev/null 2>/dev/null || {
    Log::displayError "${commandName} is not installed, please install it"
    if [[ -n "${helpIfNotExists}" ]]; then
      Log::displayInfo "${helpIfNotExists}"
    fi
    return 1
  }
  return 0
}

# @description get absolute conf file from specified conf folder deduced using these rules
#   * from absolute file (ignores <confFolder> and <extension>)
#   * relative to where script is executed (ignores <confFolder> and <extension>)
#   * from home/.bash-tools/<confFolder>
#   * from framework conf/<confFolder>
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 conf:String file to use without extension
# @arg $3 extension:String the extension (.sh by default)
#
# @stdout absolute conf filename
# @exitcode 1 if file is not found in any location
Conf::getAbsoluteFile() {
  local confFolder="$1"
  local conf="$2"
  local extension="${3-.sh}"
  if [[ -n "${extension}" && "${extension:0:1}" != "." ]]; then
    extension=".${extension}"
  fi

  testAbs() {
    local result
    result="$(realpath -e "$1" 2>/dev/null)"
    # shellcheck disable=SC2181
    if [[ "$?" = "0" && -f "${result}" ]]; then
      echo "${result}"
      return 0
    fi
    return 1
  }

  # conf is absolute file (including extension)
  testAbs "${confFolder}${extension}" && return 0
  # conf is absolute file
  testAbs "${confFolder}" && return 0
  # conf is absolute file (including extension)
  testAbs "${conf}${extension}" && return 0
  # conf is absolute file
  testAbs "${conf}" && return 0

  # relative to where script is executed (including extension)
  if [[ -n "${CURRENT_DIR+xxx}" ]]; then
    testAbs "$(File::concatenatePath "${CURRENT_DIR}" "${confFolder}")/${conf}${extension}" && return 0
  fi
  # from home/.bash-tools/<confFolder>
  testAbs "$(File::concatenatePath "${HOME}/.bash-tools" "${confFolder}")/${conf}${extension}" && return 0

  if [[ -n "${FRAMEWORK_ROOT_DIR+xxx}" ]]; then
    # from framework conf/<confFolder> (including extension)
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}${extension}" && return 0

    # from framework conf/<confFolder>
    testAbs "$(File::concatenatePath "${FRAMEWORK_ROOT_DIR}/conf" "${confFolder}")/${conf}" && return 0
  fi

  # file not found
  Log::displayError "conf file '${conf}' not found"

  return 1
}

# @description list the conf files list available in bash-tools/conf/<conf> folder
# and those overridden in ${HOME}/.bash-tools/<conf> folder
#
# @arg $1 confFolder:String the directory name (not the path) to list
# @arg $2 extension:String the extension (.sh by default)
# @arg $3 indentStr:String the indentation ('       - ' by default) can be any string compatible with sed not containing any /
#
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
Conf::getMergedList() {
  local confFolder="$1"
  local extension="${2-sh}"
  local indentStr="${3-       - }"

  local DEFAULT_CONF_DIR="${FRAMEWORK_ROOT_DIR}/conf/${confFolder}"
  local HOME_CONF_DIR="${HOME}/.bash-tools/${confFolder}"

  (
    if [[ -d "${DEFAULT_CONF_DIR}" ]]; then
      Conf::list "${DEFAULT_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
    if [[ -d "${HOME_CONF_DIR}" ]]; then
      Conf::list "${HOME_CONF_DIR}" "" "${extension}" "-type f" "${indentStr}"
    fi
  ) | sort | uniq
}

# @description dump db limited to optional table list
#
# @arg $1 instanceDump:&Map<String,String> (passed by reference) database instance to use
# @arg $2 db:String the db to dump
# @arg $3 optionalTableList:String (optional) string containing tables list (can be empty string in order to specify additional options)
# @arg $4 dumpAdditionalOptions:String[] (optional)_ ... additional dump options
# @stderr display db sql debug
# @exitcode * mysqldump command status code
Database::dump() {
  # shellcheck disable=SC2178
  local -n instanceDump=$1
  shift || true
  local db="$1"
  shift || true
  # optional table list
  local optionalTableList=""
  if [[ -n "${1+x}" ]]; then
    optionalTableList="$1"
    shift || true
  fi
  local -a dumpAdditionalOptions=()
  local -a mysqlCommand=()

  # additional options
  if [[ -n "${1+x}" ]]; then
    dumpAdditionalOptions=("$@")
  fi

  mysqlCommand+=(mysqldump)
  mysqlCommand+=("--defaults-extra-file=${instanceDump['AUTH_FILE']}")
  IFS=' ' read -r -a dumpOptions <<<"${instanceDump['DUMP_OPTIONS']}"
  mysqlCommand+=("${dumpOptions[@]}")
  mysqlCommand+=("${dumpAdditionalOptions[@]}")
  mysqlCommand+=("${db}")
  # shellcheck disable=SC2206
  mysqlCommand+=(${optionalTableList})

  Log::displayDebug "execute command: '${mysqlCommand[*]}'"
  "${mysqlCommand[@]}"
}

# @description check if given database exists
#
# @arg $1 instanceIfDbExists:&Map<String,String> (passed by reference) database instance to use
# @arg $2 dbName:String database name
# @exitcode 1 if db doesn't exist
# @stderr debug command
Database::ifDbExists() {
  local -n instanceIfDbExists=$1
  local dbName="$2"
  local result
  local -a mysqlCommand=()

  mysqlCommand+=(mysqlshow)
  mysqlCommand+=("--defaults-extra-file=${instanceIfDbExists['AUTH_FILE']}")
  # shellcheck disable=SC2206
  mysqlCommand+=(${instanceIfDbExists['SSL_OPTIONS']})
  mysqlCommand+=("${dbName}")
  Log::displayDebug "execute command: '${mysqlCommand[*]}'"
  result="$(MSYS_NO_PATHCONV=1 "${mysqlCommand[@]}" 2>/dev/null | grep '^Database: ' | grep -o "${dbName}")"
  [[ "${result}" = "${dbName}" ]]
}

# @description create a new db instance
# Returns immediately if the instance is already initialized
#
# @arg $1 instanceNewInstance:&Map<String,String> (passed by reference) database instance to use
# @arg $2 dsn:String dsn profile - load the dsn.env profile deduced using rules defined in Conf::getAbsoluteFile
#
# @example
#   declare -Agx dbInstance
#   Database::newInstance dbInstance "default.local"
#
# @exitcode 1 if dns file not able to loaded
Database::newInstance() {
  local -n instanceNewInstance=$1
  local dsn="$2"
  local DSN_FILE

  if [[ -v instanceNewInstance['INITIALIZED'] && "${instanceNewInstance['INITIALIZED']:-0}" == "1" ]]; then
    return
  fi

  # final auth file generated from dns file
  instanceNewInstance['AUTH_FILE']=""
  instanceNewInstance['DSN_FILE']=""

  # check dsn file
  DSN_FILE="$(Conf::getAbsoluteFile "dsn" "${dsn}" "env")" || return 1
  Database::checkDsnFile "${DSN_FILE}" || return 1
  instanceNewInstance['DSN_FILE']="${DSN_FILE}"

  # shellcheck source=/src/Database/testsData/dsn_valid.env
  source "${instanceNewInstance['DSN_FILE']}"

  instanceNewInstance['USER']="${USER}"
  instanceNewInstance['PASSWORD']="${PASSWORD}"
  instanceNewInstance['HOSTNAME']="${HOSTNAME}"
  instanceNewInstance['PORT']="${PORT}"

  # generate authFile for easy authentication
  instanceNewInstance['AUTH_FILE']=$(mktemp -p "${TMPDIR:-/tmp}" -t "mysql.XXXXXXXXXXXX")
  (
    echo "[client]"
    echo "user = ${USER}"
    echo "password = ${PASSWORD}"
    echo "host = ${HOSTNAME}"
    echo "port = ${PORT}"
  ) >"${instanceNewInstance['AUTH_FILE']}"

  # some of those values can be overridden using the dsn file
  # SKIP_COLUMN_NAMES enabled by default
  instanceNewInstance['SKIP_COLUMN_NAMES']="${SKIP_COLUMN_NAMES:-1}"
  instanceNewInstance['SSL_OPTIONS']="${MYSQL_SSL_OPTIONS:---ssl-mode=DISABLED}"
  instanceNewInstance['QUERY_OPTIONS']="${MYSQL_QUERY_OPTIONS:---batch --raw --default-character-set=utf8}"
  instanceNewInstance['DUMP_OPTIONS']="${MYSQL_DUMP_OPTIONS:---default-character-set=utf8 --compress --hex-blob --routines --triggers --single-transaction --set-gtid-purged=OFF --column-statistics=0 ${instanceNewInstance['SSL_OPTIONS']}}"
  instanceNewInstance['DB_IMPORT_OPTIONS']="${DB_IMPORT_OPTIONS:---connect-timeout=5 --batch --raw --default-character-set=utf8}"

  instanceNewInstance['INITIALIZED']=1
}

# @description mysql query on a given db
# @warning could use QUERY_OPTIONS variable from dsn if defined
# @example
#   cat file.sql | Database::query ...
# @arg $1 instanceQuery:&Map<String,String> (passed by reference) database instance to use
# @arg $2 sqlQuery:String (optional) sql query or sql file to execute. if not provided or empty, the command can be piped
# @arg $3 dbName:String (optional) the db name
#
# @exitcode mysql command status code
Database::query() {
  local -n instanceQuery=$1
  local -a mysqlCommand=()
  local -a queryOptions

  mysqlCommand+=(mysql)
  mysqlCommand+=("--defaults-extra-file=${instanceQuery['AUTH_FILE']}")
  IFS=' ' read -r -a queryOptions <<<"${instanceQuery['QUERY_OPTIONS']}"
  mysqlCommand+=("${queryOptions[@]}")
  if [[ "${instanceQuery['SKIP_COLUMN_NAMES']}" = "1" ]]; then
    mysqlCommand+=("-s" "--skip-column-names")
  fi
  # add optional db name
  if [[ -n "${3+x}" ]]; then
    mysqlCommand+=("$3")
  fi
  # add optional sql query
  if [[ -n "${2+x}" && -n "$2" && ! -f "$2" ]]; then
    mysqlCommand+=("-e")
    mysqlCommand+=("$2")
  fi
  Log::displayDebug "$(printf "execute command: '%s'" "${mysqlCommand[*]}")"

  if [[ -f "$2" ]]; then
    "${mysqlCommand[@]}" <"$2"
  else
    "${mysqlCommand[@]}"
  fi
}

# @description set the general options to use on mysql command to query the database
# Differs than setOptions in the way that these options could change each time
#
# @arg $1 instanceSetQueryOptions:&Map<String,String> (passed by reference) database instance to use
# @arg $2 optionsList:String query options list
Database::setQueryOptions() {
  local -n instanceSetQueryOptions=$1
  # shellcheck disable=SC2034
  instanceSetQueryOptions['QUERY_OPTIONS']="$2"
}

# @description ensure env files are loaded
# @arg $@ list of default files to load at the end
# @exitcode 1 if one of env files fails to load
# @stderr diagnostics information is displayed
# shellcheck disable=SC2120
Env::requireLoad() {
  local -a defaultFiles=("$@")
  # get list of possible config files
  local -a configFiles=()
  if [[ -n "${BASH_FRAMEWORK_ENV_FILES[0]+1}" ]]; then
    # BASH_FRAMEWORK_ENV_FILES is an array
    configFiles+=("${BASH_FRAMEWORK_ENV_FILES[@]}")
  fi
  if [[ -f "$(pwd)/.framework-config" ]]; then
    configFiles+=("$(pwd)/.framework-config")
  fi
  if [[ -f "${FRAMEWORK_ROOT_DIR}/.framework-config" ]]; then
    configFiles+=("${FRAMEWORK_ROOT_DIR}/.framework-config")
  fi
  if [[ -n "${optionBashFrameworkConfig}" && -f "${optionBashFrameworkConfig}" ]]; then
    # shellcheck disable=SC2034
    configFiles+=("${optionBashFrameworkConfig}")
  fi
  configFiles+=("${optionEnvFiles[@]}")
  configFiles+=("${defaultFiles[@]}")

  for file in "${configFiles[@]}"; do
    # shellcheck source=/.framework-config
    CURRENT_LOADED_ENV_FILE="${file}" source "${file}" || {
      Log::displayError "while loading config file: ${file}"
      return 1
    }
  done
}

# @description delete files older than n days in given path
# @warning use this function with caution as it will delete all files in given path without any prompt
# @arg $1 path:String the directory in which files will be deleted or the file to delete
# @arg $2 mtime:String expiration time in days (eg: 1 means 1 day) (default value: 1). Eg: +1 match files that have been accessed at least two days ago (rounding effect)
# @arg $3 maxdepth:int Descend at most levels (a non-negative integer) levels of directories below the starting-points. (default value: 1)
# @exitcode 1 if path not provided or empty
# @exitcode * find command failure code
# @stderr find output on error or diagnostics logs
# @see man find atime
File::garbageCollect() {
  local path="$1"
  local mtime="$2"
  local maxdepth="${3:-1}"

  if [[ -z "${path}" ]]; then
    return 1
  fi

  if [[ ! -e "${path}" ]]; then
    # path already removed
    return 0
  fi

  Log::displayInfo "Garbage collect files older than ${mtime} days in path ${path} with max depth ${maxdepth}"
  find "${path}" -depth -maxdepth "${maxdepth}" -type f -mtime "${mtime}" -print -delete
}

# @description create a temp file using default TMPDIR variable
# initialized in _includes/_commonHeader.sh
# @env TMPDIR String (default value /tmp)
# @arg $1 templateName:String template name to use(optional)
Framework::createTempFile() {
  mktemp -p "${TMPDIR:-/tmp}" -t "${1:-}.XXXXXXXXXXXX"
}

# @description Log namespace provides 2 kind of functions
# - Log::display* allows to display given message with
#   given display level
# - Log::log* allows to log given message with
#   given log level
# Log::display* functions automatically log the message too
# @see Env::requireLoad to load the display and log level from .env file

# @description log level off
export __LEVEL_OFF=0
# @description log level error
export __LEVEL_ERROR=1
# @description log level warning
export __LEVEL_WARNING=2
# @description log level info
export __LEVEL_INFO=3
# @description log level success
export __LEVEL_SUCCESS=3
# @description log level debug
export __LEVEL_DEBUG=4

# @description verbose level off
export __VERBOSE_LEVEL_OFF=0
# @description verbose level info
export __VERBOSE_LEVEL_INFO=1
# @description verbose level info
export __VERBOSE_LEVEL_DEBUG=2
# @description verbose level info
export __VERBOSE_LEVEL_TRACE=3

# @description Display message using debug color (grey)
# @arg $1 message:String the message to display
Log::displayDebug() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_DEBUG)); then
    echo -e "${__DEBUG_COLOR}DEBUG   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logDebug "$1"
}

# @description Display message using error color (red)
# @arg $1 message:String the message to display
Log::displayError() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_ERROR)); then
    echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logError "$1"
}

# @description Display message using info color (bg light blue/fg white)
# @arg $1 message:String the message to display
Log::displayInfo() {
  local type="${2:-INFO}"
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__INFO_COLOR}${type}    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logInfo "$1" "${type}"
}

# @description Display message using warning color (yellow)
# @arg $1 message:String the message to display
Log::displayWarning() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_WARNING)); then
    echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logWarning "$1"
}

# @description Display message using error color (red) and exit immediately with error status 1
# @arg $1 message:String the message to display
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  Log::logFatal "$1"
  exit 1
}

# @description activate or not Log::display* and Log::log* functions
# based on BASH_FRAMEWORK_DISPLAY_LEVEL and BASH_FRAMEWORK_LOG_LEVEL
# environment variables loaded by Env::requireLoad
# try to create log file and rotate it if necessary
# @noargs
# @set BASH_FRAMEWORK_LOG_LEVEL int to OFF level if BASH_FRAMEWORK_LOG_FILE is empty or not writable
# @env BASH_FRAMEWORK_DISPLAY_LEVEL int
# @env BASH_FRAMEWORK_LOG_LEVEL int
# @env BASH_FRAMEWORK_LOG_FILE String
# @env BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION int do log rotation if > 0
# @exitcode 0 always successful
# @stderr diagnostics information about log file is displayed
# @require Env::requireLoad
# @require UI::requireTheme
Log::requireLoad() {
  if [[ -z "${BASH_FRAMEWORK_LOG_FILE:-}" ]]; then
    BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
    export BASH_FRAMEWORK_LOG_LEVEL
  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    if [[ ! -f "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      if
        ! mkdir -p "$(dirname "${BASH_FRAMEWORK_LOG_FILE}")" 2>/dev/null ||
          ! touch --no-create "${BASH_FRAMEWORK_LOG_FILE}" 2>/dev/null
      then
        BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
        echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
      fi
    elif [[ ! -w "${BASH_FRAMEWORK_LOG_FILE}" ]]; then
      BASH_FRAMEWORK_LOG_LEVEL=${__LEVEL_OFF}
      echo -e "${__ERROR_COLOR}ERROR   - File ${BASH_FRAMEWORK_LOG_FILE} is not writable${__RESET_COLOR}" >&2
    fi

  fi

  if ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    # will always be created even if not in info level
    Log::logMessage "INFO" "Logging to file ${BASH_FRAMEWORK_LOG_FILE} - Log level ${BASH_FRAMEWORK_LOG_LEVEL}"
    if ((BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION > 0)); then
      Log::rotate "${BASH_FRAMEWORK_LOG_FILE}" "${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION}"
    fi
  fi
}

# @description draw a line with the character passed in parameter repeated depending on terminal width
# @arg $1 character:String character to use as separator (default value #)
UI::drawLine() {
  local character="${1:-#}"
  printf '%*s\n' "${COLUMNS:-$([[ -t 0 ]] && tput cols || echo)}" '' | tr ' ' "${character}"
}

# @description load colors theme constants
# @warning if tty not opened, noColor theme will be chosen
# @arg $1 theme:String the theme to use (default, noColor)
# @arg $@ args:String[]
# @set __ERROR_COLOR String indicate error status
# @set __INFO_COLOR String indicate info status
# @set __SUCCESS_COLOR String indicate success status
# @set __WARNING_COLOR String indicate warning status
# @set __SKIPPED_COLOR String indicate skipped status
# @set __DEBUG_COLOR String indicate debug status
# @set __HELP_COLOR String indicate help status
# @set __TEST_COLOR String not used
# @set __TEST_ERROR_COLOR String not used
# @set __HELP_TITLE_COLOR String used to display help title in help strings
# @set __HELP_OPTION_COLOR String used to display highlight options in help strings
#
# @set __RESET_COLOR String reset default color
#
# @set __HELP_EXAMPLE String to remove
# @set __HELP_TITLE String to remove
# @set __HELP_NORMAL String to remove
# shellcheck disable=SC2034
UI::theme() {
  local theme="${1-default}"
  if [[ ! "${theme}" =~ -force$ ]] && ! Assert::tty; then
    theme="noColor"
  fi
  case "${theme}" in
    default | default-force)
      theme="default"
      ;;
    noColor) ;;
    *)
      Log::fatal "invalid theme provided"
      ;;
  esac
  if [[ "${theme}" = "default" ]]; then
    BASH_FRAMEWORK_THEME="default"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR='\e[31m'         # Red
    __INFO_COLOR='\e[44m'          # white on lightBlue
    __SUCCESS_COLOR='\e[32m'       # Green
    __WARNING_COLOR='\e[33m'       # Yellow
    __SKIPPED_COLOR='\e[33m'       # Yellow
    __DEBUG_COLOR='\e[37m'         # Grey
    __HELP_COLOR='\e[7;49;33m'     # Black on Gold
    __TEST_COLOR='\e[100m'         # Light magenta
    __TEST_ERROR_COLOR='\e[41m'    # white on red
    __HELP_TITLE_COLOR="\e[1;37m"  # Bold
    __HELP_OPTION_COLOR="\e[1;34m" # Blue
    # Internal: reset color
    __RESET_COLOR='\e[0m' # Reset Color
    # shellcheck disable=SC2155,SC2034
    __HELP_EXAMPLE="$(echo -e "\e[2;97m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_TITLE="$(echo -e "\e[1;37m")"
    # shellcheck disable=SC2155,SC2034
    __HELP_NORMAL="$(echo -e "\033[0m")"
  else
    BASH_FRAMEWORK_THEME="noColor"
    # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
    __ERROR_COLOR=''
    __INFO_COLOR=''
    __SUCCESS_COLOR=''
    __WARNING_COLOR=''
    __SKIPPED_COLOR=''
    __DEBUG_COLOR=''
    __HELP_COLOR=''
    __TEST_COLOR=''
    __TEST_ERROR_COLOR=''
    __HELP_TITLE_COLOR=''
    __HELP_OPTION_COLOR=''
    # Internal: reset color
    __RESET_COLOR=''
    __HELP_EXAMPLE=''
    __HELP_TITLE=''
    __HELP_NORMAL=''
  fi
}

# @description Check that command version is greater than expected minimal version
# display warning if command version greater than expected minimal version
# display error if command version less than expected minimal version and exit 1
# @arg $1 commandName:String command path
# @arg $2 argVersion:String command line parameters to launch to get command version
# @arg $3 minimalVersion:String expected minimal command version
# @arg $4 parseVersionCallback:Function
# @arg $5 help:String optional help message to display if command does not exist
# @exitcode 0 if command version greater or equal to expected minimal version
# @exitcode 1 if command version less than expected minimal version
# @exitcode 2 if command does not exist
Version::checkMinimal() {
  local commandName="$1"
  local argVersion="$2"
  local minimalVersion="$3"
  local parseVersionCallback=${4:-Version::parse}
  local help="${5:-}"

  Assert::commandExists "${commandName}" "${help}" || return 2

  local version
  version="$("${commandName}" "${argVersion}" 2>&1 | ${parseVersionCallback})"

  Log::displayDebug "check ${commandName} version ${version} against minimal ${minimalVersion}"

  Version::compare "${version}" "${minimalVersion}" || {
    local result=$?
    if [[ "${result}" = "1" ]]; then
      Log::displayDebug "${commandName} version is ${version} greater than ${minimalVersion}, OK let's continue"
    elif [[ "${result}" = "2" ]]; then
      Log::displayError "${commandName} minimal version is ${minimalVersion}, your version is ${version}"
      return 1
    fi
    return 0
  }

}

# @description ensure COMMAND_BIN_DIR env var is set
# and PATH correctly prepared
# @noargs
# @set COMMAND_BIN_DIR string the directory where to find this command
# @set PATH string add directory where to find this command binary
Compiler::Facade::requireCommandBinDir() {
  COMMAND_BIN_DIR="${CURRENT_DIR}"
  Env::pathPrepend "${COMMAND_BIN_DIR}"
}

# @description ensure running user is not root
# @exitcode 1 if current user is root
# @stderr diagnostics information is displayed
Linux::requireExecutedAsUser() {
  if [[ "$(id -u)" = "0" ]]; then
    Log::fatal "this script should be executed as normal user"
  fi
}

# @description check if tty (interactive mode) is active
# @noargs
# @exitcode 1 if tty not active
# @env NON_INTERACTIVE if 1 consider as not interactive even if environment is interactive
# @env INTERACTIVE if 1 consider as interactive even if environment is not interactive
# @stderr diagnostic information + help if second argument is provided
Assert::tty() {
  if [[ "${NON_INTERACTIVE:-0}" = "1" ]]; then
    return 1
  fi
  if [[ "${INTERACTIVE:-0}" = "1" ]]; then
    return 0
  fi
  [[ -t 1 || -t 2 ]]
}

# @description list files of dir with given extension and display it as a list one by line
#
# @arg $1 dir:String the directory to list
# @arg $2 prefix:String the profile file prefix (default: "")
# @arg $3 ext:String the extension
# @arg $4 findOptions:String find options, eg: -type d (Default value: '-type f')
# @arg $5 indentStr:String the indentation can be any string compatible with sed not containing any / (Default value: '       - ')
# @stdout list of files without extension/directory
# @example text
#       - default.local
#       - default.remote
#       - localhost-root
# @exitcode 1 if directory does not exists
Conf::list() {
  local dir="$1"
  local prefix="${2:-}"
  local ext="${3}"
  local findOptions="${4--type f}"
  local indentStr="${5-       - }"

  if [[ ! -d "${dir}" ]]; then
    Log::displayError "Directory ${dir} does not exist"
  fi
  if [[ -n "${ext}" && "${ext:0:1}" != "." ]]; then
    ext=".${ext}"
  fi
  (
    # shellcheck disable=SC2086
    cd "${dir}" &&
      find . -maxdepth 1 ${findOptions} -name "${prefix}*${ext}" |
      sed -E "s#^\./${prefix}##g" |
        sed -E "s#${ext}\$##g" | sort | sed -E "s#^#${indentStr}#"
  )
}

# @description check if dsn file has all the mandatory variables set
# Mandatory variables are: HOSTNAME, USER, PASSWORD, PORT
#
# @arg $1 dsnFileName:String dsn absolute filename
# @set HOSTNAME loaded from dsn file
# @set PORT loaded from dsn file
# @set USER loaded from dsn file
# @set PASSWORD loaded from dsn file
# @exitcode 0 on valid file
# @exitcode 1 if one of the properties of the conf file is invalid or if file not found
# @stderr log output if error found in conf file
Database::checkDsnFile() {
  local dsnFileName="$1"
  if [[ ! -f "${dsnFileName}" ]]; then
    Log::displayError "dsn file ${dsnFileName} not found"
    return 1
  fi

  (
    unset HOSTNAME PORT PASSWORD USER
    # shellcheck source=/src/Database/testsData/dsn_valid.env
    source "${dsnFileName}"
    if [[ -z ${HOSTNAME+x} ]]; then
      Log::displayError "dsn file ${dsnFileName} : HOSTNAME not provided"
      return 1
    fi
    if [[ -z "${HOSTNAME}" ]]; then
      Log::displayWarning "dsn file ${dsnFileName} : HOSTNAME value not provided"
    fi
    if [[ "${HOSTNAME}" = "localhost" ]]; then
      Log::displayWarning "dsn file ${dsnFileName} : check that HOSTNAME should not be 127.0.0.1 instead of localhost"
    fi
    if [[ -z "${PORT+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : PORT not provided"
      return 1
    fi
    if ! [[ ${PORT} =~ ^[0-9]+$ ]]; then
      Log::displayError "dsn file ${dsnFileName} : PORT invalid"
      return 1
    fi
    if [[ -z "${USER+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : USER not provided"
      return 1
    fi
    if [[ -z "${PASSWORD+x}" ]]; then
      Log::displayError "dsn file ${dsnFileName} : PASSWORD not provided"
      return 1
    fi
  )
}

# @description prepend directories to the PATH environment variable
# @arg $@ args:String[] list of directories to prepend
# @set PATH update PATH with the directories prepended
Env::pathPrepend() {
  local arg
  for arg in "$@"; do
    if [[ -d "${arg}" && ":${PATH}:" != *":${arg}:"* ]]; then
      PATH="$(realpath "${arg}"):${PATH}"
    fi
  done
}

# @description concatenate 2 paths and ensure the path is correct using realpath -m
# @arg $1 basePath:String
# @arg $2 subPath:String
# @require Linux::requireRealpathCommand
File::concatenatePath() {
  local basePath="$1"
  local subPath="$2"
  local fullPath="${basePath:+${basePath}/}${subPath}"

  realpath -m "${fullPath}" 2>/dev/null
}

# @description remove ansi codes from input or files given as argument
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# @see https://en.wikipedia.org/wiki/ANSI_escape_code
# shellcheck disable=SC2120
Filters::removeAnsiCodes() {
  # cspell:disable
  sed -E 's/\x1b\[[0-9;]*[mGKHF]//g' "$@"
  # cspell:enable
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logDebug() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_DEBUG)); then
    Log::logMessage "${2:-DEBUG}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logError() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_ERROR)); then
    Log::logMessage "${2:-ERROR}" "$1"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logFatal() {
  Log::logMessage "${2:-FATAL}" "$1"
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logInfo() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-INFO}" "$1"
  fi
}

# @description Internal: common log message
# @example text
#   [date]|[levelMsg]|message
#
# @example text
#   2020-01-19 19:20:21|ERROR  |log error
#   2020-01-19 19:20:21|SKIPPED|log skipped
#
# @arg $1 levelMsg:String message's level description (eg: STATUS, ERROR, ...)
# @arg $2 msg:String the message to display
# @env BASH_FRAMEWORK_LOG_FILE String log file to use, do nothing if empty
# @env BASH_FRAMEWORK_LOG_LEVEL int log level log only if > OFF or fatal messages
# @stderr diagnostics information is displayed
# @require Env::requireLoad
# @require Log::requireLoad
Log::logMessage() {
  local levelMsg="$1"
  local msg="$2"
  local date

  if [[ -n "${BASH_FRAMEWORK_LOG_FILE}" ]] && ((BASH_FRAMEWORK_LOG_LEVEL > __LEVEL_OFF)); then
    date="$(date '+%Y-%m-%d %H:%M:%S')"
    touch "${BASH_FRAMEWORK_LOG_FILE}"
    printf "%s|%7s|%s\n" "${date}" "${levelMsg}" "${msg}" >>"${BASH_FRAMEWORK_LOG_FILE}"
  fi
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logWarning() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_WARNING)); then
    Log::logMessage "${2:-WARNING}" "$1"
  fi
}

# @description To be called before logging in the log file
# @arg $1 file:string log file name
# @arg $2 maxLogFilesCount:int maximum number of log files
Log::rotate() {
  local file="$1"
  local maxLogFilesCount="${2:-5}"

  if [[ ! -f "${file}" ]]; then
    Log::displaySkipped "Log file ${file} doesn't exist yet"
    return 0
  fi
  for i in $(seq $((maxLogFilesCount - 1)) -1 1); do
    Log::displayInfo "Log rotation ${file}.${i} to ${file}.$((i + 1))"
    mv "${file}."{"${i}","$((i + 1))"} &>/dev/null || true
  done
  if cp "${file}" "${file}.1" &>/dev/null; then
    echo >"${file}" # reset log file
    Log::displayInfo "Log rotation ${file} to ${file}.1"
  fi
}

# @description compare 2 version numbers
# @arg $1 version1:String version 1
# @arg $2 version2:String version 2
# @exitcode 0 if equal
# @exitcode 1 if version1 > version2
# @exitcode 2 else
Version::compare() {
  if [[ "$1" = "$2" ]]; then
    return 0
  fi
  local IFS=.
  # shellcheck disable=2206
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do
    ver1[i]=0
  done
  for ((i = 0; i < ${#ver1[@]}; i++)); do
    if [[ -z "${ver2[i]+unset}" ]] || [[ -z ${ver2[i]} ]]; then
      # fill empty fields in ver2 with zeros
      ver2[i]=0
    fi
    if ((10#${ver1[i]} > 10#${ver2[i]})); then
      return 1
    fi
    if ((10#${ver1[i]} < 10#${ver2[i]})); then
      return 2
    fi
  done
  return 0
}

# @description filter to keep only version number from a string
# @arg $@ files:String[] the files to filter
# @exitcode * if one of the filter command fails
# @stdin you can use stdin as alternative to files argument
# @stdout the filtered content
# shellcheck disable=SC2120
Version::parse() {
  sed -En 's/[^0-9]*(([0-9]+\.)*[0-9]+).*/\1/p' "$@" | head -n1
}

# @description load color theme
# @noargs
# @env BASH_FRAMEWORK_THEME String theme to use
# @exitcode 0 always successful
UI::requireTheme() {
  UI::theme "${BASH_FRAMEWORK_THEME-default}"
}

# @description Display message using skip color (yellow)
# @arg $1 message:String the message to display
Log::displaySkipped() {
  if ((BASH_FRAMEWORK_DISPLAY_LEVEL >= __LEVEL_INFO)); then
    echo -e "${__SKIPPED_COLOR}SKIPPED - ${1}${__RESET_COLOR}" >&2
  fi
  Log::logSkipped "$1"
}

# @description ensure command realpath is available
# @exitcode 1 if realpath command not available
# @stderr diagnostics information is displayed
Linux::requireRealpathCommand() {
  Assert::commandExists realpath
}

# @description log message to file
# @arg $1 message:String the message to display
Log::logSkipped() {
  if ((BASH_FRAMEWORK_LOG_LEVEL >= __LEVEL_INFO)); then
    Log::logMessage "${2:-SKIPPED}" "$1"
  fi
}

# FUNCTIONS

facade_main_dbImportsh() {
BASH_TOOLS_ROOT_DIR="$(cd "${CURRENT_DIR}/.." && pwd -P)"
if [[ -d "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework/" ]]; then
  FRAMEWORK_ROOT_DIR="$(cd "${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework" && pwd -P)"
else
  # if the directory does not exist yet, give a value to FRAMEWORK_ROOT_DIR
  FRAMEWORK_ROOT_DIR="${BASH_TOOLS_ROOT_DIR}/vendor/bash-tools-framework"
fi
FRAMEWORK_SRC_DIR="${FRAMEWORK_ROOT_DIR}/src"
FRAMEWORK_BIN_DIR="${FRAMEWORK_ROOT_DIR}/bin"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_ROOT_DIR}/vendor"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_ROOT_DIR}/vendor/bin"

if [[ -f "${HOME}/.bash-tools/.env" ]]; then
  export BASH_FRAMEWORK_ENV_FILES=("${HOME}/.bash-tools/.env")
fi
# REQUIRES
Env::requireLoad
UI::requireTheme
Linux::requireRealpathCommand
Log::requireLoad
Compiler::Facade::requireCommandBinDir
Linux::requireExecutedAsUser

# @require Compiler::Facade::requireCommandBinDir
# shellcheck disable=SC2034

# default values
declare optionFromAws=""
declare optionSkipSchema="0"
declare targetDbName=""
declare fromDbName=""
declare optionProfile="default"
declare optionTables=""
declare profileCommandFile=""
declare optionTargetDsn=""
declare optionCharacterSet=""
declare defaultTargetCharacterSet=""

# other configuration
declare copyrightBeginYear="2020"
declare TIMEFORMAT='time spent : %3R'
declare DB_IMPORT_DUMP_DIR=${DB_IMPORT_DUMP_DIR%/}
declare PROFILES_DIR="${BASH_TOOLS_ROOT_DIR}/conf/dbImportProfiles"
declare HOME_PROFILES_DIR="${HOME}/.bash-tools/dbImportProfiles"
declare DOWNLOAD_DUMP=0

declare -a BASH_FRAMEWORK_ARGV_FILTERED=()

copyrightCallback() {
  if [[ -z "${copyrightBeginYear}" ]]; then
    copyrightBeginYear="$(date +%Y)"
  fi
  echo "Copyright (c) ${copyrightBeginYear}-now Fran√ßois Chastanet"
}

# shellcheck disable=SC2317 # if function is overridden
updateArgListInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--verbose)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(-vvv)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListEnvFileCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListLogLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListDisplayLevelCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListNoColorCallback() {
  BASH_FRAMEWORK_ARGV_FILTERED+=(--no-color)
}
# shellcheck disable=SC2317 # if function is overridden
updateArgListThemeCallback() { :; }
# shellcheck disable=SC2317 # if function is overridden
updateArgListQuietCallback() { :; }

# shellcheck disable=SC2317 # if function is overridden
optionHelpCallback() {
  dbImportCommand help
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionVersionCallback() {
  echo "${SCRIPT_NAME} version 2.0"
  exit 0
}

# shellcheck disable=SC2317 # if function is overridden
optionEnvFileCallback() {
  local envFile="$2"
  Log::displayWarning "Command ${SCRIPT_NAME} - Option --env-file is deprecated and will be removed in the future"
  if [[ ! -f "${envFile}" || ! -r "${envFile}" ]]; then
    Log::displayError "Command ${SCRIPT_NAME} - Option --env-file - File '${envFile}' doesn't exist"
    exit 1
  fi
}

# shellcheck disable=SC2317 # if function is overridden
optionInfoVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='--verbose'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_INFO}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_INFO}
}

# shellcheck disable=SC2317 # if function is overridden
optionDebugVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_DEBUG}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

# shellcheck disable=SC2317 # if function is overridden
optionTraceVerboseCallback() {
  BASH_FRAMEWORK_ARGS_VERBOSE_OPTION='-vvv'
  BASH_FRAMEWORK_ARGS_VERBOSE=${__VERBOSE_LEVEL_TRACE}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${__LEVEL_DEBUG}
}

getLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__LEVEL_OFF}"
      ;;
    ERROR)
      echo "${__LEVEL_ERROR}"
      ;;
    WARNING)
      echo "${__LEVEL_WARNING}"
      ;;
    INFO)
      echo "${__LEVEL_INFO}"
      ;;
    DEBUG | TRACE)
      echo "${__LEVEL_DEBUG}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

getVerboseLevel() {
  local levelName="$1"
  case "${levelName^^}" in
    OFF)
      echo "${__VERBOSE_LEVEL_OFF}"
      ;;
    ERROR | WARNING | INFO)
      echo "${__VERBOSE_LEVEL_INFO}"
      ;;
    DEBUG)
      echo "${__VERBOSE_LEVEL_DEBUG}"
      ;;
    TRACE)
      echo "${__VERBOSE_LEVEL_TRACE}"
      ;;
    *)
      Log::displayError "Command ${SCRIPT_NAME} - Invalid level ${level}"
      return 1
  esac
}

# shellcheck disable=SC2317 # if function is overridden
optionDisplayLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_DISPLAY_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogLevelCallback() {
  local level="$2"
  local logLevel verboseLevel
  logLevel="$(getLevel "${level}")"
  verboseLevel="$(getVerboseLevel "${level}")"
  BASH_FRAMEWORK_ARGS_VERBOSE=${verboseLevel}
  BASH_FRAMEWORK_LOG_LEVEL=${logLevel}
}

# shellcheck disable=SC2317 # if function is overridden
optionLogFileCallback() {
  local logFile="$2"
  BASH_FRAMEWORK_LOG_FILE="${logFile}"
}

# shellcheck disable=SC2317 # if function is overridden
optionQuietCallback() {
  BASH_FRAMEWORK_QUIET_MODE=1
}

# shellcheck disable=SC2317 # if function is overridden
optionNoColorCallback() {
  UI::theme "noColor"
}

# shellcheck disable=SC2317 # if function is overridden
optionThemeCallback() {
  UI::theme "$2"
}

displayConfig() {
  echo "Config"
  UI::drawLine "-"
  local var
  while read -r var; do
    printf '%-40s = %s\n' "${var}" "$(declare -p "${var}" | sed -E -e 's/^[^=]+=(.*)/\1/')"
  done < <(typeset -p | awk 'match($3, "^(BASH_FRAMEWORK_[^=]+)=", m) { print m[1] }' | sort)
  exit 0
}

optionBashFrameworkConfigCallback() {
  if [[ ! -f "$2" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Bash framework config file '$2' does not exists"
  fi
}

defaultFrameworkConfig="$(
  cat <<'EOF'
# copied from src/_includes/.framework-config.default
# shellcheck disable=SC2034

REAL_SCRIPT_FILE="${REAL_SCRIPT_FILE:-$(readlink -e "$(realpath "${BASH_SOURCE[0]}")")}"
FRAMEWORK_ROOT_DIR="${FRAMEWORK_ROOT_DIR:-$(cd "$(readlink -e "${REAL_SCRIPT_FILE%/*}")/../.." && pwd -P)}"
FRAMEWORK_SRC_DIR="${FRAMEWORK_SRC_DIR:-${FRAMEWORK_ROOT_DIR}/src}"
FRAMEWORK_BIN_DIR="${FRAMEWORK_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/bin}"
FRAMEWORK_VENDOR_DIR="${FRAMEWORK_VENDOR_DIR:-${FRAMEWORK_ROOT_DIR}/vendor}"
FRAMEWORK_VENDOR_BIN_DIR="${FRAMEWORK_VENDOR_BIN_DIR:-${FRAMEWORK_ROOT_DIR}/vendor/bin}"

# describe the functions that will be skipped from being imported
FRAMEWORK_FUNCTIONS_IGNORE_REGEXP="${FRAMEWORK_FUNCTIONS_IGNORE_REGEXP:-^(Namespace::functions|Functions::myFunction|Namespace::requireSomething|Acquire::ForceIPv4)$}"
# describe the files that do not contain function to be imported
NON_FRAMEWORK_FILES_REGEXP="${NON_FRAMEWORK_FILES_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/_binaries|^src/_includes|^src/batsHeaders.sh$|^src/_standalone)}"
# describe the files that are allowed to not have an associated bats file
BATS_FILE_NOT_NEEDED_REGEXP="${BATS_FILE_NOT_NEEDED_REGEXP:-(^bin/|.framework-config|.bats$|/testsData/|^manualTests/|/_.sh$|/ZZZ.sh$|/__all.sh$|^src/batsHeaders.sh$|^src/_includes)}"
# describe the files that are allowed to not have a function matching the filename
FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP="${FRAMEWORK_FILES_FUNCTION_MATCHING_IGNORE_REGEXP:-^bin/|^\.framework-config$|\.tpl$|/testsData/|^manualTests/|\.bats$}"
# Source directories
if [[ ! -v FRAMEWORK_SRC_DIRS ]]; then
  FRAMEWORK_SRC_DIRS=(
    "${FRAMEWORK_ROOT_DIR}/src"
  )
fi

# export here all the variables that will be used in your templates
export REPOSITORY_URL="${REPOSITORY_URL:-https://github.com/fchastanet/bash-tools-framework}"

BASH_FRAMEWORK_THEME="${BASH_FRAMEWORK_THEME:-default}"
BASH_FRAMEWORK_LOG_LEVEL="${BASH_FRAMEWORK_LOG_LEVEL:-0}"
BASH_FRAMEWORK_DISPLAY_LEVEL="${BASH_FRAMEWORK_DISPLAY_LEVEL:-3}"
BASH_FRAMEWORK_LOG_FILE="${BASH_FRAMEWORK_LOG_FILE:-${FRAMEWORK_ROOT_DIR}/logs/$(basename "$0").log}"
BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION="${BASH_FRAMEWORK_LOG_FILE_MAX_ROTATION:-5}"
EOF
)"

commandOptionParseFinished() {
  # load default template framework config
  # shellcheck disable=SC2034
  defaultEnvFile="${PERSISTENT_TMPDIR}/.framework-config"
  echo "${defaultFrameworkConfig}" > "${defaultEnvFile}"

  Env::requireLoad "${defaultEnvFile}"
  Log::requireLoad

  if [[ "${optionConfig}" = "1" ]]; then
    displayConfig
  fi
}

# default values
declare optionFromDsn=""

# default values
declare optionProfile="default"
declare optionTables=""
declare profileCommandFile=""

profileOptionHelpCallback() {
  echo "the name of the profile to use in order to include or exclude tables"
  echo "(if not specified in default.sh from 'User profiles directory' if exists or 'Default profiles directory')"
}

optionTablesCallback() {
  if [[ ! ${optionTables} =~ ^[A-Za-z0-9_]+(,[A-Za-z0-9_]+)*$ ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - Table list is not valid : ${optionTables}"
  fi
}

profileOptionCallback() {
  local -a profilesArray
  readarray -t profilesArray < <(Conf::getMergedList "dbImportProfiles" "sh" "" || true)
  if ! Array::contains "$2" "${profilesArray[@]}"; then
    Log::displayError "${SCRIPT_NAME} - invalid profile '$2' provided"
    return 1
  fi
}
initProfileCommandCallback() {
  if [[ "${optionProfile}" != "default" && -n "${optionTables}" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} - you cannot use table and profile options at the same time"
  fi

  # Profile selection
  local profileMsgInfo
  # shellcheck disable=SC2154
  if [[ "${optionProfile}" = 'default' && -n "${optionTables}" ]]; then
    profileCommandFile=$(Framework::createTempFile "profileCmd.XXXXXXXXXXXX")
    profileMsgInfo="only ${optionTables} will be imported"
    (
      echo '#!/usr/bin/env bash'
      if [[ -n "${optionTables}" ]]; then
        echo "${optionTables}" | sed -E 's/([A-Za-z0-9_]+),?/echo "\1"\n/g'
      else
        # tables option not specified, we will import all tables of the profile
        echo 'cat'
      fi
    ) >"${profileCommandFile}"
  else
    profileCommandFile="$(Conf::getAbsoluteFile "dbImportProfiles" "${optionProfile}" "sh")" || exit 1
    profileMsgInfo="Using profile ${profileCommandFile}"
  fi
  chmod +x "${profileCommandFile}"
  Log::displayInfo "${profileMsgInfo}"
}

declare optionTargetDsn="default.local"
declare optionCharacterSet=""
declare defaultTargetCharacterSet="utf8"

initializeDefaultTargetMysqlOptions() {
  local -n dbFromInstanceTargetMysql=$1
  local fromDbName="$2"

  # get remote db collation name
  if [[ -n ${optionCollationName+x} && -z "${optionCollationName}" ]]; then
    optionCollationName=$(Database::query dbFromInstanceTargetMysql \
      "SELECT default_collation_name FROM information_schema.SCHEMATA WHERE schema_name = \"${fromDbName}\";" "information_schema")
  fi

  # get remote db character set
  if [[ -z "${optionCharacterSet}" ]]; then
    optionCharacterSet=$(Database::query dbFromInstanceTargetMysql \
      "SELECT default_character_set_name FROM information_schema.SCHEMATA WHERE schema_name = \"${fromDbName}\";" "information_schema")
  fi
}

declare optionCollationName=""
declare defaultTargetCollationName="utf8_general_ci"

dbImportCommand() {
  local options_parse_cmd="$1"
  shift || true

  if [[ "${options_parse_cmd}" = "parse" ]]; then
    local -i options_parse_optionParsedCountOptionProfile
    ((options_parse_optionParsedCountOptionProfile = 0)) || true
    local -i options_parse_optionParsedCountOptionTables
    ((options_parse_optionParsedCountOptionTables = 0)) || true
    local -i options_parse_optionParsedCountOptionFromDsn
    ((options_parse_optionParsedCountOptionFromDsn = 0)) || true
    optionSkipSchema="0"
    local -i options_parse_optionParsedCountOptionSkipSchema
    ((options_parse_optionParsedCountOptionSkipSchema = 0)) || true
    local -i options_parse_optionParsedCountOptionFromAws
    ((options_parse_optionParsedCountOptionFromAws = 0)) || true
    local -i options_parse_optionParsedCountOptionTargetDsn
    ((options_parse_optionParsedCountOptionTargetDsn = 0)) || true
    local -i options_parse_optionParsedCountOptionCharacterSet
    ((options_parse_optionParsedCountOptionCharacterSet = 0)) || true
    local -i options_parse_optionParsedCountOptionCollationName
    ((options_parse_optionParsedCountOptionCollationName = 0)) || true
    local -i options_parse_optionParsedCountOptionBashFrameworkConfig
    ((options_parse_optionParsedCountOptionBashFrameworkConfig = 0)) || true
    optionConfig="0"
    local -i options_parse_optionParsedCountOptionConfig
    ((options_parse_optionParsedCountOptionConfig = 0)) || true
    optionInfoVerbose="0"
    local -i options_parse_optionParsedCountOptionInfoVerbose
    ((options_parse_optionParsedCountOptionInfoVerbose = 0)) || true
    optionDebugVerbose="0"
    local -i options_parse_optionParsedCountOptionDebugVerbose
    ((options_parse_optionParsedCountOptionDebugVerbose = 0)) || true
    optionTraceVerbose="0"
    local -i options_parse_optionParsedCountOptionTraceVerbose
    ((options_parse_optionParsedCountOptionTraceVerbose = 0)) || true
    optionNoColor="0"
    local -i options_parse_optionParsedCountOptionNoColor
    ((options_parse_optionParsedCountOptionNoColor = 0)) || true
    local -i options_parse_optionParsedCountOptionTheme
    ((options_parse_optionParsedCountOptionTheme = 0)) || true
    optionHelp="0"
    local -i options_parse_optionParsedCountOptionHelp
    ((options_parse_optionParsedCountOptionHelp = 0)) || true
    optionVersion="0"
    local -i options_parse_optionParsedCountOptionVersion
    ((options_parse_optionParsedCountOptionVersion = 0)) || true
    optionQuiet="0"
    local -i options_parse_optionParsedCountOptionQuiet
    ((options_parse_optionParsedCountOptionQuiet = 0)) || true
    local -i options_parse_optionParsedCountOptionLogLevel
    ((options_parse_optionParsedCountOptionLogLevel = 0)) || true
    local -i options_parse_optionParsedCountOptionLogFile
    ((options_parse_optionParsedCountOptionLogFile = 0)) || true
    local -i options_parse_optionParsedCountOptionDisplayLevel
    ((options_parse_optionParsedCountOptionDisplayLevel = 0)) || true
    local -i options_parse_argParsedCountFromDbName
    ((options_parse_argParsedCountFromDbName = 0)) || true
    local -i options_parse_argParsedCountTargetDbName
    ((options_parse_argParsedCountTargetDbName = 0)) || true
    # shellcheck disable=SC2034
    local -i options_parse_parsedArgIndex=0
    while (($# > 0)); do
      local options_parse_arg="$1"
      local argOptDefaultBehavior=0
      case "${options_parse_arg}" in
        # Option 1/22
        # Option optionProfile --profile|-p variableType String min 0 max 1 authorizedValues '' regexp ''
        --profile | -p)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionProfile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionProfile))
          # shellcheck disable=SC2034
          optionProfile="$1"
          profileOptionCallback "${options_parse_arg}" "${optionProfile}"
          ;;
        # Option 2/22
        # Option optionTables --tables variableType String min 0 max 1 authorizedValues '' regexp ''
        --tables)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTables >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTables))
          # shellcheck disable=SC2034
          optionTables="$1"
          optionTablesCallback "${options_parse_arg}" "${optionTables}"
          ;;
        # Option 3/22
        # Option optionFromDsn --from-dsn|-f variableType String min 0 max 1 authorizedValues '' regexp ''
        --from-dsn | -f)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionFromDsn >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionFromDsn))
          # shellcheck disable=SC2034
          optionFromDsn="$1"
          ;;
        # Option 4/22
        # Option optionSkipSchema --skip-schema|-s variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --skip-schema | -s)
          # shellcheck disable=SC2034
          optionSkipSchema="1"
          if ((options_parse_optionParsedCountOptionSkipSchema >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionSkipSchema))
          ;;
        # Option 5/22
        # Option optionFromAws --from-aws|-a variableType String min 0 max 1 authorizedValues '' regexp ''
        --from-aws | -a)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionFromAws >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionFromAws))
          # shellcheck disable=SC2034
          optionFromAws="$1"
          ;;
        # Option 6/22
        # Option optionTargetDsn --target-dsn|-t variableType String min 0 max 1 authorizedValues '' regexp ''
        --target-dsn | -t)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTargetDsn >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTargetDsn))
          # shellcheck disable=SC2034
          optionTargetDsn="$1"
          ;;
        # Option 7/22
        # Option optionCharacterSet --character-set|-c variableType String min 0 max 1 authorizedValues '' regexp ''
        --character-set | -c)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionCharacterSet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionCharacterSet))
          # shellcheck disable=SC2034
          optionCharacterSet="$1"
          ;;
        # Option 8/22
        # Option optionCollationName --collation-name|-o variableType String min 0 max 1 authorizedValues '' regexp ''
        --collation-name | -o)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionCollationName >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionCollationName))
          # shellcheck disable=SC2034
          optionCollationName="$1"
          ;;
        # Option 9/22
        # Option optionBashFrameworkConfig --bash-framework-config variableType String min 0 max 1 authorizedValues '' regexp ''
        --bash-framework-config)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionBashFrameworkConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionBashFrameworkConfig))
          # shellcheck disable=SC2034
          optionBashFrameworkConfig="$1"
          optionBashFrameworkConfigCallback "${options_parse_arg}" "${optionBashFrameworkConfig}"
          ;;
        # Option 10/22
        # Option optionConfig --config variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --config)
          # shellcheck disable=SC2034
          optionConfig="1"
          if ((options_parse_optionParsedCountOptionConfig >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionConfig))
          ;;
        # Option 11/22
        # Option optionInfoVerbose --verbose|-v variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --verbose | -v)
          # shellcheck disable=SC2034
          optionInfoVerbose="1"
          if ((options_parse_optionParsedCountOptionInfoVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionInfoVerbose))
          optionInfoVerboseCallback "${options_parse_arg}"
          updateArgListInfoVerboseCallback "${options_parse_arg}"
          ;;
        # Option 12/22
        # Option optionDebugVerbose -vv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vv)
          # shellcheck disable=SC2034
          optionDebugVerbose="1"
          if ((options_parse_optionParsedCountOptionDebugVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDebugVerbose))
          optionDebugVerboseCallback "${options_parse_arg}"
          updateArgListDebugVerboseCallback "${options_parse_arg}"
          ;;
        # Option 13/22
        # Option optionTraceVerbose -vvv variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        -vvv)
          # shellcheck disable=SC2034
          optionTraceVerbose="1"
          if ((options_parse_optionParsedCountOptionTraceVerbose >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTraceVerbose))
          optionTraceVerboseCallback "${options_parse_arg}"
          updateArgListTraceVerboseCallback "${options_parse_arg}"
          ;;
        # Option 14/22
        # Option optionEnvFiles --env-file variableType StringArray min 0 max -1 authorizedValues '' regexp ''
        --env-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionEnvFiles))
          optionEnvFiles+=("$1")
          optionEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          updateArgListEnvFileCallback "${options_parse_arg}" "${optionEnvFiles[@]}"
          ;;
        # Option 15/22
        # Option optionNoColor --no-color variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --no-color)
          # shellcheck disable=SC2034
          optionNoColor="1"
          if ((options_parse_optionParsedCountOptionNoColor >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionNoColor))
          optionNoColorCallback "${options_parse_arg}"
          updateArgListNoColorCallback "${options_parse_arg}"
          ;;
        # Option 16/22
        # Option optionTheme --theme variableType String min 0 max 1 authorizedValues 'default|default-force|noColor' regexp ''
        --theme)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ default|default-force|noColor ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(default|default-force|noColor)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionTheme >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionTheme))
          # shellcheck disable=SC2034
          optionTheme="$1"
          optionThemeCallback "${options_parse_arg}" "${optionTheme}"
          updateArgListThemeCallback "${options_parse_arg}" "${optionTheme}"
          ;;
        # Option 17/22
        # Option optionHelp --help|-h variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --help | -h)
          # shellcheck disable=SC2034
          optionHelp="1"
          if ((options_parse_optionParsedCountOptionHelp >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionHelp))
          optionHelpCallback "${options_parse_arg}"
          ;;
        # Option 18/22
        # Option optionVersion --version variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --version)
          # shellcheck disable=SC2034
          optionVersion="1"
          if ((options_parse_optionParsedCountOptionVersion >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionVersion))
          optionVersionCallback "${options_parse_arg}"
          ;;
        # Option 19/22
        # Option optionQuiet --quiet|-q variableType Boolean min 0 max 1 authorizedValues '' regexp ''
        --quiet | -q)
          # shellcheck disable=SC2034
          optionQuiet="1"
          if ((options_parse_optionParsedCountOptionQuiet >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionQuiet))
          optionQuietCallback "${options_parse_arg}"
          updateArgListQuietCallback "${options_parse_arg}"
          ;;
        # Option 20/22
        # Option optionLogLevel --log-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --log-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogLevel))
          # shellcheck disable=SC2034
          optionLogLevel="$1"
          optionLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          updateArgListLogLevelCallback "${options_parse_arg}" "${optionLogLevel}"
          ;;
        # Option 21/22
        # Option optionLogFile --log-file variableType String min 0 max 1 authorizedValues '' regexp ''
        --log-file)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionLogFile >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionLogFile))
          # shellcheck disable=SC2034
          optionLogFile="$1"
          optionLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          updateArgListLogFileCallback "${options_parse_arg}" "${optionLogFile}"
          ;;
        # Option 22/22
        # Option optionDisplayLevel --display-level variableType String min 0 max 1 authorizedValues 'OFF|ERROR|WARNING|INFO|DEBUG|TRACE' regexp ''
        --display-level)
          shift
          if (($# == 0)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - a value needs to be specified"
            return 1
          fi
          if [[ ! "$1" =~ OFF|ERROR|WARNING|INFO|DEBUG|TRACE ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - value '$1' is not part of authorized values(OFF|ERROR|WARNING|INFO|DEBUG|TRACE)"
            return 1
          fi
          if ((options_parse_optionParsedCountOptionDisplayLevel >= 1)); then
            Log::displayError "Command ${SCRIPT_NAME} - Option ${options_parse_arg} - Maximum number of option occurrences reached(1)"
            return 1
          fi
          ((++options_parse_optionParsedCountOptionDisplayLevel))
          # shellcheck disable=SC2034
          optionDisplayLevel="$1"
          optionDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          updateArgListDisplayLevelCallback "${options_parse_arg}" "${optionDisplayLevel}"
          ;;
        -*)
          if [[ "${argOptDefaultBehavior}" = "0" ]]; then
            Log::displayError "Command ${SCRIPT_NAME} - Invalid option ${options_parse_arg}"
            return 1
          fi
          ;;
        *)
          if ((0)); then
            # Technical if - never reached
            :
          # Argument 1/2
          # Argument fromDbName min 1 max 1 authorizedValues '' regexp ''
          elif ((options_parse_parsedArgIndex >= 0 && options_parse_parsedArgIndex < 1)); then
            if ((options_parse_argParsedCountFromDbName >= 1)); then
              Log::displayError "Command ${SCRIPT_NAME} - Argument fromDbName - Maximum number of argument occurrences reached(1)"
              return 1
            fi
            ((++options_parse_argParsedCountFromDbName))
            # shellcheck disable=SC2034
            fromDbName="${options_parse_arg}"
          # Argument 2/2
          # Argument targetDbName min 0 max 1 authorizedValues '' regexp ''
          elif ((options_parse_parsedArgIndex >= 1 && options_parse_parsedArgIndex < 2)); then
            if ((options_parse_argParsedCountTargetDbName >= 1)); then
              Log::displayError "Command ${SCRIPT_NAME} - Argument targetDbName - Maximum number of argument occurrences reached(1)"
              return 1
            fi
            ((++options_parse_argParsedCountTargetDbName))
            # shellcheck disable=SC2034
            targetDbName="${options_parse_arg}"
          else
            if [[ "${argOptDefaultBehavior}" = "0" ]]; then
              Log::displayError "Command ${SCRIPT_NAME} - Argument - too much arguments provided: $*"
              return 1
            fi
          fi
          ((++options_parse_parsedArgIndex))
          ;;
      esac
      shift || true
    done
    if ((options_parse_argParsedCountFromDbName < 1)); then
      Log::displayError "Command ${SCRIPT_NAME} - Argument 'fromDbName' should be provided at least 1 time(s)"
      return 1
    fi
    commandOptionParseFinished
    initProfileCommandCallback
    dbImportCommandCallback
    Log::displayDebug "Command ${SCRIPT_NAME} - parse arguments: ${BASH_FRAMEWORK_ARGV[*]}"
    Log::displayDebug "Command ${SCRIPT_NAME} - parse filtered arguments: ${BASH_FRAMEWORK_ARGV_FILTERED[*]}"
  elif [[ "${options_parse_cmd}" = "help" ]]; then
    echo -e "$(Array::wrap " " 80 0 "${__HELP_TITLE_COLOR}DESCRIPTION:${__RESET_COLOR}" "Import source db into target db using eventual table filter")"
    echo

    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" "${SCRIPT_NAME}" "[OPTIONS]" "[ARGUMENTS]")"
    echo -e "$(Array::wrap " " 80 2 "${__HELP_TITLE_COLOR}USAGE:${__RESET_COLOR}" \
      "${SCRIPT_NAME}" \
      "[--profile|-p <String>]" "[--tables <tablesSeparatedByComma>]" "[--from-dsn|-f <String>]" "[--skip-schema|-s]" "[--from-aws|-a <awsFile>]" "[--target-dsn|-t <targetDsn>]" "[--character-set|-c <String>]" "[--collation-name|-o <String>]" "[--bash-framework-config <String>]" "[--config]" "[--verbose|-v]" "[-vv]" "[-vvv]" "[--env-file <String>]" "[--no-color]" "[--theme <String>]" "[--help|-h]" "[--version]" "[--quiet|-q]" "[--log-level <String>]" "[--log-file <String>]" "[--display-level <String>]")"
    echo
    echo -e "${__HELP_TITLE_COLOR}ARGUMENTS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}fromDbName${__HELP_NORMAL} {single} (mandatory)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(the\ name\ of\ the\ source/remote\ database)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  [${__HELP_OPTION_COLOR}targetDbName${__HELP_NORMAL} {single}]"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(the\ name\ of\ the\ target\ database\,\ use\ fromDbName\(without\ extension\)\ if\ not\ provided)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}PROFILE OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--profile${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-p <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054,SC2206
    mapfile -t helpArray < <(profileOptionHelpCallback)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--tables <tablesSeparatedByComma>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(import\ only\ table\ specified\ in\ the\ list.\ \ If\ aws\ mode\,\ ignore\ profile\ option)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}FROM OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--from-dsn${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-f <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=($'dsn to use for source database\n\\n  this option is incompatible with -a|--from-aws option')
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--skip-schema${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-s${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(avoid\ to\ import\ the\ schema)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--from-aws${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-a <awsFile>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(db\ dump\ will\ be\ downloaded\ from\ s3\ instead\ of\ using\ remote\ db.\ The\ value\ \<awsFile\>\ is\ the\ name\ of\ the\ file\ without\ s3\ location\ \(Only\ .gz\ or\ tar.gz\ file\ are\ supported\).\ This\ option\ is\ incompatible\ with\ -f\|--from-dsn\ option)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}TARGET OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--target-dsn${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-t <targetDsn>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(dsn\ to\ use\ for\ target\ database\ \(Default:\ default.local\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--character-set${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-c <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(change\ the\ character\ set\ used\ during\ database\ creation\ \(default\ value:\ utf8\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--collation-name${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-o <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(change\ the\ collation\ name\ used\ during\ database\ creation\ \(default\ value:\ utf8_general_ci\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo
    echo -e "${__HELP_TITLE_COLOR}GLOBAL OPTIONS:${__RESET_COLOR}"
    echo -e "  ${__HELP_OPTION_COLOR}--bash-framework-config <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(use\ alternate\ bash\ framework\ configuration.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--config${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ configuration)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--verbose${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-v${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(info\ level\ verbose\ mode\ \(alias\ of\ --display-level\ INFO\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(debug\ level\ verbose\ mode\ \(alias\ of\ --display-level\ DEBUG\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}-vvv${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(trace\ level\ verbose\ mode\ \(alias\ of\ --display-level\ TRACE\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--env-file <String>${__HELP_NORMAL} {list} (optional)"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Load\ the\ specified\ env\ file\ \(deprecated\,\ please\ use\ --bash-framework-config\ option\ instead\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--no-color${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Produce\ monochrome\ output.\ alias\ of\ --theme\ noColor.)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--theme <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(choose\ color\ theme\ \(default\,\ default-force\ or\ noColor\)\ -\ default-force\ means\ colors\ will\ be\ produced\ even\ if\ command\ is\ piped)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--help${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-h${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Display\ this\ command\ help)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--version${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Print\ version\ information\ and\ quit)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--quiet${__HELP_NORMAL}, ${__HELP_OPTION_COLOR}-q${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(quiet\ mode\,\ doesn\'t\ display\ any\ output)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--log-file <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(Set\ log\ file)
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e "  ${__HELP_OPTION_COLOR}--display-level <String>${__HELP_NORMAL} {single}"
    local -a helpArray
    # shellcheck disable=SC2054
    helpArray=(set\ display\ level\ \(one\ of\ OFF\,\ ERROR\,\ WARNING\,\ INFO\,\ DEBUG\,\ TRACE\ value\))
    echo -e "    $(Array::wrap " " 76 4 "${helpArray[@]}")"
    echo -e """
${__HELP_TITLE}Default profiles directory:${__HELP_NORMAL}
${PROFILES_DIR-configuration error}

${__HELP_TITLE}User profiles directory:${__HELP_NORMAL}
${HOME_PROFILES_DIR-configuration error}
Allows to override profiles defined in "Default profiles directory"

${__HELP_TITLE}List of available profiles:${__HELP_NORMAL}
${profilesList}

${__HELP_TITLE}List of available dsn:${__HELP_NORMAL}
${dsnList}

${__HELP_TITLE}Aws s3 location:${__HELP_NORMAL}
${S3_BASE_URL}

${__HELP_TITLE}Example 1: from one database to another one${__HELP_NORMAL}
${__HELP_EXAMPLE}TODO${__HELP_NORMAL}

${__HELP_TITLE}Example 2: import from S3${__HELP_NORMAL}
${__HELP_EXAMPLE}TODO${__HELP_NORMAL}"""
    echo
    echo -n -e "${__HELP_TITLE_COLOR}VERSION: ${__RESET_COLOR}"
    echo '2.0'
    echo
    echo -e "${__HELP_TITLE_COLOR}AUTHOR:${__RESET_COLOR}"
    echo '[Fran√ßois Chastanet](https://github.com/fchastanet)'
    echo
    echo -e "${__HELP_TITLE_COLOR}SOURCE FILE:${__RESET_COLOR}"
    echo 'https://github.com/fchastanet/bash-tools/tree/master/src/_binaries/DbImport/dbImport.sh'
    echo
    echo -e "${__HELP_TITLE_COLOR}LICENSE:${__RESET_COLOR}"
    echo 'MIT License'
    echo
    Array::wrap ' ' 76 4 "$(copyrightCallback)"
  else
    Log::displayError "Command ${SCRIPT_NAME} - Option command invalid: '${options_parse_cmd}'"
    return 1
  fi
}

optionHelpCallback() {
  local profilesList=""
  local dsnList=""
  dsnList="$(Conf::getMergedList "dsn" "env")"
  profilesList="$(Conf::getMergedList "dbImportProfiles" "sh" || true)"

  dbImportCommand help | envsubst
  exit 0
}

dbImportCommandCallback() {
  if [[ -z "${targetDbName}" ]]; then
    targetDbName="${fromDbName}"
  fi

  if [[ -n "${optionFromAws}" ]]; then
    Assert::commandExists aws \
      "Command ${SCRIPT_NAME} - missing aws, please check https://docs.aws.amazon.com/fr_fr/cli/latest/userguide/install-cliv2.html" || exit 1

    if [[ -n "${optionFromDsn}" ]]; then
      Log::fatal "Command ${SCRIPT_NAME} - you cannot use from-dsn and from-aws at the same time"
    fi

    if [[ -z "${S3_BASE_URL}" ]]; then
      Log::fatal "Command ${SCRIPT_NAME} - missing S3_BASE_URL, please provide a value in .env file"
    fi
  elif [[ -z "${optionFromDsn}" ]]; then
    # default value for FROM_DSN if from-aws not set
    optionFromDsn=""
  fi

  if [[ -z "${DB_IMPORT_DUMP_DIR}" ]]; then
    Log::fatal "Command ${SCRIPT_NAME} -you have to specify a value for DB_IMPORT_DUMP_DIR env variable"
  fi

  if [[ ! -d "${DB_IMPORT_DUMP_DIR}" ]]; then
    mkdir -p "${DB_IMPORT_DUMP_DIR}" ||
      Log::fatal "Command ${SCRIPT_NAME} -impossible to create directory ${DB_IMPORT_DUMP_DIR} specified by DB_IMPORT_DUMP_DIR env variable"
  fi
}

dbImportCommand parse "${BASH_FRAMEWORK_ARGV[@]}"

# dump header/footer
read -r -d '\0' DUMP_HEADER <<-EOM
    SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS = 0;
    SET @OLD_AUTOCOMMIT=@@AUTOCOMMIT, AUTOCOMMIT = 0;
    SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS = 0;\0
EOM

read -r -d '\0' DUMP_FOOTER <<-EOM2
    COMMIT;
    SET AUTOCOMMIT=@OLD_AUTOCOMMIT;
    SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
    SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;\0
EOM2

declare DUMP_SIZE_QUERY
DUMP_SIZE_QUERY="$(
  cat <<'EOF'
SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 0) AS size
FROM information_schema.TABLES WHERE table_schema='${fromDbName}'
AND table_name IN(${listTablesDumpSize}, 'dummy')
GROUP BY table_schema
EOF
)"

# @require Linux::requireExecutedAsUser
run() {

  # check dependencies
  Assert::commandExists mysql "sudo apt-get install -y mysql-client"
  Assert::commandExists mysqlshow "sudo apt-get install -y mysql-client"
  Assert::commandExists mysqldump "sudo apt-get install -y mysql-client"
  Assert::commandExists pv "sudo apt-get install -y pv"
  Assert::commandExists gawk "sudo apt-get install -y gawk"
  Assert::commandExists awk "sudo apt-get install -y gawk"
  Version::checkMinimal "gawk" "--version" "5.0.1"

  # create db instances
  declare -Agx dbFromInstance dbTargetDatabase

  # shellcheck disable=SC2154
  Database::newInstance dbTargetDatabase "${optionTargetDsn}"
  # shellcheck disable=SC2154
  Database::setQueryOptions dbTargetDatabase "${dbTargetDatabase[QUERY_OPTIONS]} --connect-timeout=5"
  Log::displayInfo "Using target dsn ${dbTargetDatabase['DSN_FILE']}"
  if [[ -z "${optionFromAws}" ]]; then
    # shellcheck disable=SC2154
    Database::newInstance dbFromInstance "${optionFromDsn}"
    Database::setQueryOptions dbFromInstance "${dbFromInstance[QUERY_OPTIONS]} --connect-timeout=5"
    Log::displayInfo "Using from dsn ${dbFromInstance['DSN_FILE']}"
  fi

  local remoteDbDumpTempFile
  local remoteDbStructureDumpTempFile
  if [[ -n "${optionFromAws}" ]]; then
    remoteDbDumpTempFile="${DB_IMPORT_DUMP_DIR}/${optionFromAws}"
  else
    # shellcheck disable=SC2154
    remoteDbDumpTempFile="${DB_IMPORT_DUMP_DIR}/${fromDbName}_${optionProfile}.sql.gz"
    remoteDbStructureDumpTempFile="${DB_IMPORT_DUMP_DIR}/${fromDbName}_${optionProfile}_structure.sql.gz"
  fi

  # check if local dump exists
  local downloadDump=0
  if [[ ! -f "${remoteDbDumpTempFile}" ]]; then
    Log::displayInfo "local dump does not exist"
    downloadDump=1
  fi
  if [[ -z "${optionFromAws}" && ! -f "${remoteDbStructureDumpTempFile}" ]]; then
    Log::displayInfo "local structure dump does not exist"
    downloadDump=1
  fi
  if [[ "${downloadDump}" = "0" ]]; then
    Log::displayInfo "local dump ${remoteDbDumpTempFile} already exists, avoid download"
  fi

  Log::displayInfo "tables list will calculated using profile ${optionProfile} => ${profileCommandFile}"
  SECONDS=0
  if [[ "${downloadDump}" = "1" ]]; then
    Log::displayInfo "Download dump"

    if [[ -n "${optionFromAws}" ]]; then
      # download dump from s3
      local s3Url="${S3_BASE_URL%/}/${optionFromAws}"
      aws s3 ls --human-readable "${s3Url}" || {
        Log::fatal "Command ${SCRIPT_NAME} - unable to get information on S3 object : ${s3Url}"
      }
      Log::displayInfo "Download dump from ${s3Url} ..."
      TMPDIR="${TMDIR:-/tmp}" aws s3 cp "${s3Url}" "${remoteDbDumpTempFile}" || {
        Log::fatal "Command ${SCRIPT_NAME} - unable to download dump from S3 : ${s3Url}"
      }
    else
      # check if remote db exists
      Database::ifDbExists dbFromInstance "${fromDbName}" || {
        Log::fatal "Command ${SCRIPT_NAME} - Remote Database ${fromDbName} does not exist"
      }

      initializeDefaultTargetMysqlOptions dbFromInstance "${fromDbName}"

      local dumpHeader
      dumpHeader=$(printf "%s\nSET names '%s';\n" "${DUMP_HEADER}" "${optionCharacterSet}")

      # calculate remote db dump size
      local listTables
      local listTablesDumpSize
      local listTablesDump
      listTables="$(Database::query dbFromInstance "show tables" "${fromDbName}" | ${profileCommandFile} | sort)"
      # shellcheck disable=SC2034 # used by DUMP_SIZE_QUERY
      listTablesDumpSize="$(echo "${listTables}" | awk -v d="," -v q="'" '{s=(NR==1?s:s d)q $0 q}END{print s }')"
      listTablesDump=$(echo "${listTables}" | awk -v d=" " -v q="" '{s=(NR==1?s:s d)q $0 q}END{print s }')

      Log::displayInfo "Calculate dump size for tables ${listTablesDump}"
      local remoteDbDumpSize
      remoteDbDumpSize=$(echo "${DUMP_SIZE_QUERY}" | envsubst | Database::query dbFromInstance)
      if [[ -z "${remoteDbDumpSize}" ]]; then
        # could occur with the none profile
        remoteDbDumpSize="0"
      fi

      # dump db
      Log::displayInfo "Dump the database ${fromDbName} (Size:${remoteDbDumpSize}MB) ..."
      local dumpSizePvEstimation
      dumpSizePvEstimation=$(awk "BEGIN {printf \"%.0f\",${remoteDbDumpSize}/1.5}")
      time (
        echo "${dumpHeader}"
        Database::dump dbFromInstance "${fromDbName}" "${listTablesDump}" \
          --no-create-info --skip-add-drop-table --single-transaction=TRUE |
          pv --progress --size "${dumpSizePvEstimation}m"
        echo "${DUMP_FOOTER}"
      ) | gzip >"${remoteDbDumpTempFile}"

      Log::displayInfo "Dump structure of the database ${fromDbName} ..."
      time (
        echo "${dumpHeader}"
        #shellcheck disable=SC2016
        Database::dump dbFromInstance "${fromDbName}" "" \
          --no-data --skip-add-drop-table --single-transaction=TRUE |
          sed 's/^CREATE TABLE `/CREATE TABLE IF NOT EXISTS `/g'
        echo "${DUMP_FOOTER}"
      ) | gzip >"${remoteDbStructureDumpTempFile}"
    fi
    Log::displayInfo "Dump done."
  fi

  # mark dumps as modified now to avoid them to be garbage collected
  touch -c -m "${remoteDbDumpTempFile}" || true
  touch -c -m "${remoteDbStructureDumpTempFile}" || true

  # TODO Collation and character set should be retrieved from dump files if possible
  # shellcheck disable=SC2154
  local targetCollationName="${optionCollationName:-${defaultTargetCollationName}}"
  # shellcheck disable=SC2154
  local targetCharacterSet="${optionCharacterSet:-${defaultTargetCharacterSet}}"

  # shellcheck disable=SC2154
  Log::displayInfo "create target database ${targetDbName} if needed"
  #shellcheck disable=SC2016
  Database::query dbTargetDatabase \
    "$(printf 'CREATE DATABASE IF NOT EXISTS `%s` CHARACTER SET "%s" COLLATE "%s"' "${targetDbName}" "${targetCharacterSet}" "${targetCollationName}")"

  if [[ -z "${optionFromAws}" ]]; then
    Database::setQueryOptions dbTargetDatabase "${dbTargetDatabase['DB_IMPORT_OPTIONS']}"
    Log::displayInfo "Importing remote db '${fromDbName}' to local db '${targetDbName}'"
    # shellcheck disable=SC2154
    if [[ "${optionSkipSchema}" = "1" ]]; then
      Log::displayInfo "avoid to create db structure"
    else
      Log::displayInfo "create db structure from ${remoteDbStructureDumpTempFile}"
      time (
        pv "${remoteDbStructureDumpTempFile}" | zcat |
          Database::query dbTargetDatabase "" "${targetDbName}"
      )
    fi
  fi
  Log::displayInfo "import remote to local from file ${remoteDbDumpTempFile}"
  local -a dbImportStreamOptions=(
    --profile "${optionProfile}"
    --target-dsn "${optionTargetDsn}"
    --character-set "${targetCharacterSet}"
  )
  if [[ -n "${optionTables:-}" ]]; then
    dbImportStreamOptions+=(
      --tables "${optionTables}"
    )
  fi
  time (
    "${CURRENT_DIR}/dbImportStream" \
      "${dbImportStreamOptions[@]}" \
      "${remoteDbDumpTempFile}" \
      "${targetDbName}"

  )

  # garbage collect db import dumps
  File::garbageCollect "${DB_IMPORT_DUMP_DIR}" "${DB_IMPORT_GARBAGE_COLLECT_DAYS:-+30}" || true

  Log::displayInfo "Import database duration : $(date -u -d "@${SECONDS}" +"%T")"
}

if [[ "${BASH_FRAMEWORK_QUIET_MODE:-0}" = "1" ]]; then
  run &>/dev/null
else
  run
fi

}

facade_main_dbImportsh "$@"
