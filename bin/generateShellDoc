#!/usr/bin/env bash

#####################################
# GENERATED FILE FROM src/build/generateShellDoc.sh
# DO NOT EDIT IT
#####################################

# shellcheck disable=SC2034
SCRIPT_NAME=${0##*/}
# shellcheck disable=SC2034
CURRENT_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
BIN_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
ROOT_DIR="$(cd "${BIN_DIR}/.." && pwd -P)"
# shellcheck disable=SC2034
SRC_DIR="${ROOT_DIR}/src"
# shellcheck disable=SC2034
VENDOR_DIR="${ROOT_DIR}/vendor"
# shellcheck disable=SC2034
VENDOR_BIN_DIR="${ROOT_DIR}/vendor/bin"
export PATH="${BIN_DIR}":"${VENDOR_BIN_DIR}":${PATH}

# shellcheck disable=SC2034
TMPDIR="$(mktemp -d -p "${TMPDIR:-/tmp}" -t bash-framework-$$-XXXXXX)"
export TMPDIR

# temp dir cleaning
cleanOnExit() {
  rm -Rf "${TMPDIR}" >/dev/null 2>&1
}
trap cleanOnExit EXIT HUP QUIT ABRT TERM

# @see https://unix.stackexchange.com/a/386856
interruptManagement() {
  # restore SIGINT handler
  trap - INT
  # ensure that Ctrl-C is trapped by this script and not by sub process
  # report to the parent that we have indeed been interrupted
  kill -s INT "$$"
}
trap interruptManagement INT

# shellcheck disable=SC2034
((failures = 0)) || true

shopt -s expand_aliases

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

export TERM=xterm-256color

#avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# FUNCTIONS

# Display message using warning color (yellow)
# @param {String} $1 message
Log::displayWarning() {
  echo -e "${__WARNING_COLOR}WARN    - ${1}${__RESET_COLOR}" >&2
}

# Public: shallow clone a repository at specific commit sha, tag or branch
# or update repo if already exists
#
# **Arguments**:
# * $1 repository
# * $2 Install dir
# * $3 revision commit sha, tag or branch
# * $4 put "FORCE_DELETION" to force directory deletion if directory exists and it's not a git repository (default: 0)
#     USE THIS OPTION WITH CAUTION !!! as the directory will be deleted without any prompt
#
# **Return**:
# * code !=0 if git failure or directory not writable
# * code=1 if destination dir already exists and force option is not 1
Git::shallowClone() {
  local REPO="$1"
  local INSTALL_DIR="$2"
  local REVISION="$3"
  local FORCE_DELETION="${4:-0}"

  if [[ -d "${INSTALL_DIR}/.git" ]]; then
    Log::displayInfo "Repository ${INSTALL_DIR} already installed"
  else
    if [[ -f "${INSTALL_DIR}" || -d "${INSTALL_DIR}" ]]; then
      if [[ "${FORCE_DELETION}" = "FORCE_DELETION" ]]; then
        Log::displayWarning "Removing ${INSTALL_DIR} ..."
        rm -Rf "${INSTALL_DIR}" || exit 1
      else
        Log::displayError "Destination ${INSTALL_DIR} already exists, use force option to automatically delete the destination"
        return 1
      fi
    fi
    (
      Log::displayInfo "Installing ${INSTALL_DIR} ..."
      mkdir -p "${INSTALL_DIR}"
      cd "${INSTALL_DIR}" || exit 1
      git init >&2
      git remote add origin "${REPO}" >&2
    )
  fi
  (
    cd "${INSTALL_DIR}" || exit 1
    git -c advice.detachedHead=false fetch --progress --depth 1 origin "${REVISION}" >&2
    git reset --hard FETCH_HEAD >&2
  )
}

ShellDoc::installRequirementsIfNeeded() {
  local tomDocInstalled
  tomDocInstalled="$(cat "${BASH_FRAMEWORK_TOMDOC_INSTALLED}")"
  if [[ "${tomDocInstalled}" != "1" ]]; then
    (Log::displayInfo "Check if tomdoc.sh is up to date")
    if Git::shallowClone \
      "https://github.com/fchastanet/tomdoc.sh.git" \
      "${VENDOR_DIR}/fchastanet.tomdoc.sh" \
      "master" \
      "FORCE_DELETION"; then
      echo "1" >"${BASH_FRAMEWORK_TOMDOC_INSTALLED}"
    else
      Log::fatal "unable to install tomdoc.sh library"
    fi
  fi
}

# extract shDoc from file
#
# @param {String} $1 currentDir
# @param {String} $2 relativeFile
# @output the shell documentation in markdown format
ShellDoc::generateShellDoc() {
  local currentDir="$1"
  local relativeFile="$2"

  ShellDoc::installRequirementsIfNeeded
  (
    cd "${currentDir}" || exit 1
    "${ROOT_DIR}/vendor/fchastanet.tomdoc.sh/tomdoc.sh" "${relativeFile}"
  )
}

# Display message using error color (red)
# @param {String} $1 message
Log::displayError() {
  echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}" >&2
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayInfo() {
  echo -e "${__INFO_COLOR}INFO    - ${1}${__RESET_COLOR}" >&2
}

# add reference to index file
# @param {String} $1 indexFile
# @param {String} $2 mdRelativeFile
# @param {String} $3 title
ShellDoc::appendDocToIndex() {
  local indexFile="$1"
  local mdRelativeFile="$2"
  local title="$3"

  echo "* [${title}](${mdRelativeFile})" >>"${indexFile}"
}

# generate shell doc file
#
# @param {String} $1 currentDir
# @param {String} $2 relativeFile the file from which the markdown file will be generated
# @param {String} $3 targetDocFile the markdown file generated using tomdoc
# @return 0 if file has been generated, 1 if file is empty or error
# if generated doc is empty, targetDocFile is deleted if it was existing
ShellDoc::generateShellDocFile() {
  local currentDir="$1"
  local relativeFile="$2"
  local targetDocFile="$3"

  (
    local doc
    doc="$(ShellDoc::generateShellDoc "${currentDir}" "${relativeFile}")"
    if [[ -n "${doc}" ]]; then
      echo "${doc}" >"${targetDocFile}"
      return 0
    else
      # empty doc
      rm -f "${targetDocFile}" || true
      return 1
    fi
  )
}

# Checks if file can be created in folder
# The file does not need to exist
Assert::fileWritable() {
  local file="$1"
  local dir
  dir="$(dirname "${file}")"

  [[ -w "${dir}" ]]
}

if [[ -t 1 || -t 2 ]]; then
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR='\e[31m'      # Red
  readonly __INFO_COLOR='\e[44m'       # white on lightBlue
  readonly __SUCCESS_COLOR='\e[32m'    # Green
  readonly __WARNING_COLOR='\e[33m'    # Yellow
  readonly __TEST_COLOR='\e[100m'      # Light magenta
  readonly __TEST_ERROR_COLOR='\e[41m' # white on red
  readonly __SKIPPED_COLOR='\e[33m'    # Yellow
  readonly __DEBUG_COLOR='\e[37m'      # Grey
  # Internal: reset color
  readonly __RESET_COLOR='\e[0m' # Reset Color
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_EXAMPLE="$(echo -e "\e[1;30m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_TITLE="$(echo -e "\e[1;37m")"
  # shellcheck disable=SC2155,SC2034
  readonly __HELP_NORMAL="$(echo -e "\033[0m")"
else
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  readonly __ERROR_COLOR=''
  readonly __INFO_COLOR=''
  readonly __SUCCESS_COLOR=''
  readonly __WARNING_COLOR=''
  readonly __SKIPPED_COLOR=''
  readonly __TEST_COLOR=''
  readonly __TEST_ERROR_COLOR=''
  readonly __DEBUG_COLOR=''
  # Internal: reset color
  readonly __RESET_COLOR=''
  readonly __HELP_EXAMPLE=''
  readonly __HELP_TITLE=''
  readonly __HELP_NORMAL=''
fi
export __ERROR_COLOR
export __INFO_COLOR
export __SUCCESS_COLOR
export __WARNING_COLOR
export __SKIPPED_COLOR
export __TEST_COLOR
export __TEST_ERROR_COLOR
export __SKIPPED_COLOR
export __DEBUG_COLOR
export __RESET_COLOR
export __HELP_EXAMPLE
export __HELP_TITLE
export __HELP_NORMAL

# Display message using error color (red) and exit immediately with error status 1
# @param {String} $1 message
Log::fatal() {
  echo -e "${__ERROR_COLOR}FATAL   - ${1}${__RESET_COLOR}" >&2
  exit 1
}

# shellcheck disable=SC2034
BASH_FRAMEWORK_TOMDOC_INSTALLED=$(mktemp -p "${TMPDIR:-/tmp}" -t tomdocInstalled.XXXX)

# generate doc + index
# @param {String} $1 fromDir
# @param {String} $2 docDir
# @param {String} $3 indexFile
ShellDoc::generateShellDocsFromDir() {
  local fromDir="$1"
  local docDir="$2"
  local indexFile="$3"

  while IFS= read -r relativeFile; do
    relativeFile="${relativeFile#./}"
    local basenameNoExtension="${relativeFile%.*}"
    local targetDocFile="${docDir}/${basenameNoExtension}.md"
    local targetDocDir

    # create target doc dir
    targetDocDir="$(dirname "${targetDocFile}")"
    mkdir -p "${targetDocDir}" || {
      Log::displayError "unable to create target doc directory ${targetDocDir}"
      return 1
    }

    # generate markdown file from shell file
    Log::displayInfo "generate markdown doc for ${relativeFile} in ${targetDocFile}"

    if ShellDoc::generateShellDocFile "${fromDir}" "${relativeFile}" "${targetDocFile}"; then
      ShellDoc::appendDocToIndex "${indexFile}" "${relativeFile}" "${basenameNoExtension}"
    fi
  done < <(cd "${fromDir}" && find . -name "*.sh" | sort)
}

# Usage info
showHelp() {
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} find all .sh files and generate shDoc
in markdown format in the specified target directory

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} {fromDir} {docDir} {indexFile}

  --help,-h : prints this help and exits
  fromDir   : directory from which sh files will be searched
  docDir    : target doc directory
  indexFile : the markdown index file
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help -o h -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done

if (($# != 3)); then
  Log::fatal "yous should provide exactly 3 parameters"
fi

declare fromDir="$1"
declare docDir="$2"
declare indexFile="$3"

fromDir="$(realpath "${fromDir}")"
docDir="$(realpath "${docDir}")"
indexFile="$(realpath "${indexFile}")"

if [[ ! -d "${fromDir}" ]]; then
  Log::fatal "From directory '${fromDir}' does not exists"
fi
if [[ ! -r "${fromDir}" ]]; then
  Log::fatal "From directory '${fromDir}' is not readable"
fi

mkdir -p "${docDir}" || true
if [[ ! -w "${docDir}" ]]; then
  Log::fatal "From directory '${fromDir}' is not writeable"
fi

if ! Assert::fileWritable "${indexFile}"; then
  Log::fatal "File ${indexFile} is not writeable"
fi

ShellDoc::generateShellDocsFromDir \
  "${fromDir}" \
  "${docDir}" \
  "${indexFile}"
