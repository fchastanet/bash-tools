#!/usr/bin/env bash

#####################################
# GENERATED FILE FROM src/build/generateShellDoc.sh
# DO NOT EDIT IT
#####################################

# shellcheck disable=SC2034
SCRIPT_NAME=${0##*/}
# shellcheck disable=SC2034
CURRENT_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
BIN_DIR=$(cd "$(readlink -e "${BASH_SOURCE[0]%/*}")" && pwd -P)
ROOT_DIR="$(cd "${BIN_DIR}/.." && pwd -P)"
# shellcheck disable=SC2034
SRC_DIR="${ROOT_DIR}/lib"

# shellcheck disable=SC2034
((failures = 0)) || true

shopt -s expand_aliases

# Bash will remember & return the highest exit code in a chain of pipes.
# This way you can catch the error inside pipes, e.g. mysqldump | gzip
set -o pipefail
set -o errexit

# a log is generated when a command fails
set -o errtrace

# use nullglob so that (file*.php) will return an empty array if no file matches the wildcard
shopt -s nullglob

export TERM=xterm-256color

#avoid interactive install
export DEBIAN_FRONTEND=noninteractive
export DEBCONF_NONINTERACTIVE_SEEN=true

# FUNCTIONS

if [[ -t 0 ]]; then
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  export readonly __ERROR_COLOR='\e[31m'      # Red
  export readonly __INFO_COLOR='\e[44m'       # white on lightBlue
  export readonly __SUCCESS_COLOR='\e[32m'    # Green
  export readonly __WARNING_COLOR='\e[33m'    # Yellow
  export readonly __SKIPPED_COLOR='\e[93m'    # Light Yellow
  export readonly __TEST_COLOR='\e[100m'      # Light magenta
  export readonly __TEST_ERROR_COLOR='\e[41m' # white on red
  export readonly __SKIPPED_COLOR='\e[33m'    # Yellow
  export readonly __DEBUG_COLOR='\e[37m'      # Grey
  # Internal: reset color
  export readonly __RESET_COLOR='\e[0m' # Reset Color
  # shellcheck disable=SC2155,SC2034
  export readonly __HELP_EXAMPLE="$(echo -e "\e[1;30m")"
  # shellcheck disable=SC2155,SC2034
  export readonly __HELP_TITLE="$(echo -e "\e[1;37m")"
  # shellcheck disable=SC2155,SC2034
  export readonly __HELP_NORMAL="$(echo -e "\033[0m")"
else
  # check colors applicable https://misc.flogisoft.com/bash/tip_colors_and_formatting
  export readonly __ERROR_COLOR=''
  export readonly __INFO_COLOR=''
  export readonly __SUCCESS_COLOR=''
  export readonly __WARNING_COLOR=''
  export readonly __SKIPPED_COLOR=''
  export readonly __TEST_COLOR=''
  export readonly __TEST_ERROR_COLOR=''
  export readonly __SKIPPED_COLOR=''
  export readonly __DEBUG_COLOR=''
  # Internal: reset color
  export readonly __RESET_COLOR=''
  export readonly __HELP_EXAMPLE=''
  export readonly __HELP_TITLE=''
  export readonly __HELP_NORMAL=''
fi

# Display message using error color (red)
# @param {String} $1 message
Log::displayError() {
  echo -e "${__ERROR_COLOR}ERROR   - ${1}${__RESET_COLOR}"
}

# Display message using info color (bg light blue/fg white)
# @param {String} $1 message
Log::displayInfo() {
  echo -e "${__INFO_COLOR}INFO    - ${1}${__RESET_COLOR}"
}

# Display message using error color (red) and exit immediately with error status 1
# @param {String} $1 message
Log::fatal() {
  Log::displayError "$1"
  exit 1
}

# extract shDoc from file
#
# @param {String} $1 currentDir
# @param {String} $2 relativeFile
# @output the shell documentation in markdown format
generateShellDoc() {
  local currentDir="$1"
  local relativeFile="$2"

  (
    cd "${currentDir}" || exit 1
    "${ROOT_DIR}/vendor/fchastanet.tomdoc.sh/tomdoc.sh" "${relativeFile}"
  )
}

# generate shell doc file
#
# @param {String} $1 currentDir
# @param {String} $2 relativeFile the file from which the markdown file will be generated
# @param {String} $3 targetDocFile the markdown file generated using tomdoc
# @return 0 if file has been generated, 1 if file is empty or error
# if generated doc is empty, targetDocFile is deleted if it was existing
generateShellDocFile() {
  local currentDir="$1"
  local relativeFile="$2"
  local targetDocFile="$3"

  (
    local doc
    doc="$(generateShellDoc "${currentDir}" "${relativeFile}")"
    if [[ -n "${doc}" ]]; then
      echo "${doc}" >"${targetDocFile}"
      return 0
    else
      # empty doc
      rm -f "${targetDocFile}" || true
      return 1
    fi
  )
}

# add reference to index file
# @param {String} $1 indexFile
# @param {String} $2 title
# @param {String} $3 mdRelativeFile
appendDocToIndex() {
  local indexFile="$1"
  local title="$2"
  local mdRelativeFile="$3"

  echo "* [${relativeFile}](doc/${basenameNoExtension}.md)" >>"${indexFile}"
  echo "* [${title}](${mdRelativeFile})" >>"${indexFile}"
}

# generate doc + index
# @param {String} $1 fromDir
# @param {String} $2 docDir
# @param {String} $3 indexFile
generateShellDocsFromDir() {
  local fromDir="$1"
  local docDir="$2"
  local indexFile="$3"

  while IFS= read -r relativeFile; do
    relativeFile="${relativeFile#./}"
    local basenameNoExtension="${relativeFile%.*}"
    local targetDocFile="${docDir}/${basenameNoExtension}.md"
    local targetDocDir

    # create target doc dir
    targetDocDir="$(dirname "${targetDocFile}")"
    mkdir -p "${targetDocDir}" || {
      Log::displayError "unable to create target doc directory ${targetDocDir}"
      return 1
    }

    # generate markdown file from shell file
    Log::displayInfo "generate markdown doc for ${relativeFile} in ${targetDocFile}"

    if generateShellDocFile "${fromDir}" "${relativeFile}" "${targetDocFile}"; then
      appendDocToIndex "${indexFile}" "${relativeFile}" "${basenameNoExtension}"
    fi
  done < <(cd "${fromDir}" && find . -name "*.sh" | sort)
}

# Usage info
showHelp() {
  cat <<EOF
${__HELP_TITLE}Description:${__HELP_NORMAL} find all .sh files and generate shDoc
in markdown format in the specified target directory

${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} [-h|--help] prints this help and exits
${__HELP_TITLE}Usage:${__HELP_NORMAL} ${SCRIPT_NAME} {fromDir} {docDir} {indexFile}

  --help,-h : prints this help and exits
  fromDir   : directory from which sh files will be searched
  docDir    : target doc directory
  indexFile : the markdown index file
EOF
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help -o h -- "$@" 2>/dev/null) || {
  showHelp
  Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true; do
  case $1 in
    -h | --help)
      showHelp
      exit 0
      ;;
    --)
      shift || true
      break
      ;;
    *)
      showHelp
      Log::fatal "invalid argument $1"
      ;;
  esac
  shift || true
done

declare fromDir="$1"
declare docDir="$2"
declare indexFile="$3"

if [[ ! -d "${fromDir}" ]]; then
  Log::fatal "Directory ${fromDir} does not exists"
fi

fromDir="$(realpath "${fromDir}")"
docDir="$(realpath "${docDir}")"
indexFile="$(realpath "${indexFile}")"

generateShellDocsFromDir \
  "${fromDir}" \
  "${docDir}" \
  "${indexFile}"
