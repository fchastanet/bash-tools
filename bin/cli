#!/usr/bin/env bash

CURRENT_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
# load bash-framework
# shellcheck source=bash-framework/_bootstrap.sh
source "$( cd "${CURRENT_DIR}/.." && pwd )/bash-framework/_bootstrap.sh"

import bash-framework/Log

Framework::expectNonRootUser
import bash-framework/Database

# ensure that Ctrl-C is trapped by this script
trap 'exit 130' INT

# check dependencies
Functions::checkCommandExists docker "check https://docs.docker.com/engine/install/ubuntu/"

SCRIPT_NAME=${0##*/}
PROFILES_DIR="$(cd "${CURRENT_DIR}/.." && pwd)/conf/cliProfiles"
HOME_PROFILES_DIR="${HOME}/.bash-tools/cliProfiles"

showHelp() {
local containers
containers=$(docker ps --format '{{.Names}}'| sed -E 's/[^-]+-(.*)/\1/'| paste -sd "," -)
local profilesList=""
Functions::loadConf "cliProfiles" "default"

profilesList="$(Functions::getConfMergedList "cliProfiles" "sh" || true)"
cat << EOF
Description: easy connection to docker container

Command: ${SCRIPT_NAME} [-h|--help] prints this help and exits
Command: ${SCRIPT_NAME} [<container>] [user] [command]

    <container> : container should be one of these values (provided by 'docker ps'): 
        ${containers}
        if not provided, it will load the container specified in default configuration (${finalContainerArg})

examples:
    to connect to mysql container in bash mode with user mysql
        ${SCRIPT_NAME} mysql mysql "//bin/bash"
    to connect to web container with user root
        ${SCRIPT_NAME} web root

you can override these mappings by providing your own profile in ${CLI_PROFILE_HOME}
    
This script will be executed with the variables userArg containerArg commandArg set as specified in command line
and should provide value for the following variables finalUserArg finalContainerArg finalCommandArg

List of available profiles (from ${PROFILES_DIR} and overridable in ${HOME_PROFILES_DIR}): 
${profilesList}
EOF
}

# Internal function that can be used in conf profiles to load the dsn file
loadDsn() {
    local dsn="$1"
    local dsnFile
    dsnFile="$(Functions::getAbsoluteConfFile "dsn" "${dsn}" "env")"
    Database::checkDsnFile "${dsnFile}"
    # shellcheck source=/conf/dsn/default.local.env
    # shellcheck disable=SC1091
    source "${dsnFile}"
}

# read command parameters
# $@ is all command line parameters passed to the script.
# -o is for short options like -h
# -l is for long options with double dash like --help
# the comma separates different long options
options=$(getopt -l help -o h -- "$@" 2> /dev/null) || {
    showHelp
    Log::fatal "invalid options specified"
}

eval set -- "${options}"
while true
do
case $1 in
-h|--help)
    showHelp
    exit 0
    ;;
--)
    shift
    break;;
*)
    showHelp
    Log::fatal "invalid argument $1"
esac
shift
done

declare containerArg="$1"
declare userArg
declare -a commandArg
if shift; then
    userArg="$1"
fi
if shift; then
    commandArg=("$@")
fi

# load default conf file
Functions::loadConf "cliProfiles" "default"
# try to load config file associated to container if provided
if [[ -n "${containerArg}" ]]; then
    Functions::loadConf "cliProfiles" "${containerArg}" || {
        # conf file not existing fallback to provided args or to default ones if not provided
        finalContainerArg="${containerArg}"
        finalUserArg=${userArg:-${finalUserArg}}
        finalCommandArg=${commandArg:-${finalCommandArg}}
    }
fi

declare -a cmd=()
if [[ "$(Functions::isWindows; echo $?)" = "1" ]]; then
    # open tty for git bash
    cmd+=(winpty)
fi
INTERACTIVE_MODE="-i"
if ! read -r -t 0; then
  # command is not piped
  INTERACTIVE_MODE+="t"
fi

cmd+=(docker)
cmd+=(exec)
cmd+=("${INTERACTIVE_MODE}")
# ensure column/lines will be updated upon terminal resize
cmd+=(-e)
cmd+=("COLUMNS=$(tput cols)")
cmd+=(-e)
cmd+=("LINES=$(tput lines)")

cmd+=("--user=${finalUserArg}")
cmd+=("${finalContainerArg}")
cmd+=("${finalCommandArg[@]}")
(>&2 echo MSYS_NO_PATHCONV=1 MSYS2_ARG_CONV_EXCL='*' "${cmd[@]}")
MSYS_NO_PATHCONV=1 MSYS2_ARG_CONV_EXCL='*' "${cmd[@]}"
